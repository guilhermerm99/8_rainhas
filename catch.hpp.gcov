        -:    0:Source:catch.hpp
        -:    0:Graph:testa_rainhas.gcno
        -:    0:Data:testa_rainhas.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: *  Catch v2.2.1
        -:    3: *  Generated: 2018-03-11 12:01:31.654719
        -:    4: *  ----------------------------------------------------------
        -:    5: *  This file has been merged from multiple headers. Please don't edit it directly
        -:    6: *  Copyright (c) 2018 Two Blue Cubes Ltd. All rights reserved.
        -:    7: *
        -:    8: *  Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    9: *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:   10: */
        -:   11:#ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
        -:   12:#define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
        -:   13:// start catch.hpp
        -:   14:
        -:   15:
        -:   16:#define CATCH_VERSION_MAJOR 2
        -:   17:#define CATCH_VERSION_MINOR 2
        -:   18:#define CATCH_VERSION_PATCH 1
        -:   19:
        -:   20:#ifdef __clang__
        -:   21:#    pragma clang system_header
        -:   22:#elif defined __GNUC__
        -:   23:#    pragma GCC system_header
        -:   24:#endif
        -:   25:
        -:   26:// start catch_suppress_warnings.h
        -:   27:
        -:   28:#ifdef __clang__
        -:   29:#   ifdef __ICC // icpc defines the __clang__ macro
        -:   30:#       pragma warning(push)
        -:   31:#       pragma warning(disable: 161 1682)
        -:   32:#   else // __ICC
        -:   33:#       pragma clang diagnostic ignored "-Wunused-variable"
        -:   34:#       pragma clang diagnostic push
        -:   35:#       pragma clang diagnostic ignored "-Wpadded"
        -:   36:#       pragma clang diagnostic ignored "-Wswitch-enum"
        -:   37:#       pragma clang diagnostic ignored "-Wcovered-switch-default"
        -:   38:#    endif
        -:   39:#elif defined __GNUC__
        -:   40:#    pragma GCC diagnostic ignored "-Wunused-variable"
        -:   41:#    pragma GCC diagnostic ignored "-Wparentheses"
        -:   42:#    pragma GCC diagnostic push
        -:   43:#    pragma GCC diagnostic ignored "-Wpadded"
        -:   44:#endif
        -:   45:// end catch_suppress_warnings.h
        -:   46:#if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)
        -:   47:#  define CATCH_IMPL
        -:   48:#  define CATCH_CONFIG_ALL_PARTS
        -:   49:#endif
        -:   50:
        -:   51:// In the impl file, we want to have access to all parts of the headers
        -:   52:// Can also be used to sanely support PCHs
        -:   53:#if defined(CATCH_CONFIG_ALL_PARTS)
        -:   54:#  define CATCH_CONFIG_EXTERNAL_INTERFACES
        -:   55:#  if defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -:   56:#    undef CATCH_CONFIG_DISABLE_MATCHERS
        -:   57:#  endif
        -:   58:#  define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
        -:   59:#endif
        -:   60:
        -:   61:#if !defined(CATCH_CONFIG_IMPL_ONLY)
        -:   62:// start catch_platform.h
        -:   63:
        -:   64:#ifdef __APPLE__
        -:   65:# include <TargetConditionals.h>
        -:   66:# if TARGET_OS_OSX == 1
        -:   67:#  define CATCH_PLATFORM_MAC
        -:   68:# elif TARGET_OS_IPHONE == 1
        -:   69:#  define CATCH_PLATFORM_IPHONE
        -:   70:# endif
        -:   71:
        -:   72:#elif defined(linux) || defined(__linux) || defined(__linux__)
        -:   73:#  define CATCH_PLATFORM_LINUX
        -:   74:
        -:   75:#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER)
        -:   76:#  define CATCH_PLATFORM_WINDOWS
        -:   77:#endif
        -:   78:
        -:   79:// end catch_platform.h
        -:   80:
        -:   81:#ifdef CATCH_IMPL
        -:   82:#  ifndef CLARA_CONFIG_MAIN
        -:   83:#    define CLARA_CONFIG_MAIN_NOT_DEFINED
        -:   84:#    define CLARA_CONFIG_MAIN
        -:   85:#  endif
        -:   86:#endif
        -:   87:
        -:   88:// start catch_user_interfaces.h
        -:   89:
        -:   90:namespace Catch {
        -:   91:    unsigned int rngSeed();
        -:   92:}
        -:   93:
        -:   94:// end catch_user_interfaces.h
        -:   95:// start catch_tag_alias_autoregistrar.h
        -:   96:
        -:   97:// start catch_common.h
        -:   98:
        -:   99:// start catch_compiler_capabilities.h
        -:  100:
        -:  101:// Detect a number of compiler features - by compiler
        -:  102:// The following features are defined:
        -:  103://
        -:  104:// CATCH_CONFIG_COUNTER : is the __COUNTER__ macro supported?
        -:  105:// CATCH_CONFIG_WINDOWS_SEH : is Windows SEH supported?
        -:  106:// CATCH_CONFIG_POSIX_SIGNALS : are POSIX signals supported?
        -:  107:// ****************
        -:  108:// Note to maintainers: if new toggles are added please document them
        -:  109:// in configuration.md, too
        -:  110:// ****************
        -:  111:
        -:  112:// In general each macro has a _NO_<feature name> form
        -:  113:// (e.g. CATCH_CONFIG_NO_POSIX_SIGNALS) which disables the feature.
        -:  114:// Many features, at point of detection, define an _INTERNAL_ macro, so they
        -:  115:// can be combined, en-mass, with the _NO_ forms later.
        -:  116:
        -:  117:#ifdef __cplusplus
        -:  118:
        -:  119:#  if __cplusplus >= 201402L
        -:  120:#    define CATCH_CPP14_OR_GREATER
        -:  121:#  endif
        -:  122:
        -:  123:#  if __cplusplus >= 201703L
        -:  124:#    define CATCH_CPP17_OR_GREATER
        -:  125:#  endif
        -:  126:
        -:  127:#endif
        -:  128:
        -:  129:#if defined(CATCH_CPP17_OR_GREATER)
        -:  130:#  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
        -:  131:#endif
        -:  132:
        -:  133:#ifdef __clang__
        -:  134:
        -:  135:#       define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -:  136:            _Pragma( "clang diagnostic push" ) \
        -:  137:            _Pragma( "clang diagnostic ignored \"-Wexit-time-destructors\"" ) \
        -:  138:            _Pragma( "clang diagnostic ignored \"-Wglobal-constructors\"")
        -:  139:#       define CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \
        -:  140:            _Pragma( "clang diagnostic pop" )
        -:  141:
        -:  142:#       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
        -:  143:            _Pragma( "clang diagnostic push" ) \
        -:  144:            _Pragma( "clang diagnostic ignored \"-Wparentheses\"" )
        -:  145:#       define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \
        -:  146:            _Pragma( "clang diagnostic pop" )
        -:  147:
        -:  148:#endif // __clang__
        -:  149:
        -:  150:////////////////////////////////////////////////////////////////////////////////
        -:  151:// Assume that non-Windows platforms support posix signals by default
        -:  152:#if !defined(CATCH_PLATFORM_WINDOWS)
        -:  153:    #define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS
        -:  154:#endif
        -:  155:
        -:  156:////////////////////////////////////////////////////////////////////////////////
        -:  157:// We know some environments not to support full POSIX signals
        -:  158:#if defined(__CYGWIN__) || defined(__QNX__) || defined(__EMSCRIPTEN__) || defined(__DJGPP__)
        -:  159:    #define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
        -:  160:#endif
        -:  161:
        -:  162:#ifdef __OS400__
        -:  163:#       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
        -:  164:#       define CATCH_CONFIG_COLOUR_NONE
        -:  165:#endif
        -:  166:
        -:  167:////////////////////////////////////////////////////////////////////////////////
        -:  168:// Cygwin
        -:  169:#ifdef __CYGWIN__
        -:  170:
        -:  171:// Required for some versions of Cygwin to declare gettimeofday
        -:  172:// see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin
        -:  173:#   define _BSD_SOURCE
        -:  174:
        -:  175:#endif // __CYGWIN__
        -:  176:
        -:  177:////////////////////////////////////////////////////////////////////////////////
        -:  178:// Visual C++
        -:  179:#ifdef _MSC_VER
        -:  180:
        -:  181:#  if _MSC_VER >= 1900 // Visual Studio 2015 or newer
        -:  182:#    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
        -:  183:#  endif
        -:  184:
        -:  185:// Universal Windows platform does not support SEH
        -:  186:// Or console colours (or console at all...)
        -:  187:#  if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
        -:  188:#    define CATCH_CONFIG_COLOUR_NONE
        -:  189:#  else
        -:  190:#    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH
        -:  191:#  endif
        -:  192:
        -:  193:#endif // _MSC_VER
        -:  194:
        -:  195:////////////////////////////////////////////////////////////////////////////////
        -:  196:
        -:  197:// DJGPP
        -:  198:#ifdef __DJGPP__
        -:  199:#  define CATCH_INTERNAL_CONFIG_NO_WCHAR
        -:  200:#endif // __DJGPP__
        -:  201:
        -:  202:////////////////////////////////////////////////////////////////////////////////
        -:  203:
        -:  204:// Use of __COUNTER__ is suppressed during code analysis in
        -:  205:// CLion/AppCode 2017.2.x and former, because __COUNTER__ is not properly
        -:  206:// handled by it.
        -:  207:// Otherwise all supported compilers support COUNTER macro,
        -:  208:// but user still might want to turn it off
        -:  209:#if ( !defined(__JETBRAINS_IDE__) || __JETBRAINS_IDE__ >= 20170300L )
        -:  210:    #define CATCH_INTERNAL_CONFIG_COUNTER
        -:  211:#endif
        -:  212:
        -:  213:#if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)
        -:  214:#   define CATCH_CONFIG_COUNTER
        -:  215:#endif
        -:  216:#if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) && !defined(CATCH_CONFIG_NO_WINDOWS_SEH) && !defined(CATCH_CONFIG_WINDOWS_SEH)
        -:  217:#   define CATCH_CONFIG_WINDOWS_SEH
        -:  218:#endif
        -:  219:// This is set by default, because we assume that unix compilers are posix-signal-compatible by default.
        -:  220:#if defined(CATCH_INTERNAL_CONFIG_POSIX_SIGNALS) && !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_POSIX_SIGNALS)
        -:  221:#   define CATCH_CONFIG_POSIX_SIGNALS
        -:  222:#endif
        -:  223:// This is set by default, because we assume that compilers with no wchar_t support are just rare exceptions.
        -:  224:#if !defined(CATCH_INTERNAL_CONFIG_NO_WCHAR) && !defined(CATCH_CONFIG_NO_WCHAR) && !defined(CATCH_CONFIG_WCHAR)
        -:  225:#   define CATCH_CONFIG_WCHAR
        -:  226:#endif
        -:  227:
        -:  228:#if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) && !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) && !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
        -:  229:#  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
        -:  230:#endif
        -:  231:
        -:  232:#if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)
        -:  233:#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS
        -:  234:#   define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS
        -:  235:#endif
        -:  236:#if !defined(CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS)
        -:  237:#   define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
        -:  238:#   define CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS
        -:  239:#endif
        -:  240:
        -:  241:// end catch_compiler_capabilities.h
        -:  242:#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
        -:  243:#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
        -:  244:#ifdef CATCH_CONFIG_COUNTER
        -:  245:#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )
        -:  246:#else
        -:  247:#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )
        -:  248:#endif
        -:  249:
        -:  250:#include <iosfwd>
        -:  251:#include <string>
        -:  252:#include <cstdint>
        -:  253:
        -:  254:namespace Catch {
        -:  255:
        -:  256:    struct CaseSensitive { enum Choice {
        -:  257:        Yes,
        -:  258:        No
        -:  259:    }; };
        -:  260:
        -:  261:    class NonCopyable {
        -:  262:        NonCopyable( NonCopyable const& )              = delete;
        -:  263:        NonCopyable( NonCopyable && )                  = delete;
        -:  264:        NonCopyable& operator = ( NonCopyable const& ) = delete;
        -:  265:        NonCopyable& operator = ( NonCopyable && )     = delete;
        -:  266:
        -:  267:    protected:
        -:  268:        NonCopyable();
        -:  269:        virtual ~NonCopyable();
        -:  270:    };
        -:  271:
        -:  272:    struct SourceLineInfo {
        -:  273:
        -:  274:        SourceLineInfo() = delete;
       83:  275:        SourceLineInfo( char const* _file, std::size_t _line ) noexcept
       83:  276:        :   file( _file ),
       83:  277:            line( _line )
       83:  278:        {}
        -:  279:
        -:  280:        SourceLineInfo( SourceLineInfo const& other )        = default;
        -:  281:        SourceLineInfo( SourceLineInfo && )                  = default;
        -:  282:        SourceLineInfo& operator = ( SourceLineInfo const& ) = default;
        -:  283:        SourceLineInfo& operator = ( SourceLineInfo && )     = default;
        -:  284:
        -:  285:        bool empty() const noexcept;
        -:  286:        bool operator == ( SourceLineInfo const& other ) const noexcept;
        -:  287:        bool operator < ( SourceLineInfo const& other ) const noexcept;
        -:  288:
        -:  289:        char const* file;
        -:  290:        std::size_t line;
        -:  291:    };
        -:  292:
        -:  293:    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );
        -:  294:
        -:  295:    // Use this in variadic streaming macros to allow
        -:  296:    //    >> +StreamEndStop
        -:  297:    // as well as
        -:  298:    //    >> stuff +StreamEndStop
        -:  299:    struct StreamEndStop {
        -:  300:        std::string operator+() const;
        -:  301:    };
        -:  302:    template<typename T>
        -:  303:    T const& operator + ( T const& value, StreamEndStop ) {
        -:  304:        return value;
        -:  305:    }
        -:  306:}
        -:  307:
        -:  308:#define CATCH_INTERNAL_LINEINFO \
        -:  309:    ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )
        -:  310:
        -:  311:// end catch_common.h
        -:  312:namespace Catch {
        -:  313:
        -:  314:    struct RegistrarForTagAliases {
        -:  315:        RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
        -:  316:    };
        -:  317:
        -:  318:} // end namespace Catch
        -:  319:
        -:  320:#define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \
        -:  321:    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -:  322:    namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); } \
        -:  323:    CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS
        -:  324:
        -:  325:// end catch_tag_alias_autoregistrar.h
        -:  326:// start catch_test_registry.h
        -:  327:
        -:  328:// start catch_interfaces_testcase.h
        -:  329:
        -:  330:#include <vector>
        -:  331:#include <memory>
        -:  332:
        -:  333:namespace Catch {
        -:  334:
        -:  335:    class TestSpec;
        -:  336:
        -:  337:    struct ITestInvoker {
        -:  338:        virtual void invoke () const = 0;
        -:  339:        virtual ~ITestInvoker();
        -:  340:    };
        -:  341:
        -:  342:    using ITestCasePtr = std::shared_ptr<ITestInvoker>;
        -:  343:
        -:  344:    class TestCase;
        -:  345:    struct IConfig;
        -:  346:
        -:  347:    struct ITestCaseRegistry {
        -:  348:        virtual ~ITestCaseRegistry();
        -:  349:        virtual std::vector<TestCase> const& getAllTests() const = 0;
        -:  350:        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;
        -:  351:    };
        -:  352:
        -:  353:    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );
        -:  354:    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );
        -:  355:    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );
        -:  356:
        -:  357:}
        -:  358:
        -:  359:// end catch_interfaces_testcase.h
        -:  360:// start catch_stringref.h
        -:  361:
        -:  362:#include <cstddef>
        -:  363:#include <string>
        -:  364:#include <iosfwd>
        -:  365:
        -:  366:namespace Catch {
        -:  367:
        -:  368:    class StringData;
        -:  369:
        -:  370:    /// A non-owning string class (similar to the forthcoming std::string_view)
        -:  371:    /// Note that, because a StringRef may be a substring of another string,
        -:  372:    /// it may not be null terminated. c_str() must return a null terminated
        -:  373:    /// string, however, and so the StringRef will internally take ownership
        -:  374:    /// (taking a copy), if necessary. In theory this ownership is not externally
        -:  375:    /// visible - but it does mean (substring) StringRefs should not be shared between
        -:  376:    /// threads.
        -:  377:    class StringRef {
        -:  378:    public:
        -:  379:        using size_type = std::size_t;
        -:  380:
        -:  381:    private:
        -:  382:        friend struct StringRefTestAccess;
        -:  383:
        -:  384:        char const* m_start;
        -:  385:        size_type m_size;
        -:  386:
        -:  387:        char* m_data = nullptr;
        -:  388:
        -:  389:        void takeOwnership();
        -:  390:
        -:  391:        static constexpr char const* const s_empty = "";
        -:  392:
        -:  393:    public: // construction/ assignment
       53:  394:        StringRef() noexcept
       53:  395:        :   StringRef( s_empty, 0 )
       53:  396:        {}
        -:  397:
      131:  398:        StringRef( StringRef const& other ) noexcept
      131:  399:        :   m_start( other.m_start ),
      131:  400:            m_size( other.m_size )
      131:  401:        {}
        -:  402:
        -:  403:        StringRef( StringRef&& other ) noexcept
        -:  404:        :   m_start( other.m_start ),
        -:  405:            m_size( other.m_size ),
        -:  406:            m_data( other.m_data )
        -:  407:        {
        -:  408:            other.m_data = nullptr;
        -:  409:        }
        -:  410:
        -:  411:        StringRef( char const* rawChars ) noexcept;
        -:  412:
      239:  413:        StringRef( char const* rawChars, size_type size ) noexcept
      239:  414:        :   m_start( rawChars ),
      239:  415:            m_size( size )
      239:  416:        {}
        -:  417:
        1:  418:        StringRef( std::string const& stdString ) noexcept
        1:  419:        :   m_start( stdString.c_str() ),
        1:  420:            m_size( stdString.size() )
        1:  421:        {}
        -:  422:
      371:  423:        ~StringRef() noexcept {
     371*:  424:            delete[] m_data;
      371:  425:        }
        -:  426:
      102:  427:        auto operator = ( StringRef const &other ) noexcept -> StringRef& {
     102*:  428:            delete[] m_data;
      102:  429:            m_data = nullptr;
      102:  430:            m_start = other.m_start;
      102:  431:            m_size = other.m_size;
      102:  432:            return *this;
        -:  433:        }
        -:  434:
        -:  435:        operator std::string() const;
        -:  436:
        -:  437:        void swap( StringRef& other ) noexcept;
        -:  438:
        -:  439:    public: // operators
        -:  440:        auto operator == ( StringRef const& other ) const noexcept -> bool;
        -:  441:        auto operator != ( StringRef const& other ) const noexcept -> bool;
        -:  442:
        -:  443:        auto operator[] ( size_type index ) const noexcept -> char;
        -:  444:
        -:  445:    public: // named queries
        1:  446:        auto empty() const noexcept -> bool {
        1:  447:            return m_size == 0;
        -:  448:        }
    #####:  449:        auto size() const noexcept -> size_type {
    #####:  450:            return m_size;
        -:  451:        }
        -:  452:
        -:  453:        auto numberOfCharacters() const noexcept -> size_type;
        -:  454:        auto c_str() const -> char const*;
        -:  455:
        -:  456:    public: // substrings and searches
        -:  457:        auto substr( size_type start, size_type size ) const noexcept -> StringRef;
        -:  458:
        -:  459:        // Returns the current start pointer.
        -:  460:        // Note that the pointer can change when if the StringRef is a substring
        -:  461:        auto currentData() const noexcept -> char const*;
        -:  462:
        -:  463:    private: // ownership queries - may not be consistent between calls
        -:  464:        auto isOwned() const noexcept -> bool;
        -:  465:        auto isSubstring() const noexcept -> bool;
        -:  466:    };
        -:  467:
        -:  468:    auto operator + ( StringRef const& lhs, StringRef const& rhs ) -> std::string;
        -:  469:    auto operator + ( StringRef const& lhs, char const* rhs ) -> std::string;
        -:  470:    auto operator + ( char const* lhs, StringRef const& rhs ) -> std::string;
        -:  471:
        -:  472:    auto operator += ( std::string& lhs, StringRef const& sr ) -> std::string&;
        -:  473:    auto operator << ( std::ostream& os, StringRef const& sr ) -> std::ostream&;
        -:  474:
       51:  475:    inline auto operator "" _sr( char const* rawChars, std::size_t size ) noexcept -> StringRef {
       51:  476:        return StringRef( rawChars, size );
        -:  477:    }
        -:  478:
        -:  479:} // namespace Catch
        -:  480:
        -:  481:// end catch_stringref.h
        -:  482:namespace Catch {
        -:  483:
        -:  484:template<typename C>
        -:  485:class TestInvokerAsMethod : public ITestInvoker {
        -:  486:    void (C::*m_testAsMethod)();
        -:  487:public:
        -:  488:    TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}
        -:  489:
        -:  490:    void invoke() const override {
        -:  491:        C obj;
        -:  492:        (obj.*m_testAsMethod)();
        -:  493:    }
        -:  494:};
        -:  495:
        -:  496:auto makeTestInvoker( void(*testAsFunction)() ) noexcept -> ITestInvoker*;
        -:  497:
        -:  498:template<typename C>
        -:  499:auto makeTestInvoker( void (C::*testAsMethod)() ) noexcept -> ITestInvoker* {
        -:  500:    return new(std::nothrow) TestInvokerAsMethod<C>( testAsMethod );
        -:  501:}
        -:  502:
        -:  503:struct NameAndTags {
        -:  504:    NameAndTags( StringRef const& name_ = StringRef(), StringRef const& tags_ = StringRef() ) noexcept;
        -:  505:    StringRef name;
        -:  506:    StringRef tags;
        -:  507:};
        -:  508:
        -:  509:struct AutoReg : NonCopyable {
        -:  510:    AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept;
        -:  511:    ~AutoReg();
        -:  512:};
        -:  513:
        -:  514:} // end namespace Catch
        -:  515:
        -:  516:#if defined(CATCH_CONFIG_DISABLE)
        -:  517:    #define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \
        -:  518:        static void TestName()
        -:  519:    #define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \
        -:  520:        namespace{                        \
        -:  521:            struct TestName : ClassName { \
        -:  522:                void test();              \
        -:  523:            };                            \
        -:  524:        }                                 \
        -:  525:        void TestName::test()
        -:  526:
        -:  527:#endif
        -:  528:
        -:  529:    ///////////////////////////////////////////////////////////////////////////////
        -:  530:    #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
        -:  531:        static void TestName(); \
        -:  532:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -:  533:        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, "", Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \
        -:  534:        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \
        -:  535:        static void TestName()
        -:  536:    #define INTERNAL_CATCH_TESTCASE( ... ) \
        -:  537:        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )
        -:  538:
        -:  539:    ///////////////////////////////////////////////////////////////////////////////
        -:  540:    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
        -:  541:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -:  542:        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &QualifiedMethod ), CATCH_INTERNAL_LINEINFO, "&" #QualifiedMethod, Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \
        -:  543:        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS
        -:  544:
        -:  545:    ///////////////////////////////////////////////////////////////////////////////
        -:  546:    #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
        -:  547:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -:  548:        namespace{ \
        -:  549:            struct TestName : ClassName{ \
        -:  550:                void test(); \
        -:  551:            }; \
        -:  552:            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( Catch::makeTestInvoker( &TestName::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \
        -:  553:        } \
        -:  554:        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \
        -:  555:        void TestName::test()
        -:  556:    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
        -:  557:        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )
        -:  558:
        -:  559:    ///////////////////////////////////////////////////////////////////////////////
        -:  560:    #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
        -:  561:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -:  562:        Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, "", Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \
        -:  563:        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS
        -:  564:
        -:  565:// end catch_test_registry.h
        -:  566:// start catch_capture.hpp
        -:  567:
        -:  568:// start catch_assertionhandler.h
        -:  569:
        -:  570:// start catch_assertioninfo.h
        -:  571:
        -:  572:// start catch_result_type.h
        -:  573:
        -:  574:namespace Catch {
        -:  575:
        -:  576:    // ResultWas::OfType enum
        -:  577:    struct ResultWas { enum OfType {
        -:  578:        Unknown = -1,
        -:  579:        Ok = 0,
        -:  580:        Info = 1,
        -:  581:        Warning = 2,
        -:  582:
        -:  583:        FailureBit = 0x10,
        -:  584:
        -:  585:        ExpressionFailed = FailureBit | 1,
        -:  586:        ExplicitFailure = FailureBit | 2,
        -:  587:
        -:  588:        Exception = 0x100 | FailureBit,
        -:  589:
        -:  590:        ThrewException = Exception | 1,
        -:  591:        DidntThrowException = Exception | 2,
        -:  592:
        -:  593:        FatalErrorCondition = 0x200 | FailureBit
        -:  594:
        -:  595:    }; };
        -:  596:
        -:  597:    bool isOk( ResultWas::OfType resultType );
        -:  598:    bool isJustInfo( int flags );
        -:  599:
        -:  600:    // ResultDisposition::Flags enum
        -:  601:    struct ResultDisposition { enum Flags {
        -:  602:        Normal = 0x01,
        -:  603:
        -:  604:        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
        -:  605:        FalseTest = 0x04,           // Prefix expression with !
        -:  606:        SuppressFail = 0x08         // Failures are reported but do not fail the test
        -:  607:    }; };
        -:  608:
        -:  609:    ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );
        -:  610:
        -:  611:    bool shouldContinueOnFailure( int flags );
       41:  612:    inline bool isFalseTest( int flags ) { return ( flags & ResultDisposition::FalseTest ) != 0; }
        -:  613:    bool shouldSuppressFailure( int flags );
        -:  614:
        -:  615:} // end namespace Catch
        -:  616:
        -:  617:// end catch_result_type.h
        -:  618:namespace Catch {
        -:  619:
        -:  620:    struct AssertionInfo
        -:  621:    {
        -:  622:        StringRef macroName;
        -:  623:        SourceLineInfo lineInfo;
        -:  624:        StringRef capturedExpression;
        -:  625:        ResultDisposition::Flags resultDisposition;
        -:  626:
        -:  627:        // We want to delete this constructor but a compiler bug in 4.8 means
        -:  628:        // the struct is then treated as non-aggregate
        -:  629:        //AssertionInfo() = delete;
        -:  630:    };
        -:  631:
        -:  632:} // end namespace Catch
        -:  633:
        -:  634:// end catch_assertioninfo.h
        -:  635:// start catch_decomposer.h
        -:  636:
        -:  637:// start catch_tostring.h
        -:  638:
        -:  639:#include <vector>
        -:  640:#include <cstddef>
        -:  641:#include <type_traits>
        -:  642:#include <string>
        -:  643:// start catch_stream.h
        -:  644:
        -:  645:#include <iosfwd>
        -:  646:#include <cstddef>
        -:  647:#include <ostream>
        -:  648:
        -:  649:namespace Catch {
        -:  650:
        -:  651:    std::ostream& cout();
        -:  652:    std::ostream& cerr();
        -:  653:    std::ostream& clog();
        -:  654:
        -:  655:    class StringRef;
        -:  656:
        -:  657:    struct IStream {
        -:  658:        virtual ~IStream();
        -:  659:        virtual std::ostream& stream() const = 0;
        -:  660:    };
        -:  661:
        -:  662:    auto makeStream( StringRef const &filename ) -> IStream const*;
        -:  663:
        -:  664:    class ReusableStringStream {
        -:  665:        std::size_t m_index;
        -:  666:        std::ostream* m_oss;
        -:  667:    public:
        -:  668:        ReusableStringStream();
        -:  669:        ~ReusableStringStream();
        -:  670:
        -:  671:        auto str() const -> std::string;
        -:  672:
        -:  673:        template<typename T>
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA27_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA17_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA37_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA20_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsINS_9StringRefEEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA23_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA53_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIcEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA2_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA36_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA16_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsImEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsISt5_SetwEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA13_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA25_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsINS_14SourceLineInfoEEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsINS_14LazyExpressionEEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA3_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA9_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIFRSt8ios_baseS3_EEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA1_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIdEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIfEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsISt13_SetprecisionEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA4_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIyEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA5_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIxEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIjEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIPKcEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsISt8_SetfillIcEEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsINS_16TestCaseTracking11TrackerBase10CycleStateEEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA18_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA21_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA15_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA22_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA67_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA19_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
_ZN5Catch20ReusableStringStreamlsIA12_cEERS0_RKT_:
    #####:  674:        auto operator << ( T const& value ) -> ReusableStringStream& {
    #####:  675:            *m_oss << value;
    #####:  676:            return *this;
        -:  677:        }
------------------
    #####:  678:        auto get() -> std::ostream& { return *m_oss; }
        -:  679:
        -:  680:        static void cleanup();
        -:  681:    };
        -:  682:}
        -:  683:
        -:  684:// end catch_stream.h
        -:  685:
        -:  686:#ifdef __OBJC__
        -:  687:// start catch_objc_arc.hpp
        -:  688:
        -:  689:#import <Foundation/Foundation.h>
        -:  690:
        -:  691:#ifdef __has_feature
        -:  692:#define CATCH_ARC_ENABLED __has_feature(objc_arc)
        -:  693:#else
        -:  694:#define CATCH_ARC_ENABLED 0
        -:  695:#endif
        -:  696:
        -:  697:void arcSafeRelease( NSObject* obj );
        -:  698:id performOptionalSelector( id obj, SEL sel );
        -:  699:
        -:  700:#if !CATCH_ARC_ENABLED
        -:  701:inline void arcSafeRelease( NSObject* obj ) {
        -:  702:    [obj release];
        -:  703:}
        -:  704:inline id performOptionalSelector( id obj, SEL sel ) {
        -:  705:    if( [obj respondsToSelector: sel] )
        -:  706:        return [obj performSelector: sel];
        -:  707:    return nil;
        -:  708:}
        -:  709:#define CATCH_UNSAFE_UNRETAINED
        -:  710:#define CATCH_ARC_STRONG
        -:  711:#else
        -:  712:inline void arcSafeRelease( NSObject* ){}
        -:  713:inline id performOptionalSelector( id obj, SEL sel ) {
        -:  714:#ifdef __clang__
        -:  715:#pragma clang diagnostic push
        -:  716:#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        -:  717:#endif
        -:  718:    if( [obj respondsToSelector: sel] )
        -:  719:        return [obj performSelector: sel];
        -:  720:#ifdef __clang__
        -:  721:#pragma clang diagnostic pop
        -:  722:#endif
        -:  723:    return nil;
        -:  724:}
        -:  725:#define CATCH_UNSAFE_UNRETAINED __unsafe_unretained
        -:  726:#define CATCH_ARC_STRONG __strong
        -:  727:#endif
        -:  728:
        -:  729:// end catch_objc_arc.hpp
        -:  730:#endif
        -:  731:
        -:  732:#ifdef _MSC_VER
        -:  733:#pragma warning(push)
        -:  734:#pragma warning(disable:4180) // We attempt to stream a function (address) by const&, which MSVC complains about but is harmless
        -:  735:#endif
        -:  736:
        -:  737:// We need a dummy global operator<< so we can bring it into Catch namespace later
        -:  738:struct Catch_global_namespace_dummy {};
        -:  739:std::ostream& operator<<(std::ostream&, Catch_global_namespace_dummy);
        -:  740:
        -:  741:namespace Catch {
        -:  742:    // Bring in operator<< from global namespace into Catch namespace
        -:  743:    using ::operator<<;
        -:  744:
        -:  745:    namespace Detail {
        -:  746:
        -:  747:        extern const std::string unprintableString;
        -:  748:
        -:  749:        std::string rawMemoryToString( const void *object, std::size_t size );
        -:  750:
        -:  751:        template<typename T>
        -:  752:        std::string rawMemoryToString( const T& object ) {
        -:  753:          return rawMemoryToString( &object, sizeof(object) );
        -:  754:        }
        -:  755:
        -:  756:        template<typename T>
        -:  757:        class IsStreamInsertable {
        -:  758:            template<typename SS, typename TT>
        -:  759:            static auto test(int)
        -:  760:                -> decltype(std::declval<SS&>() << std::declval<TT>(), std::true_type());
        -:  761:
        -:  762:            template<typename, typename>
        -:  763:            static auto test(...)->std::false_type;
        -:  764:
        -:  765:        public:
        -:  766:            static const bool value = decltype(test<std::ostream, const T&>(0))::value;
        -:  767:        };
        -:  768:
        -:  769:        template<typename E>
        -:  770:        std::string convertUnknownEnumToString( E e );
        -:  771:
        -:  772:        template<typename T>
        -:  773:        typename std::enable_if<!std::is_enum<T>::value, std::string>::type convertUnstreamable( T const& value ) {
        -:  774:#if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)
        -:  775:            (void)value;
        -:  776:            return Detail::unprintableString;
        -:  777:#else
        -:  778:            return CATCH_CONFIG_FALLBACK_STRINGIFIER(value);
        -:  779:#endif
        -:  780:        }
        -:  781:        template<typename T>
        -:  782:        typename std::enable_if<std::is_enum<T>::value, std::string>::type convertUnstreamable( T const& value ) {
        -:  783:            return convertUnknownEnumToString( value );
        -:  784:        }
        -:  785:
        -:  786:    } // namespace Detail
        -:  787:
        -:  788:    // If we decide for C++14, change these to enable_if_ts
        -:  789:    template <typename T, typename = void>
        -:  790:    struct StringMaker {
        -:  791:        template <typename Fake = T>
        -:  792:        static
        -:  793:        typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type
    #####:  794:            convert(const Fake& value) {
    #####:  795:                ReusableStringStream rss;
    #####:  796:                rss << value;
    #####:  797:                return rss.str();
    #####:  798:        }
        -:  799:
        -:  800:        template <typename Fake = T>
        -:  801:        static
        -:  802:        typename std::enable_if<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type
        -:  803:            convert( const Fake& value ) {
        -:  804:                return Detail::convertUnstreamable( value );
        -:  805:        }
        -:  806:    };
        -:  807:
        -:  808:    namespace Detail {
        -:  809:
        -:  810:        // This function dispatches all stringification requests inside of Catch.
        -:  811:        // Should be preferably called fully qualified, like ::Catch::Detail::stringify
        -:  812:        template <typename T>
    #####:  813:        std::string stringify(const T& e) {
    #####:  814:            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
        -:  815:        }
------------------
_ZN5Catch6Detail9stringifyIiEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  813:        std::string stringify(const T& e) {
    #####:  814:            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
        -:  815:        }
------------------
_ZN5Catch6Detail9stringifyIcEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  813:        std::string stringify(const T& e) {
    #####:  814:            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
        -:  815:        }
------------------
_ZN5Catch6Detail9stringifyIjEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  813:        std::string stringify(const T& e) {
    #####:  814:            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
        -:  815:        }
------------------
_ZN5Catch6Detail9stringifyIyEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  813:        std::string stringify(const T& e) {
    #####:  814:            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
        -:  815:        }
------------------
_ZN5Catch6Detail9stringifyIxEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  813:        std::string stringify(const T& e) {
    #####:  814:            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
        -:  815:        }
------------------
_ZN5Catch6Detail9stringifyINSt7__cxx1112basic_stringIwSt11char_traitsIwESaIwEEEEENS3_IcS4_IcESaIcEEERKT_:
    #####:  813:        std::string stringify(const T& e) {
    #####:  814:            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
        -:  815:        }
------------------
_ZN5Catch6Detail9stringifyINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEES7_RKT_:
    #####:  813:        std::string stringify(const T& e) {
    #####:  814:            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
        -:  815:        }
------------------
_ZN5Catch6Detail9stringifyINS_14SourceLineInfoEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  813:        std::string stringify(const T& e) {
    #####:  814:            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
        -:  815:        }
------------------
_ZN5Catch6Detail9stringifyIdEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:  813:        std::string stringify(const T& e) {
    #####:  814:            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
        -:  815:        }
------------------
        -:  816:
        -:  817:        template<typename E>
        -:  818:        std::string convertUnknownEnumToString( E e ) {
        -:  819:            return ::Catch::Detail::stringify(static_cast<typename std::underlying_type<E>::type>(e));
        -:  820:        }
        -:  821:
        -:  822:    } // namespace Detail
        -:  823:
        -:  824:    // Some predefined specializations
        -:  825:
        -:  826:    template<>
        -:  827:    struct StringMaker<std::string> {
        -:  828:        static std::string convert(const std::string& str);
        -:  829:    };
        -:  830:#ifdef CATCH_CONFIG_WCHAR
        -:  831:    template<>
        -:  832:    struct StringMaker<std::wstring> {
        -:  833:        static std::string convert(const std::wstring& wstr);
        -:  834:    };
        -:  835:#endif
        -:  836:
        -:  837:    template<>
        -:  838:    struct StringMaker<char const *> {
        -:  839:        static std::string convert(char const * str);
        -:  840:    };
        -:  841:    template<>
        -:  842:    struct StringMaker<char *> {
        -:  843:        static std::string convert(char * str);
        -:  844:    };
        -:  845:#ifdef CATCH_CONFIG_WCHAR
        -:  846:    template<>
        -:  847:    struct StringMaker<wchar_t const *> {
        -:  848:        static std::string convert(wchar_t const * str);
        -:  849:    };
        -:  850:    template<>
        -:  851:    struct StringMaker<wchar_t *> {
        -:  852:        static std::string convert(wchar_t * str);
        -:  853:    };
        -:  854:#endif
        -:  855:
        -:  856:    template<int SZ>
        -:  857:    struct StringMaker<char[SZ]> {
        -:  858:        static std::string convert(const char* str) {
        -:  859:            return ::Catch::Detail::stringify(std::string{ str });
        -:  860:        }
        -:  861:    };
        -:  862:    template<int SZ>
        -:  863:    struct StringMaker<signed char[SZ]> {
        -:  864:        static std::string convert(const char* str) {
        -:  865:            return ::Catch::Detail::stringify(std::string{ str });
        -:  866:        }
        -:  867:    };
        -:  868:    template<int SZ>
        -:  869:    struct StringMaker<unsigned char[SZ]> {
        -:  870:        static std::string convert(const char* str) {
        -:  871:            return ::Catch::Detail::stringify(std::string{ str });
        -:  872:        }
        -:  873:    };
        -:  874:
        -:  875:    template<>
        -:  876:    struct StringMaker<int> {
        -:  877:        static std::string convert(int value);
        -:  878:    };
        -:  879:    template<>
        -:  880:    struct StringMaker<long> {
        -:  881:        static std::string convert(long value);
        -:  882:    };
        -:  883:    template<>
        -:  884:    struct StringMaker<long long> {
        -:  885:        static std::string convert(long long value);
        -:  886:    };
        -:  887:    template<>
        -:  888:    struct StringMaker<unsigned int> {
        -:  889:        static std::string convert(unsigned int value);
        -:  890:    };
        -:  891:    template<>
        -:  892:    struct StringMaker<unsigned long> {
        -:  893:        static std::string convert(unsigned long value);
        -:  894:    };
        -:  895:    template<>
        -:  896:    struct StringMaker<unsigned long long> {
        -:  897:        static std::string convert(unsigned long long value);
        -:  898:    };
        -:  899:
        -:  900:    template<>
        -:  901:    struct StringMaker<bool> {
        -:  902:        static std::string convert(bool b);
        -:  903:    };
        -:  904:
        -:  905:    template<>
        -:  906:    struct StringMaker<char> {
        -:  907:        static std::string convert(char c);
        -:  908:    };
        -:  909:    template<>
        -:  910:    struct StringMaker<signed char> {
        -:  911:        static std::string convert(signed char c);
        -:  912:    };
        -:  913:    template<>
        -:  914:    struct StringMaker<unsigned char> {
        -:  915:        static std::string convert(unsigned char c);
        -:  916:    };
        -:  917:
        -:  918:    template<>
        -:  919:    struct StringMaker<std::nullptr_t> {
        -:  920:        static std::string convert(std::nullptr_t);
        -:  921:    };
        -:  922:
        -:  923:    template<>
        -:  924:    struct StringMaker<float> {
        -:  925:        static std::string convert(float value);
        -:  926:    };
        -:  927:    template<>
        -:  928:    struct StringMaker<double> {
        -:  929:        static std::string convert(double value);
        -:  930:    };
        -:  931:
        -:  932:    template <typename T>
        -:  933:    struct StringMaker<T*> {
        -:  934:        template <typename U>
        -:  935:        static std::string convert(U* p) {
        -:  936:            if (p) {
        -:  937:                return ::Catch::Detail::rawMemoryToString(p);
        -:  938:            } else {
        -:  939:                return "nullptr";
        -:  940:            }
        -:  941:        }
        -:  942:    };
        -:  943:
        -:  944:    template <typename R, typename C>
        -:  945:    struct StringMaker<R C::*> {
        -:  946:        static std::string convert(R C::* p) {
        -:  947:            if (p) {
        -:  948:                return ::Catch::Detail::rawMemoryToString(p);
        -:  949:            } else {
        -:  950:                return "nullptr";
        -:  951:            }
        -:  952:        }
        -:  953:    };
        -:  954:
        -:  955:    namespace Detail {
        -:  956:        template<typename InputIterator>
        -:  957:        std::string rangeToString(InputIterator first, InputIterator last) {
        -:  958:            ReusableStringStream rss;
        -:  959:            rss << "{ ";
        -:  960:            if (first != last) {
        -:  961:                rss << ::Catch::Detail::stringify(*first);
        -:  962:                for (++first; first != last; ++first)
        -:  963:                    rss << ", " << ::Catch::Detail::stringify(*first);
        -:  964:            }
        -:  965:            rss << " }";
        -:  966:            return rss.str();
        -:  967:        }
        -:  968:    }
        -:  969:
        -:  970:#ifdef __OBJC__
        -:  971:    template<>
        -:  972:    struct StringMaker<NSString*> {
        -:  973:        static std::string convert(NSString * nsstring) {
        -:  974:            if (!nsstring)
        -:  975:                return "nil";
        -:  976:            return std::string("@") + [nsstring UTF8String];
        -:  977:        }
        -:  978:    };
        -:  979:    template<>
        -:  980:    struct StringMaker<NSObject*> {
        -:  981:        static std::string convert(NSObject* nsObject) {
        -:  982:            return ::Catch::Detail::stringify([nsObject description]);
        -:  983:        }
        -:  984:
        -:  985:    };
        -:  986:    namespace Detail {
        -:  987:        inline std::string stringify( NSString* nsstring ) {
        -:  988:            return StringMaker<NSString*>::convert( nsstring );
        -:  989:        }
        -:  990:
        -:  991:    } // namespace Detail
        -:  992:#endif // __OBJC__
        -:  993:
        -:  994:} // namespace Catch
        -:  995:
        -:  996://////////////////////////////////////////////////////
        -:  997:// Separate std-lib types stringification, so it can be selectively enabled
        -:  998:// This means that we do not bring in
        -:  999:
        -: 1000:#if defined(CATCH_CONFIG_ENABLE_ALL_STRINGMAKERS)
        -: 1001:#  define CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER
        -: 1002:#  define CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER
        -: 1003:#  define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
        -: 1004:#endif
        -: 1005:
        -: 1006:// Separate std::pair specialization
        -: 1007:#if defined(CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER)
        -: 1008:#include <utility>
        -: 1009:namespace Catch {
        -: 1010:    template<typename T1, typename T2>
        -: 1011:    struct StringMaker<std::pair<T1, T2> > {
        -: 1012:        static std::string convert(const std::pair<T1, T2>& pair) {
        -: 1013:            ReusableStringStream rss;
        -: 1014:            rss << "{ "
        -: 1015:                << ::Catch::Detail::stringify(pair.first)
        -: 1016:                << ", "
        -: 1017:                << ::Catch::Detail::stringify(pair.second)
        -: 1018:                << " }";
        -: 1019:            return rss.str();
        -: 1020:        }
        -: 1021:    };
        -: 1022:}
        -: 1023:#endif // CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER
        -: 1024:
        -: 1025:// Separate std::tuple specialization
        -: 1026:#if defined(CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER)
        -: 1027:#include <tuple>
        -: 1028:namespace Catch {
        -: 1029:    namespace Detail {
        -: 1030:        template<
        -: 1031:            typename Tuple,
        -: 1032:            std::size_t N = 0,
        -: 1033:            bool = (N < std::tuple_size<Tuple>::value)
        -: 1034:            >
        -: 1035:            struct TupleElementPrinter {
        -: 1036:            static void print(const Tuple& tuple, std::ostream& os) {
        -: 1037:                os << (N ? ", " : " ")
        -: 1038:                    << ::Catch::Detail::stringify(std::get<N>(tuple));
        -: 1039:                TupleElementPrinter<Tuple, N + 1>::print(tuple, os);
        -: 1040:            }
        -: 1041:        };
        -: 1042:
        -: 1043:        template<
        -: 1044:            typename Tuple,
        -: 1045:            std::size_t N
        -: 1046:        >
        -: 1047:            struct TupleElementPrinter<Tuple, N, false> {
        -: 1048:            static void print(const Tuple&, std::ostream&) {}
        -: 1049:        };
        -: 1050:
        -: 1051:    }
        -: 1052:
        -: 1053:    template<typename ...Types>
        -: 1054:    struct StringMaker<std::tuple<Types...>> {
        -: 1055:        static std::string convert(const std::tuple<Types...>& tuple) {
        -: 1056:            ReusableStringStream rss;
        -: 1057:            rss << '{';
        -: 1058:            Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());
        -: 1059:            rss << " }";
        -: 1060:            return rss.str();
        -: 1061:        }
        -: 1062:    };
        -: 1063:}
        -: 1064:#endif // CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER
        -: 1065:
        -: 1066:namespace Catch {
        -: 1067:    struct not_this_one {}; // Tag type for detecting which begin/ end are being selected
        -: 1068:
        -: 1069:    // Import begin/ end from std here so they are considered alongside the fallback (...) overloads in this namespace
        -: 1070:    using std::begin;
        -: 1071:    using std::end;
        -: 1072:
        -: 1073:    not_this_one begin( ... );
        -: 1074:    not_this_one end( ... );
        -: 1075:
        -: 1076:    template <typename T>
        -: 1077:    struct is_range {
        -: 1078:        static const bool value =
        -: 1079:            !std::is_same<decltype(begin(std::declval<T>())), not_this_one>::value &&
        -: 1080:            !std::is_same<decltype(end(std::declval<T>())), not_this_one>::value;
        -: 1081:    };
        -: 1082:
        -: 1083:    template<typename Range>
        -: 1084:    std::string rangeToString( Range const& range ) {
        -: 1085:        return ::Catch::Detail::rangeToString( begin( range ), end( range ) );
        -: 1086:    }
        -: 1087:
        -: 1088:    // Handle vector<bool> specially
        -: 1089:    template<typename Allocator>
        -: 1090:    std::string rangeToString( std::vector<bool, Allocator> const& v ) {
        -: 1091:        ReusableStringStream rss;
        -: 1092:        rss << "{ ";
        -: 1093:        bool first = true;
        -: 1094:        for( bool b : v ) {
        -: 1095:            if( first )
        -: 1096:                first = false;
        -: 1097:            else
        -: 1098:                rss << ", ";
        -: 1099:            rss << ::Catch::Detail::stringify( b );
        -: 1100:        }
        -: 1101:        rss << " }";
        -: 1102:        return rss.str();
        -: 1103:    }
        -: 1104:
        -: 1105:    template<typename R>
        -: 1106:    struct StringMaker<R, typename std::enable_if<is_range<R>::value && !::Catch::Detail::IsStreamInsertable<R>::value>::type> {
        -: 1107:        static std::string convert( R const& range ) {
        -: 1108:            return rangeToString( range );
        -: 1109:        }
        -: 1110:    };
        -: 1111:
        -: 1112:    template <typename T, int SZ>
        -: 1113:    struct StringMaker<T[SZ]> {
        -: 1114:        static std::string convert(T const(&arr)[SZ]) {
        -: 1115:            return rangeToString(arr);
        -: 1116:        }
        -: 1117:    };
        -: 1118:
        -: 1119:} // namespace Catch
        -: 1120:
        -: 1121:// Separate std::chrono::duration specialization
        -: 1122:#if defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
        -: 1123:#include <ctime>
        -: 1124:#include <ratio>
        -: 1125:#include <chrono>
        -: 1126:
        -: 1127:namespace Catch {
        -: 1128:
        -: 1129:template <class Ratio>
        -: 1130:struct ratio_string {
        -: 1131:    static std::string symbol();
        -: 1132:};
        -: 1133:
        -: 1134:template <class Ratio>
        -: 1135:std::string ratio_string<Ratio>::symbol() {
        -: 1136:    Catch::ReusableStringStream rss;
        -: 1137:    rss << '[' << Ratio::num << '/'
        -: 1138:        << Ratio::den << ']';
        -: 1139:    return rss.str();
        -: 1140:}
        -: 1141:template <>
        -: 1142:struct ratio_string<std::atto> {
        -: 1143:    static std::string symbol();
        -: 1144:};
        -: 1145:template <>
        -: 1146:struct ratio_string<std::femto> {
        -: 1147:    static std::string symbol();
        -: 1148:};
        -: 1149:template <>
        -: 1150:struct ratio_string<std::pico> {
        -: 1151:    static std::string symbol();
        -: 1152:};
        -: 1153:template <>
        -: 1154:struct ratio_string<std::nano> {
        -: 1155:    static std::string symbol();
        -: 1156:};
        -: 1157:template <>
        -: 1158:struct ratio_string<std::micro> {
        -: 1159:    static std::string symbol();
        -: 1160:};
        -: 1161:template <>
        -: 1162:struct ratio_string<std::milli> {
        -: 1163:    static std::string symbol();
        -: 1164:};
        -: 1165:
        -: 1166:    ////////////
        -: 1167:    // std::chrono::duration specializations
        -: 1168:    template<typename Value, typename Ratio>
        -: 1169:    struct StringMaker<std::chrono::duration<Value, Ratio>> {
        -: 1170:        static std::string convert(std::chrono::duration<Value, Ratio> const& duration) {
        -: 1171:            ReusableStringStream rss;
        -: 1172:            rss << duration.count() << ' ' << ratio_string<Ratio>::symbol() << 's';
        -: 1173:            return rss.str();
        -: 1174:        }
        -: 1175:    };
        -: 1176:    template<typename Value>
        -: 1177:    struct StringMaker<std::chrono::duration<Value, std::ratio<1>>> {
        -: 1178:        static std::string convert(std::chrono::duration<Value, std::ratio<1>> const& duration) {
        -: 1179:            ReusableStringStream rss;
        -: 1180:            rss << duration.count() << " s";
        -: 1181:            return rss.str();
        -: 1182:        }
        -: 1183:    };
        -: 1184:    template<typename Value>
        -: 1185:    struct StringMaker<std::chrono::duration<Value, std::ratio<60>>> {
        -: 1186:        static std::string convert(std::chrono::duration<Value, std::ratio<60>> const& duration) {
        -: 1187:            ReusableStringStream rss;
        -: 1188:            rss << duration.count() << " m";
        -: 1189:            return rss.str();
        -: 1190:        }
        -: 1191:    };
        -: 1192:    template<typename Value>
        -: 1193:    struct StringMaker<std::chrono::duration<Value, std::ratio<3600>>> {
        -: 1194:        static std::string convert(std::chrono::duration<Value, std::ratio<3600>> const& duration) {
        -: 1195:            ReusableStringStream rss;
        -: 1196:            rss << duration.count() << " h";
        -: 1197:            return rss.str();
        -: 1198:        }
        -: 1199:    };
        -: 1200:
        -: 1201:    ////////////
        -: 1202:    // std::chrono::time_point specialization
        -: 1203:    // Generic time_point cannot be specialized, only std::chrono::time_point<system_clock>
        -: 1204:    template<typename Clock, typename Duration>
        -: 1205:    struct StringMaker<std::chrono::time_point<Clock, Duration>> {
        -: 1206:        static std::string convert(std::chrono::time_point<Clock, Duration> const& time_point) {
        -: 1207:            return ::Catch::Detail::stringify(time_point.time_since_epoch()) + " since epoch";
        -: 1208:        }
        -: 1209:    };
        -: 1210:    // std::chrono::time_point<system_clock> specialization
        -: 1211:    template<typename Duration>
        -: 1212:    struct StringMaker<std::chrono::time_point<std::chrono::system_clock, Duration>> {
        -: 1213:        static std::string convert(std::chrono::time_point<std::chrono::system_clock, Duration> const& time_point) {
        -: 1214:            auto converted = std::chrono::system_clock::to_time_t(time_point);
        -: 1215:
        -: 1216:#ifdef _MSC_VER
        -: 1217:            std::tm timeInfo = {};
        -: 1218:            gmtime_s(&timeInfo, &converted);
        -: 1219:#else
        -: 1220:            std::tm* timeInfo = std::gmtime(&converted);
        -: 1221:#endif
        -: 1222:
        -: 1223:            auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");
        -: 1224:            char timeStamp[timeStampSize];
        -: 1225:            const char * const fmt = "%Y-%m-%dT%H:%M:%SZ";
        -: 1226:
        -: 1227:#ifdef _MSC_VER
        -: 1228:            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
        -: 1229:#else
        -: 1230:            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
        -: 1231:#endif
        -: 1232:            return std::string(timeStamp);
        -: 1233:        }
        -: 1234:    };
        -: 1235:}
        -: 1236:#endif // CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
        -: 1237:
        -: 1238:#ifdef _MSC_VER
        -: 1239:#pragma warning(pop)
        -: 1240:#endif
        -: 1241:
        -: 1242:// end catch_tostring.h
        -: 1243:#include <iosfwd>
        -: 1244:
        -: 1245:#ifdef _MSC_VER
        -: 1246:#pragma warning(push)
        -: 1247:#pragma warning(disable:4389) // '==' : signed/unsigned mismatch
        -: 1248:#pragma warning(disable:4018) // more "signed/unsigned mismatch"
        -: 1249:#pragma warning(disable:4312) // Converting int to T* using reinterpret_cast (issue on x64 platform)
        -: 1250:#pragma warning(disable:4180) // qualifier applied to function type has no meaning
        -: 1251:#endif
        -: 1252:
        -: 1253:namespace Catch {
        -: 1254:
        -: 1255:    struct ITransientExpression {
    #####: 1256:        auto isBinaryExpression() const -> bool { return m_isBinaryExpression; }
       41: 1257:        auto getResult() const -> bool { return m_result; }
        -: 1258:        virtual void streamReconstructedExpression( std::ostream &os ) const = 0;
        -: 1259:
       41: 1260:        ITransientExpression( bool isBinaryExpression, bool result )
       41: 1261:        :   m_isBinaryExpression( isBinaryExpression ),
       41: 1262:            m_result( result )
       41: 1263:        {}
        -: 1264:
        -: 1265:        // We don't actually need a virtual destructor, but many static analysers
        -: 1266:        // complain if it's not here :-(
        -: 1267:        virtual ~ITransientExpression();
        -: 1268:
        -: 1269:        bool m_isBinaryExpression;
        -: 1270:        bool m_result;
        -: 1271:
        -: 1272:    };
        -: 1273:
        -: 1274:    void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs );
        -: 1275:
        -: 1276:    template<typename LhsT, typename RhsT>
        -: 1277:    class BinaryExpr  : public ITransientExpression {
        -: 1278:        LhsT m_lhs;
        -: 1279:        StringRef m_op;
        -: 1280:        RhsT m_rhs;
        -: 1281:
    #####: 1282:        void streamReconstructedExpression( std::ostream &os ) const override {
        -: 1283:            formatReconstructedExpression
    #####: 1284:                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );
    #####: 1285:        }
        -: 1286:
        -: 1287:    public:
       41: 1288:        BinaryExpr( bool comparisonResult, LhsT lhs, StringRef op, RhsT rhs )
        -: 1289:        :   ITransientExpression{ true, comparisonResult },
       41: 1290:            m_lhs( lhs ),
       41: 1291:            m_op( op ),
       41: 1292:            m_rhs( rhs )
       41: 1293:        {}
        -: 1294:    };
        -: 1295:
        -: 1296:    template<typename LhsT>
        -: 1297:    class UnaryExpr : public ITransientExpression {
        -: 1298:        LhsT m_lhs;
        -: 1299:
        -: 1300:        void streamReconstructedExpression( std::ostream &os ) const override {
        -: 1301:            os << Catch::Detail::stringify( m_lhs );
        -: 1302:        }
        -: 1303:
        -: 1304:    public:
        -: 1305:        explicit UnaryExpr( LhsT lhs )
        -: 1306:        :   ITransientExpression{ false, lhs ? true : false },
        -: 1307:            m_lhs( lhs )
        -: 1308:        {}
        -: 1309:    };
        -: 1310:
        -: 1311:    // Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)
        -: 1312:    template<typename LhsT, typename RhsT>
       41: 1313:    auto compareEqual( LhsT const& lhs, RhsT const& rhs ) -> bool { return static_cast<bool>(lhs == rhs); }
        -: 1314:    template<typename T>
        -: 1315:    auto compareEqual( T* const& lhs, int rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
        -: 1316:    template<typename T>
        -: 1317:    auto compareEqual( T* const& lhs, long rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
        -: 1318:    template<typename T>
        -: 1319:    auto compareEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }
        -: 1320:    template<typename T>
        -: 1321:    auto compareEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }
        -: 1322:
        -: 1323:    template<typename LhsT, typename RhsT>
        -: 1324:    auto compareNotEqual( LhsT const& lhs, RhsT&& rhs ) -> bool { return static_cast<bool>(lhs != rhs); }
        -: 1325:    template<typename T>
        -: 1326:    auto compareNotEqual( T* const& lhs, int rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
        -: 1327:    template<typename T>
        -: 1328:    auto compareNotEqual( T* const& lhs, long rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
        -: 1329:    template<typename T>
        -: 1330:    auto compareNotEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }
        -: 1331:    template<typename T>
        -: 1332:    auto compareNotEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }
        -: 1333:
        -: 1334:    template<typename LhsT>
        -: 1335:    class ExprLhs {
        -: 1336:        LhsT m_lhs;
        -: 1337:    public:
       41: 1338:        explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}
        -: 1339:
        -: 1340:        template<typename RhsT>
       41: 1341:        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
       41: 1342:            return { compareEqual( m_lhs, rhs ), m_lhs, "==", rhs };
        -: 1343:        }
        -: 1344:        auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
        -: 1345:            return { m_lhs == rhs, m_lhs, "==", rhs };
        -: 1346:        }
        -: 1347:
        -: 1348:        template<typename RhsT>
        -: 1349:        auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 1350:            return { compareNotEqual( m_lhs, rhs ), m_lhs, "!=", rhs };
        -: 1351:        }
        -: 1352:        auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
        -: 1353:            return { m_lhs != rhs, m_lhs, "!=", rhs };
        -: 1354:        }
        -: 1355:
        -: 1356:        template<typename RhsT>
        -: 1357:        auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 1358:            return { static_cast<bool>(m_lhs > rhs), m_lhs, ">", rhs };
        -: 1359:        }
        -: 1360:        template<typename RhsT>
        -: 1361:        auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 1362:            return { static_cast<bool>(m_lhs < rhs), m_lhs, "<", rhs };
        -: 1363:        }
        -: 1364:        template<typename RhsT>
        -: 1365:        auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 1366:            return { static_cast<bool>(m_lhs >= rhs), m_lhs, ">=", rhs };
        -: 1367:        }
        -: 1368:        template<typename RhsT>
        -: 1369:        auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
        -: 1370:            return { static_cast<bool>(m_lhs <= rhs), m_lhs, "<=", rhs };
        -: 1371:        }
        -: 1372:
        -: 1373:        auto makeUnaryExpr() const -> UnaryExpr<LhsT> {
        -: 1374:            return UnaryExpr<LhsT>{ m_lhs };
        -: 1375:        }
        -: 1376:    };
        -: 1377:
        -: 1378:    void handleExpression( ITransientExpression const& expr );
        -: 1379:
        -: 1380:    template<typename T>
        -: 1381:    void handleExpression( ExprLhs<T> const& expr ) {
        -: 1382:        handleExpression( expr.makeUnaryExpr() );
        -: 1383:    }
        -: 1384:
        -: 1385:    struct Decomposer {
        -: 1386:        template<typename T>
       41: 1387:        auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {
       41: 1388:            return ExprLhs<T const&>{ lhs };
        -: 1389:        }
        -: 1390:
        -: 1391:        auto operator <=( bool value ) -> ExprLhs<bool> {
        -: 1392:            return ExprLhs<bool>{ value };
        -: 1393:        }
        -: 1394:    };
        -: 1395:
        -: 1396:} // end namespace Catch
        -: 1397:
        -: 1398:#ifdef _MSC_VER
        -: 1399:#pragma warning(pop)
        -: 1400:#endif
        -: 1401:
        -: 1402:// end catch_decomposer.h
        -: 1403:// start catch_interfaces_capture.h
        -: 1404:
        -: 1405:#include <string>
        -: 1406:
        -: 1407:namespace Catch {
        -: 1408:
        -: 1409:    class AssertionResult;
        -: 1410:    struct AssertionInfo;
        -: 1411:    struct SectionInfo;
        -: 1412:    struct SectionEndInfo;
        -: 1413:    struct MessageInfo;
        -: 1414:    struct Counts;
        -: 1415:    struct BenchmarkInfo;
        -: 1416:    struct BenchmarkStats;
        -: 1417:    struct AssertionReaction;
        -: 1418:
        -: 1419:    struct ITransientExpression;
        -: 1420:
        -: 1421:    struct IResultCapture {
        -: 1422:
        -: 1423:        virtual ~IResultCapture();
        -: 1424:
        -: 1425:        virtual bool sectionStarted(    SectionInfo const& sectionInfo,
        -: 1426:                                        Counts& assertions ) = 0;
        -: 1427:        virtual void sectionEnded( SectionEndInfo const& endInfo ) = 0;
        -: 1428:        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) = 0;
        -: 1429:
        -: 1430:        virtual void benchmarkStarting( BenchmarkInfo const& info ) = 0;
        -: 1431:        virtual void benchmarkEnded( BenchmarkStats const& stats ) = 0;
        -: 1432:
        -: 1433:        virtual void pushScopedMessage( MessageInfo const& message ) = 0;
        -: 1434:        virtual void popScopedMessage( MessageInfo const& message ) = 0;
        -: 1435:
        -: 1436:        virtual void handleFatalErrorCondition( StringRef message ) = 0;
        -: 1437:
        -: 1438:        virtual void handleExpr
        -: 1439:                (   AssertionInfo const& info,
        -: 1440:                    ITransientExpression const& expr,
        -: 1441:                    AssertionReaction& reaction ) = 0;
        -: 1442:        virtual void handleMessage
        -: 1443:                (   AssertionInfo const& info,
        -: 1444:                    ResultWas::OfType resultType,
        -: 1445:                    StringRef const& message,
        -: 1446:                    AssertionReaction& reaction ) = 0;
        -: 1447:        virtual void handleUnexpectedExceptionNotThrown
        -: 1448:                (   AssertionInfo const& info,
        -: 1449:                    AssertionReaction& reaction ) = 0;
        -: 1450:        virtual void handleUnexpectedInflightException
        -: 1451:                (   AssertionInfo const& info,
        -: 1452:                    std::string const& message,
        -: 1453:                    AssertionReaction& reaction ) = 0;
        -: 1454:        virtual void handleIncomplete
        -: 1455:                (   AssertionInfo const& info ) = 0;
        -: 1456:        virtual void handleNonExpr
        -: 1457:                (   AssertionInfo const &info,
        -: 1458:                    ResultWas::OfType resultType,
        -: 1459:                    AssertionReaction &reaction ) = 0;
        -: 1460:
        -: 1461:        virtual bool lastAssertionPassed() = 0;
        -: 1462:        virtual void assertionPassed() = 0;
        -: 1463:
        -: 1464:        // Deprecated, do not use:
        -: 1465:        virtual std::string getCurrentTestName() const = 0;
        -: 1466:        virtual const AssertionResult* getLastResult() const = 0;
        -: 1467:        virtual void exceptionEarlyReported() = 0;
        -: 1468:    };
        -: 1469:
        -: 1470:    IResultCapture& getResultCapture();
        -: 1471:}
        -: 1472:
        -: 1473:// end catch_interfaces_capture.h
        -: 1474:namespace Catch {
        -: 1475:
        -: 1476:    struct TestFailureException{};
        -: 1477:    struct AssertionResultData;
        -: 1478:    struct IResultCapture;
        -: 1479:    class RunContext;
        -: 1480:
        -: 1481:    class LazyExpression {
        -: 1482:        friend class AssertionHandler;
        -: 1483:        friend struct AssertionStats;
        -: 1484:        friend class RunContext;
        -: 1485:
        -: 1486:        ITransientExpression const* m_transientExpression = nullptr;
        -: 1487:        bool m_isNegated;
        -: 1488:    public:
        -: 1489:        LazyExpression( bool isNegated );
        -: 1490:        LazyExpression( LazyExpression const& other );
        -: 1491:        LazyExpression& operator = ( LazyExpression const& ) = delete;
        -: 1492:
        -: 1493:        explicit operator bool() const;
        -: 1494:
        -: 1495:        friend auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream&;
        -: 1496:    };
        -: 1497:
        -: 1498:    struct AssertionReaction {
        -: 1499:        bool shouldDebugBreak = false;
        -: 1500:        bool shouldThrow = false;
        -: 1501:    };
        -: 1502:
        -: 1503:    class AssertionHandler {
        -: 1504:        AssertionInfo m_assertionInfo;
        -: 1505:        AssertionReaction m_reaction;
        -: 1506:        bool m_completed = false;
        -: 1507:        IResultCapture& m_resultCapture;
        -: 1508:
        -: 1509:    public:
        -: 1510:        AssertionHandler
        -: 1511:            (   StringRef macroName,
        -: 1512:                SourceLineInfo const& lineInfo,
        -: 1513:                StringRef capturedExpression,
        -: 1514:                ResultDisposition::Flags resultDisposition );
       41: 1515:        ~AssertionHandler() {
       41: 1516:            if ( !m_completed ) {
    #####: 1517:                m_resultCapture.handleIncomplete( m_assertionInfo );
        -: 1518:            }
       41: 1519:        }
        -: 1520:
        -: 1521:        template<typename T>
        -: 1522:        void handleExpr( ExprLhs<T> const& expr ) {
        -: 1523:            handleExpr( expr.makeUnaryExpr() );
        -: 1524:        }
        -: 1525:        void handleExpr( ITransientExpression const& expr );
        -: 1526:
        -: 1527:        void handleMessage(ResultWas::OfType resultType, StringRef const& message);
        -: 1528:
        -: 1529:        void handleExceptionThrownAsExpected();
        -: 1530:        void handleUnexpectedExceptionNotThrown();
        -: 1531:        void handleExceptionNotThrownAsExpected();
        -: 1532:        void handleThrowingCallSkipped();
        -: 1533:        void handleUnexpectedInflightException();
        -: 1534:
        -: 1535:        void complete();
        -: 1536:        void setCompleted();
        -: 1537:
        -: 1538:        // query
        -: 1539:        auto allowThrows() const -> bool;
        -: 1540:    };
        -: 1541:
        -: 1542:    void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef matcherString );
        -: 1543:
        -: 1544:} // namespace Catch
        -: 1545:
        -: 1546:// end catch_assertionhandler.h
        -: 1547:// start catch_message.h
        -: 1548:
        -: 1549:#include <string>
        -: 1550:
        -: 1551:namespace Catch {
        -: 1552:
        -: 1553:    struct MessageInfo {
        -: 1554:        MessageInfo(    std::string const& _macroName,
        -: 1555:                        SourceLineInfo const& _lineInfo,
        -: 1556:                        ResultWas::OfType _type );
        -: 1557:
        -: 1558:        std::string macroName;
        -: 1559:        std::string message;
        -: 1560:        SourceLineInfo lineInfo;
        -: 1561:        ResultWas::OfType type;
        -: 1562:        unsigned int sequence;
        -: 1563:
        -: 1564:        bool operator == ( MessageInfo const& other ) const;
        -: 1565:        bool operator < ( MessageInfo const& other ) const;
        -: 1566:    private:
        -: 1567:        static unsigned int globalCount;
        -: 1568:    };
        -: 1569:
        -: 1570:    struct MessageStream {
        -: 1571:
        -: 1572:        template<typename T>
        -: 1573:        MessageStream& operator << ( T const& value ) {
        -: 1574:            m_stream << value;
        -: 1575:            return *this;
        -: 1576:        }
        -: 1577:
        -: 1578:        ReusableStringStream m_stream;
        -: 1579:    };
        -: 1580:
        -: 1581:    struct MessageBuilder : MessageStream {
        -: 1582:        MessageBuilder( std::string const& macroName,
        -: 1583:                        SourceLineInfo const& lineInfo,
        -: 1584:                        ResultWas::OfType type );
        -: 1585:
        -: 1586:        template<typename T>
    #####: 1587:        MessageBuilder& operator << ( T const& value ) {
    #####: 1588:            m_stream << value;
    #####: 1589:            return *this;
        -: 1590:        }
        -: 1591:
        -: 1592:        MessageInfo m_info;
        -: 1593:    };
        -: 1594:
        -: 1595:    class ScopedMessage {
        -: 1596:    public:
        -: 1597:        explicit ScopedMessage( MessageBuilder const& builder );
        -: 1598:        ~ScopedMessage();
        -: 1599:
        -: 1600:        MessageInfo m_info;
        -: 1601:    };
        -: 1602:
        -: 1603:} // end namespace Catch
        -: 1604:
        -: 1605:// end catch_message.h
        -: 1606:#if !defined(CATCH_CONFIG_DISABLE)
        -: 1607:
        -: 1608:#if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)
        -: 1609:  #define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__
        -: 1610:#else
        -: 1611:  #define CATCH_INTERNAL_STRINGIFY(...) "Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION"
        -: 1612:#endif
        -: 1613:
        -: 1614:#if defined(CATCH_CONFIG_FAST_COMPILE)
        -: 1615:
        -: 1616:///////////////////////////////////////////////////////////////////////////////
        -: 1617:// Another way to speed-up compilation is to omit local try-catch for REQUIRE*
        -: 1618:// macros.
        -: 1619:#define INTERNAL_CATCH_TRY
        -: 1620:#define INTERNAL_CATCH_CATCH( capturer )
        -: 1621:
        -: 1622:#else // CATCH_CONFIG_FAST_COMPILE
        -: 1623:
        -: 1624:#define INTERNAL_CATCH_TRY try
        -: 1625:#define INTERNAL_CATCH_CATCH( handler ) catch(...) { handler.handleUnexpectedInflightException(); }
        -: 1626:
        -: 1627:#endif
        -: 1628:
        -: 1629:#define INTERNAL_CATCH_REACT( handler ) handler.complete();
        -: 1630:
        -: 1631:///////////////////////////////////////////////////////////////////////////////
        -: 1632:#define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \
        -: 1633:    do { \
        -: 1634:        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
        -: 1635:        INTERNAL_CATCH_TRY { \
        -: 1636:            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
        -: 1637:            catchAssertionHandler.handleExpr( Catch::Decomposer() <= __VA_ARGS__ ); \
        -: 1638:            CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \
        -: 1639:        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
        -: 1640:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 1641:    } while( (void)0, false && static_cast<bool>( !!(__VA_ARGS__) ) ) // the expression here is never evaluated at runtime but it forces the compiler to give it a look
        -: 1642:    // The double negation silences MSVC's C4800 warning, the static_cast forces short-circuit evaluation if the type has overloaded &&.
        -: 1643:
        -: 1644:///////////////////////////////////////////////////////////////////////////////
        -: 1645:#define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \
        -: 1646:    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
        -: 1647:    if( Catch::getResultCapture().lastAssertionPassed() )
        -: 1648:
        -: 1649:///////////////////////////////////////////////////////////////////////////////
        -: 1650:#define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \
        -: 1651:    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
        -: 1652:    if( !Catch::getResultCapture().lastAssertionPassed() )
        -: 1653:
        -: 1654:///////////////////////////////////////////////////////////////////////////////
        -: 1655:#define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \
        -: 1656:    do { \
        -: 1657:        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
        -: 1658:        try { \
        -: 1659:            static_cast<void>(__VA_ARGS__); \
        -: 1660:            catchAssertionHandler.handleExceptionNotThrownAsExpected(); \
        -: 1661:        } \
        -: 1662:        catch( ... ) { \
        -: 1663:            catchAssertionHandler.handleUnexpectedInflightException(); \
        -: 1664:        } \
        -: 1665:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 1666:    } while( false )
        -: 1667:
        -: 1668:///////////////////////////////////////////////////////////////////////////////
        -: 1669:#define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \
        -: 1670:    do { \
        -: 1671:        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \
        -: 1672:        if( catchAssertionHandler.allowThrows() ) \
        -: 1673:            try { \
        -: 1674:                static_cast<void>(__VA_ARGS__); \
        -: 1675:                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
        -: 1676:            } \
        -: 1677:            catch( ... ) { \
        -: 1678:                catchAssertionHandler.handleExceptionThrownAsExpected(); \
        -: 1679:            } \
        -: 1680:        else \
        -: 1681:            catchAssertionHandler.handleThrowingCallSkipped(); \
        -: 1682:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 1683:    } while( false )
        -: 1684:
        -: 1685:///////////////////////////////////////////////////////////////////////////////
        -: 1686:#define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \
        -: 1687:    do { \
        -: 1688:        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) ", " CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \
        -: 1689:        if( catchAssertionHandler.allowThrows() ) \
        -: 1690:            try { \
        -: 1691:                static_cast<void>(expr); \
        -: 1692:                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
        -: 1693:            } \
        -: 1694:            catch( exceptionType const& ) { \
        -: 1695:                catchAssertionHandler.handleExceptionThrownAsExpected(); \
        -: 1696:            } \
        -: 1697:            catch( ... ) { \
        -: 1698:                catchAssertionHandler.handleUnexpectedInflightException(); \
        -: 1699:            } \
        -: 1700:        else \
        -: 1701:            catchAssertionHandler.handleThrowingCallSkipped(); \
        -: 1702:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 1703:    } while( false )
        -: 1704:
        -: 1705:///////////////////////////////////////////////////////////////////////////////
        -: 1706:#define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \
        -: 1707:    do { \
        -: 1708:        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, "", resultDisposition ); \
        -: 1709:        catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \
        -: 1710:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 1711:    } while( false )
        -: 1712:
        -: 1713:///////////////////////////////////////////////////////////////////////////////
        -: 1714:#define INTERNAL_CATCH_INFO( macroName, log ) \
        -: 1715:    Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log );
        -: 1716:
        -: 1717:///////////////////////////////////////////////////////////////////////////////
        -: 1718:// Although this is matcher-based, it can be used with just a string
        -: 1719:#define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \
        -: 1720:    do { \
        -: 1721:        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        -: 1722:        if( catchAssertionHandler.allowThrows() ) \
        -: 1723:            try { \
        -: 1724:                static_cast<void>(__VA_ARGS__); \
        -: 1725:                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
        -: 1726:            } \
        -: 1727:            catch( ... ) { \
        -: 1728:                Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, #matcher ); \
        -: 1729:            } \
        -: 1730:        else \
        -: 1731:            catchAssertionHandler.handleThrowingCallSkipped(); \
        -: 1732:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 1733:    } while( false )
        -: 1734:
        -: 1735:#endif // CATCH_CONFIG_DISABLE
        -: 1736:
        -: 1737:// end catch_capture.hpp
        -: 1738:// start catch_section.h
        -: 1739:
        -: 1740:// start catch_section_info.h
        -: 1741:
        -: 1742:// start catch_totals.h
        -: 1743:
        -: 1744:#include <cstddef>
        -: 1745:
        -: 1746:namespace Catch {
        -: 1747:
        -: 1748:    struct Counts {
        -: 1749:        Counts operator - ( Counts const& other ) const;
        -: 1750:        Counts& operator += ( Counts const& other );
        -: 1751:
        -: 1752:        std::size_t total() const;
        -: 1753:        bool allPassed() const;
        -: 1754:        bool allOk() const;
        -: 1755:
        -: 1756:        std::size_t passed = 0;
        -: 1757:        std::size_t failed = 0;
        -: 1758:        std::size_t failedButOk = 0;
        -: 1759:    };
        -: 1760:
        -: 1761:    struct Totals {
        -: 1762:
        -: 1763:        Totals operator - ( Totals const& other ) const;
        -: 1764:        Totals& operator += ( Totals const& other );
        -: 1765:
        -: 1766:        Totals delta( Totals const& prevTotals ) const;
        -: 1767:
        -: 1768:        int error = 0;
        -: 1769:        Counts assertions;
        -: 1770:        Counts testCases;
        -: 1771:    };
        -: 1772:}
        -: 1773:
        -: 1774:// end catch_totals.h
        -: 1775:#include <string>
        -: 1776:
        -: 1777:namespace Catch {
        -: 1778:
        -: 1779:    struct SectionInfo {
        -: 1780:        SectionInfo
        -: 1781:            (   SourceLineInfo const& _lineInfo,
        -: 1782:                std::string const& _name,
        -: 1783:                std::string const& _description = std::string() );
        -: 1784:
        -: 1785:        std::string name;
        -: 1786:        std::string description;
        -: 1787:        SourceLineInfo lineInfo;
        -: 1788:    };
        -: 1789:
        -: 1790:    struct SectionEndInfo {
        -: 1791:        SectionEndInfo( SectionInfo const& _sectionInfo, Counts const& _prevAssertions, double _durationInSeconds );
        -: 1792:
        -: 1793:        SectionInfo sectionInfo;
        -: 1794:        Counts prevAssertions;
        -: 1795:        double durationInSeconds;
        -: 1796:    };
        -: 1797:
        -: 1798:} // end namespace Catch
        -: 1799:
        -: 1800:// end catch_section_info.h
        -: 1801:// start catch_timer.h
        -: 1802:
        -: 1803:#include <cstdint>
        -: 1804:
        -: 1805:namespace Catch {
        -: 1806:
        -: 1807:    auto getCurrentNanosecondsSinceEpoch() -> uint64_t;
        -: 1808:    auto getEstimatedClockResolution() -> uint64_t;
        -: 1809:
        -: 1810:    class Timer {
        -: 1811:        uint64_t m_nanoseconds = 0;
        -: 1812:    public:
        -: 1813:        void start();
        -: 1814:        auto getElapsedNanoseconds() const -> uint64_t;
        -: 1815:        auto getElapsedMicroseconds() const -> uint64_t;
        -: 1816:        auto getElapsedMilliseconds() const -> unsigned int;
        -: 1817:        auto getElapsedSeconds() const -> double;
        -: 1818:    };
        -: 1819:
        -: 1820:} // namespace Catch
        -: 1821:
        -: 1822:// end catch_timer.h
        -: 1823:#include <string>
        -: 1824:
        -: 1825:namespace Catch {
        -: 1826:
        -: 1827:    class Section : NonCopyable {
        -: 1828:    public:
        -: 1829:        Section( SectionInfo const& info );
        -: 1830:        ~Section();
        -: 1831:
        -: 1832:        // This indicates whether the section should be executed or not
        -: 1833:        explicit operator bool() const;
        -: 1834:
        -: 1835:    private:
        -: 1836:        SectionInfo m_info;
        -: 1837:
        -: 1838:        std::string m_name;
        -: 1839:        Counts m_assertions;
        -: 1840:        bool m_sectionIncluded;
        -: 1841:        Timer m_timer;
        -: 1842:    };
        -: 1843:
        -: 1844:} // end namespace Catch
        -: 1845:
        -: 1846:    #define INTERNAL_CATCH_SECTION( ... ) \
        -: 1847:        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) )
        -: 1848:
        -: 1849:// end catch_section.h
        -: 1850:// start catch_benchmark.h
        -: 1851:
        -: 1852:#include <cstdint>
        -: 1853:#include <string>
        -: 1854:
        -: 1855:namespace Catch {
        -: 1856:
        -: 1857:    class BenchmarkLooper {
        -: 1858:
        -: 1859:        std::string m_name;
        -: 1860:        std::size_t m_count = 0;
        -: 1861:        std::size_t m_iterationsToRun = 1;
        -: 1862:        uint64_t m_resolution;
        -: 1863:        Timer m_timer;
        -: 1864:
        -: 1865:        static auto getResolution() -> uint64_t;
        -: 1866:    public:
        -: 1867:        // Keep most of this inline as it's on the code path that is being timed
        -: 1868:        BenchmarkLooper( StringRef name )
        -: 1869:        :   m_name( name ),
        -: 1870:            m_resolution( getResolution() )
        -: 1871:        {
        -: 1872:            reportStart();
        -: 1873:            m_timer.start();
        -: 1874:        }
        -: 1875:
        -: 1876:        explicit operator bool() {
        -: 1877:            if( m_count < m_iterationsToRun )
        -: 1878:                return true;
        -: 1879:            return needsMoreIterations();
        -: 1880:        }
        -: 1881:
        -: 1882:        void increment() {
        -: 1883:            ++m_count;
        -: 1884:        }
        -: 1885:
        -: 1886:        void reportStart();
        -: 1887:        auto needsMoreIterations() -> bool;
        -: 1888:    };
        -: 1889:
        -: 1890:} // end namespace Catch
        -: 1891:
        -: 1892:#define BENCHMARK( name ) \
        -: 1893:    for( Catch::BenchmarkLooper looper( name ); looper; looper.increment() )
        -: 1894:
        -: 1895:// end catch_benchmark.h
        -: 1896:// start catch_interfaces_exception.h
        -: 1897:
        -: 1898:// start catch_interfaces_registry_hub.h
        -: 1899:
        -: 1900:#include <string>
        -: 1901:#include <memory>
        -: 1902:
        -: 1903:namespace Catch {
        -: 1904:
        -: 1905:    class TestCase;
        -: 1906:    struct ITestCaseRegistry;
        -: 1907:    struct IExceptionTranslatorRegistry;
        -: 1908:    struct IExceptionTranslator;
        -: 1909:    struct IReporterRegistry;
        -: 1910:    struct IReporterFactory;
        -: 1911:    struct ITagAliasRegistry;
        -: 1912:    class StartupExceptionRegistry;
        -: 1913:
        -: 1914:    using IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;
        -: 1915:
        -: 1916:    struct IRegistryHub {
        -: 1917:        virtual ~IRegistryHub();
        -: 1918:
        -: 1919:        virtual IReporterRegistry const& getReporterRegistry() const = 0;
        -: 1920:        virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
        -: 1921:        virtual ITagAliasRegistry const& getTagAliasRegistry() const = 0;
        -: 1922:
        -: 1923:        virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() = 0;
        -: 1924:
        -: 1925:        virtual StartupExceptionRegistry const& getStartupExceptionRegistry() const = 0;
        -: 1926:    };
        -: 1927:
        -: 1928:    struct IMutableRegistryHub {
        -: 1929:        virtual ~IMutableRegistryHub();
        -: 1930:        virtual void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) = 0;
        -: 1931:        virtual void registerListener( IReporterFactoryPtr const& factory ) = 0;
        -: 1932:        virtual void registerTest( TestCase const& testInfo ) = 0;
        -: 1933:        virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;
        -: 1934:        virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) = 0;
        -: 1935:        virtual void registerStartupException() noexcept = 0;
        -: 1936:    };
        -: 1937:
        -: 1938:    IRegistryHub& getRegistryHub();
        -: 1939:    IMutableRegistryHub& getMutableRegistryHub();
        -: 1940:    void cleanUp();
        -: 1941:    std::string translateActiveException();
        -: 1942:
        -: 1943:}
        -: 1944:
        -: 1945:// end catch_interfaces_registry_hub.h
        -: 1946:#if defined(CATCH_CONFIG_DISABLE)
        -: 1947:    #define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \
        -: 1948:        static std::string translatorName( signature )
        -: 1949:#endif
        -: 1950:
        -: 1951:#include <exception>
        -: 1952:#include <string>
        -: 1953:#include <vector>
        -: 1954:
        -: 1955:namespace Catch {
        -: 1956:    using exceptionTranslateFunction = std::string(*)();
        -: 1957:
        -: 1958:    struct IExceptionTranslator;
        -: 1959:    using ExceptionTranslators = std::vector<std::unique_ptr<IExceptionTranslator const>>;
        -: 1960:
        -: 1961:    struct IExceptionTranslator {
        -: 1962:        virtual ~IExceptionTranslator();
        -: 1963:        virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;
        -: 1964:    };
        -: 1965:
        -: 1966:    struct IExceptionTranslatorRegistry {
        -: 1967:        virtual ~IExceptionTranslatorRegistry();
        -: 1968:
        -: 1969:        virtual std::string translateActiveException() const = 0;
        -: 1970:    };
        -: 1971:
        -: 1972:    class ExceptionTranslatorRegistrar {
        -: 1973:        template<typename T>
        -: 1974:        class ExceptionTranslator : public IExceptionTranslator {
        -: 1975:        public:
        -: 1976:
        -: 1977:            ExceptionTranslator( std::string(*translateFunction)( T& ) )
        -: 1978:            : m_translateFunction( translateFunction )
        -: 1979:            {}
        -: 1980:
        -: 1981:            std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {
        -: 1982:                try {
        -: 1983:                    if( it == itEnd )
        -: 1984:                        std::rethrow_exception(std::current_exception());
        -: 1985:                    else
        -: 1986:                        return (*it)->translate( it+1, itEnd );
        -: 1987:                }
        -: 1988:                catch( T& ex ) {
        -: 1989:                    return m_translateFunction( ex );
        -: 1990:                }
        -: 1991:            }
        -: 1992:
        -: 1993:        protected:
        -: 1994:            std::string(*m_translateFunction)( T& );
        -: 1995:        };
        -: 1996:
        -: 1997:    public:
        -: 1998:        template<typename T>
        -: 1999:        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {
        -: 2000:            getMutableRegistryHub().registerTranslator
        -: 2001:                ( new ExceptionTranslator<T>( translateFunction ) );
        -: 2002:        }
        -: 2003:    };
        -: 2004:}
        -: 2005:
        -: 2006:///////////////////////////////////////////////////////////////////////////////
        -: 2007:#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \
        -: 2008:    static std::string translatorName( signature ); \
        -: 2009:    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 2010:    namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); } \
        -: 2011:    CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \
        -: 2012:    static std::string translatorName( signature )
        -: 2013:
        -: 2014:#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
        -: 2015:
        -: 2016:// end catch_interfaces_exception.h
        -: 2017:// start catch_approx.h
        -: 2018:
        -: 2019:#include <type_traits>
        -: 2020:#include <stdexcept>
        -: 2021:
        -: 2022:namespace Catch {
        -: 2023:namespace Detail {
        -: 2024:
        -: 2025:    class Approx {
        -: 2026:    private:
        -: 2027:        bool equalityComparisonImpl(double other) const;
        -: 2028:
        -: 2029:    public:
        -: 2030:        explicit Approx ( double value );
        -: 2031:
        -: 2032:        static Approx custom();
        -: 2033:
        -: 2034:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2035:        Approx operator()( T const& value ) {
        -: 2036:            Approx approx( static_cast<double>(value) );
        -: 2037:            approx.epsilon( m_epsilon );
        -: 2038:            approx.margin( m_margin );
        -: 2039:            approx.scale( m_scale );
        -: 2040:            return approx;
        -: 2041:        }
        -: 2042:
        -: 2043:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
    #####: 2044:        explicit Approx( T const& value ): Approx(static_cast<double>(value))
    #####: 2045:        {}
        -: 2046:
        -: 2047:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2048:        friend bool operator == ( const T& lhs, Approx const& rhs ) {
        -: 2049:            auto lhs_v = static_cast<double>(lhs);
        -: 2050:            return rhs.equalityComparisonImpl(lhs_v);
        -: 2051:        }
        -: 2052:
        -: 2053:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2054:        friend bool operator == ( Approx const& lhs, const T& rhs ) {
        -: 2055:            return operator==( rhs, lhs );
        -: 2056:        }
        -: 2057:
        -: 2058:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2059:        friend bool operator != ( T const& lhs, Approx const& rhs ) {
        -: 2060:            return !operator==( lhs, rhs );
        -: 2061:        }
        -: 2062:
        -: 2063:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2064:        friend bool operator != ( Approx const& lhs, T const& rhs ) {
        -: 2065:            return !operator==( rhs, lhs );
        -: 2066:        }
        -: 2067:
        -: 2068:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2069:        friend bool operator <= ( T const& lhs, Approx const& rhs ) {
        -: 2070:            return static_cast<double>(lhs) < rhs.m_value || lhs == rhs;
        -: 2071:        }
        -: 2072:
        -: 2073:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2074:        friend bool operator <= ( Approx const& lhs, T const& rhs ) {
        -: 2075:            return lhs.m_value < static_cast<double>(rhs) || lhs == rhs;
        -: 2076:        }
        -: 2077:
        -: 2078:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2079:        friend bool operator >= ( T const& lhs, Approx const& rhs ) {
        -: 2080:            return static_cast<double>(lhs) > rhs.m_value || lhs == rhs;
        -: 2081:        }
        -: 2082:
        -: 2083:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2084:        friend bool operator >= ( Approx const& lhs, T const& rhs ) {
        -: 2085:            return lhs.m_value > static_cast<double>(rhs) || lhs == rhs;
        -: 2086:        }
        -: 2087:
        -: 2088:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2089:        Approx& epsilon( T const& newEpsilon ) {
        -: 2090:            double epsilonAsDouble = static_cast<double>(newEpsilon);
        -: 2091:            if( epsilonAsDouble < 0 || epsilonAsDouble > 1.0 ) {
        -: 2092:                throw std::domain_error
        -: 2093:                    (   "Invalid Approx::epsilon: " +
        -: 2094:                        Catch::Detail::stringify( epsilonAsDouble ) +
        -: 2095:                        ", Approx::epsilon has to be between 0 and 1" );
        -: 2096:            }
        -: 2097:            m_epsilon = epsilonAsDouble;
        -: 2098:            return *this;
        -: 2099:        }
        -: 2100:
        -: 2101:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2102:        Approx& margin( T const& newMargin ) {
        -: 2103:            double marginAsDouble = static_cast<double>(newMargin);
        -: 2104:            if( marginAsDouble < 0 ) {
        -: 2105:                throw std::domain_error
        -: 2106:                    (   "Invalid Approx::margin: " +
        -: 2107:                         Catch::Detail::stringify( marginAsDouble ) +
        -: 2108:                         ", Approx::Margin has to be non-negative." );
        -: 2109:
        -: 2110:            }
        -: 2111:            m_margin = marginAsDouble;
        -: 2112:            return *this;
        -: 2113:        }
        -: 2114:
        -: 2115:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2116:        Approx& scale( T const& newScale ) {
        -: 2117:            m_scale = static_cast<double>(newScale);
        -: 2118:            return *this;
        -: 2119:        }
        -: 2120:
        -: 2121:        std::string toString() const;
        -: 2122:
        -: 2123:    private:
        -: 2124:        double m_epsilon;
        -: 2125:        double m_margin;
        -: 2126:        double m_scale;
        -: 2127:        double m_value;
        -: 2128:    };
        -: 2129:}
        -: 2130:
        -: 2131:template<>
        -: 2132:struct StringMaker<Catch::Detail::Approx> {
        -: 2133:    static std::string convert(Catch::Detail::Approx const& value);
        -: 2134:};
        -: 2135:
        -: 2136:} // end namespace Catch
        -: 2137:
        -: 2138:// end catch_approx.h
        -: 2139:// start catch_string_manip.h
        -: 2140:
        -: 2141:#include <string>
        -: 2142:#include <iosfwd>
        -: 2143:
        -: 2144:namespace Catch {
        -: 2145:
        -: 2146:    bool startsWith( std::string const& s, std::string const& prefix );
        -: 2147:    bool startsWith( std::string const& s, char prefix );
        -: 2148:    bool endsWith( std::string const& s, std::string const& suffix );
        -: 2149:    bool endsWith( std::string const& s, char suffix );
        -: 2150:    bool contains( std::string const& s, std::string const& infix );
        -: 2151:    void toLowerInPlace( std::string& s );
        -: 2152:    std::string toLower( std::string const& s );
        -: 2153:    std::string trim( std::string const& str );
        -: 2154:    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );
        -: 2155:
        -: 2156:    struct pluralise {
        -: 2157:        pluralise( std::size_t count, std::string const& label );
        -: 2158:
        -: 2159:        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );
        -: 2160:
        -: 2161:        std::size_t m_count;
        -: 2162:        std::string m_label;
        -: 2163:    };
        -: 2164:}
        -: 2165:
        -: 2166:// end catch_string_manip.h
        -: 2167:#ifndef CATCH_CONFIG_DISABLE_MATCHERS
        -: 2168:// start catch_capture_matchers.h
        -: 2169:
        -: 2170:// start catch_matchers.h
        -: 2171:
        -: 2172:#include <string>
        -: 2173:#include <vector>
        -: 2174:
        -: 2175:namespace Catch {
        -: 2176:namespace Matchers {
        -: 2177:    namespace Impl {
        -: 2178:
        -: 2179:        template<typename ArgT> struct MatchAllOf;
        -: 2180:        template<typename ArgT> struct MatchAnyOf;
        -: 2181:        template<typename ArgT> struct MatchNotOf;
        -: 2182:
        -: 2183:        class MatcherUntypedBase {
        -: 2184:        public:
    #####: 2185:            MatcherUntypedBase() = default;
        -: 2186:            MatcherUntypedBase ( MatcherUntypedBase const& ) = default;
        -: 2187:            MatcherUntypedBase& operator = ( MatcherUntypedBase const& ) = delete;
        -: 2188:            std::string toString() const;
        -: 2189:
        -: 2190:        protected:
        -: 2191:            virtual ~MatcherUntypedBase();
        -: 2192:            virtual std::string describe() const = 0;
        -: 2193:            mutable std::string m_cachedToString;
        -: 2194:        };
        -: 2195:
        -: 2196:        template<typename ObjectT>
        -: 2197:        struct MatcherMethod {
        -: 2198:            virtual bool match( ObjectT const& arg ) const = 0;
        -: 2199:        };
        -: 2200:        template<typename PtrT>
        -: 2201:        struct MatcherMethod<PtrT*> {
        -: 2202:            virtual bool match( PtrT* arg ) const = 0;
        -: 2203:        };
        -: 2204:
        -: 2205:        template<typename T>
        -: 2206:        struct MatcherBase : MatcherUntypedBase, MatcherMethod<T> {
        -: 2207:
        -: 2208:            MatchAllOf<T> operator && ( MatcherBase const& other ) const;
        -: 2209:            MatchAnyOf<T> operator || ( MatcherBase const& other ) const;
        -: 2210:            MatchNotOf<T> operator ! () const;
        -: 2211:        };
        -: 2212:
        -: 2213:        template<typename ArgT>
        -: 2214:        struct MatchAllOf : MatcherBase<ArgT> {
        -: 2215:            bool match( ArgT const& arg ) const override {
        -: 2216:                for( auto matcher : m_matchers ) {
        -: 2217:                    if (!matcher->match(arg))
        -: 2218:                        return false;
        -: 2219:                }
        -: 2220:                return true;
        -: 2221:            }
        -: 2222:            std::string describe() const override {
        -: 2223:                std::string description;
        -: 2224:                description.reserve( 4 + m_matchers.size()*32 );
        -: 2225:                description += "( ";
        -: 2226:                bool first = true;
        -: 2227:                for( auto matcher : m_matchers ) {
        -: 2228:                    if( first )
        -: 2229:                        first = false;
        -: 2230:                    else
        -: 2231:                        description += " and ";
        -: 2232:                    description += matcher->toString();
        -: 2233:                }
        -: 2234:                description += " )";
        -: 2235:                return description;
        -: 2236:            }
        -: 2237:
        -: 2238:            MatchAllOf<ArgT>& operator && ( MatcherBase<ArgT> const& other ) {
        -: 2239:                m_matchers.push_back( &other );
        -: 2240:                return *this;
        -: 2241:            }
        -: 2242:
        -: 2243:            std::vector<MatcherBase<ArgT> const*> m_matchers;
        -: 2244:        };
        -: 2245:        template<typename ArgT>
        -: 2246:        struct MatchAnyOf : MatcherBase<ArgT> {
        -: 2247:
        -: 2248:            bool match( ArgT const& arg ) const override {
        -: 2249:                for( auto matcher : m_matchers ) {
        -: 2250:                    if (matcher->match(arg))
        -: 2251:                        return true;
        -: 2252:                }
        -: 2253:                return false;
        -: 2254:            }
        -: 2255:            std::string describe() const override {
        -: 2256:                std::string description;
        -: 2257:                description.reserve( 4 + m_matchers.size()*32 );
        -: 2258:                description += "( ";
        -: 2259:                bool first = true;
        -: 2260:                for( auto matcher : m_matchers ) {
        -: 2261:                    if( first )
        -: 2262:                        first = false;
        -: 2263:                    else
        -: 2264:                        description += " or ";
        -: 2265:                    description += matcher->toString();
        -: 2266:                }
        -: 2267:                description += " )";
        -: 2268:                return description;
        -: 2269:            }
        -: 2270:
        -: 2271:            MatchAnyOf<ArgT>& operator || ( MatcherBase<ArgT> const& other ) {
        -: 2272:                m_matchers.push_back( &other );
        -: 2273:                return *this;
        -: 2274:            }
        -: 2275:
        -: 2276:            std::vector<MatcherBase<ArgT> const*> m_matchers;
        -: 2277:        };
        -: 2278:
        -: 2279:        template<typename ArgT>
        -: 2280:        struct MatchNotOf : MatcherBase<ArgT> {
        -: 2281:
        -: 2282:            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}
        -: 2283:
        -: 2284:            bool match( ArgT const& arg ) const override {
        -: 2285:                return !m_underlyingMatcher.match( arg );
        -: 2286:            }
        -: 2287:
        -: 2288:            std::string describe() const override {
        -: 2289:                return "not " + m_underlyingMatcher.toString();
        -: 2290:            }
        -: 2291:            MatcherBase<ArgT> const& m_underlyingMatcher;
        -: 2292:        };
        -: 2293:
        -: 2294:        template<typename T>
        -: 2295:        MatchAllOf<T> MatcherBase<T>::operator && ( MatcherBase const& other ) const {
        -: 2296:            return MatchAllOf<T>() && *this && other;
        -: 2297:        }
        -: 2298:        template<typename T>
        -: 2299:        MatchAnyOf<T> MatcherBase<T>::operator || ( MatcherBase const& other ) const {
        -: 2300:            return MatchAnyOf<T>() || *this || other;
        -: 2301:        }
        -: 2302:        template<typename T>
        -: 2303:        MatchNotOf<T> MatcherBase<T>::operator ! () const {
        -: 2304:            return MatchNotOf<T>( *this );
        -: 2305:        }
        -: 2306:
        -: 2307:    } // namespace Impl
        -: 2308:
        -: 2309:} // namespace Matchers
        -: 2310:
        -: 2311:using namespace Matchers;
        -: 2312:using Matchers::Impl::MatcherBase;
        -: 2313:
        -: 2314:} // namespace Catch
        -: 2315:
        -: 2316:// end catch_matchers.h
        -: 2317:// start catch_matchers_floating.h
        -: 2318:
        -: 2319:#include <type_traits>
        -: 2320:#include <cmath>
        -: 2321:
        -: 2322:namespace Catch {
        -: 2323:namespace Matchers {
        -: 2324:
        -: 2325:    namespace Floating {
        -: 2326:
        -: 2327:        enum class FloatingPointKind : uint8_t;
        -: 2328:
        -: 2329:        struct WithinAbsMatcher : MatcherBase<double> {
        -: 2330:            WithinAbsMatcher(double target, double margin);
        -: 2331:            bool match(double const& matchee) const override;
        -: 2332:            std::string describe() const override;
        -: 2333:        private:
        -: 2334:            double m_target;
        -: 2335:            double m_margin;
        -: 2336:        };
        -: 2337:
        -: 2338:        struct WithinUlpsMatcher : MatcherBase<double> {
        -: 2339:            WithinUlpsMatcher(double target, int ulps, FloatingPointKind baseType);
        -: 2340:            bool match(double const& matchee) const override;
        -: 2341:            std::string describe() const override;
        -: 2342:        private:
        -: 2343:            double m_target;
        -: 2344:            int m_ulps;
        -: 2345:            FloatingPointKind m_type;
        -: 2346:        };
        -: 2347:
        -: 2348:    } // namespace Floating
        -: 2349:
        -: 2350:    // The following functions create the actual matcher objects.
        -: 2351:    // This allows the types to be inferred
        -: 2352:    Floating::WithinUlpsMatcher WithinULP(double target, int maxUlpDiff);
        -: 2353:    Floating::WithinUlpsMatcher WithinULP(float target, int maxUlpDiff);
        -: 2354:    Floating::WithinAbsMatcher WithinAbs(double target, double margin);
        -: 2355:
        -: 2356:} // namespace Matchers
        -: 2357:} // namespace Catch
        -: 2358:
        -: 2359:// end catch_matchers_floating.h
        -: 2360:// start catch_matchers_string.h
        -: 2361:
        -: 2362:#include <string>
        -: 2363:
        -: 2364:namespace Catch {
        -: 2365:namespace Matchers {
        -: 2366:
        -: 2367:    namespace StdString {
        -: 2368:
        -: 2369:        struct CasedString
        -: 2370:        {
        -: 2371:            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity );
        -: 2372:            std::string adjustString( std::string const& str ) const;
        -: 2373:            std::string caseSensitivitySuffix() const;
        -: 2374:
        -: 2375:            CaseSensitive::Choice m_caseSensitivity;
        -: 2376:            std::string m_str;
        -: 2377:        };
        -: 2378:
        -: 2379:        struct StringMatcherBase : MatcherBase<std::string> {
        -: 2380:            StringMatcherBase( std::string const& operation, CasedString const& comparator );
        -: 2381:            std::string describe() const override;
        -: 2382:
        -: 2383:            CasedString m_comparator;
        -: 2384:            std::string m_operation;
        -: 2385:        };
        -: 2386:
        -: 2387:        struct EqualsMatcher : StringMatcherBase {
        -: 2388:            EqualsMatcher( CasedString const& comparator );
        -: 2389:            bool match( std::string const& source ) const override;
        -: 2390:        };
        -: 2391:        struct ContainsMatcher : StringMatcherBase {
        -: 2392:            ContainsMatcher( CasedString const& comparator );
        -: 2393:            bool match( std::string const& source ) const override;
        -: 2394:        };
        -: 2395:        struct StartsWithMatcher : StringMatcherBase {
        -: 2396:            StartsWithMatcher( CasedString const& comparator );
        -: 2397:            bool match( std::string const& source ) const override;
        -: 2398:        };
        -: 2399:        struct EndsWithMatcher : StringMatcherBase {
        -: 2400:            EndsWithMatcher( CasedString const& comparator );
        -: 2401:            bool match( std::string const& source ) const override;
        -: 2402:        };
        -: 2403:
        -: 2404:        struct RegexMatcher : MatcherBase<std::string> {
        -: 2405:            RegexMatcher( std::string regex, CaseSensitive::Choice caseSensitivity );
        -: 2406:            bool match( std::string const& matchee ) const override;
        -: 2407:            std::string describe() const override;
        -: 2408:
        -: 2409:        private:
        -: 2410:            std::string m_regex;
        -: 2411:            CaseSensitive::Choice m_caseSensitivity;
        -: 2412:        };
        -: 2413:
        -: 2414:    } // namespace StdString
        -: 2415:
        -: 2416:    // The following functions create the actual matcher objects.
        -: 2417:    // This allows the types to be inferred
        -: 2418:
        -: 2419:    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
        -: 2420:    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
        -: 2421:    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
        -: 2422:    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
        -: 2423:    StdString::RegexMatcher Matches( std::string const& regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
        -: 2424:
        -: 2425:} // namespace Matchers
        -: 2426:} // namespace Catch
        -: 2427:
        -: 2428:// end catch_matchers_string.h
        -: 2429:// start catch_matchers_vector.h
        -: 2430:
        -: 2431:#include <algorithm>
        -: 2432:
        -: 2433:namespace Catch {
        -: 2434:namespace Matchers {
        -: 2435:
        -: 2436:    namespace Vector {
        -: 2437:        namespace Detail {
        -: 2438:            template <typename InputIterator, typename T>
        -: 2439:            size_t count(InputIterator first, InputIterator last, T const& item) {
        -: 2440:                size_t cnt = 0;
        -: 2441:                for (; first != last; ++first) {
        -: 2442:                    if (*first == item) {
        -: 2443:                        ++cnt;
        -: 2444:                    }
        -: 2445:                }
        -: 2446:                return cnt;
        -: 2447:            }
        -: 2448:            template <typename InputIterator, typename T>
        -: 2449:            bool contains(InputIterator first, InputIterator last, T const& item) {
        -: 2450:                for (; first != last; ++first) {
        -: 2451:                    if (*first == item) {
        -: 2452:                        return true;
        -: 2453:                    }
        -: 2454:                }
        -: 2455:                return false;
        -: 2456:            }
        -: 2457:        }
        -: 2458:
        -: 2459:        template<typename T>
        -: 2460:        struct ContainsElementMatcher : MatcherBase<std::vector<T>> {
        -: 2461:
        -: 2462:            ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}
        -: 2463:
        -: 2464:            bool match(std::vector<T> const &v) const override {
        -: 2465:                for (auto const& el : v) {
        -: 2466:                    if (el == m_comparator) {
        -: 2467:                        return true;
        -: 2468:                    }
        -: 2469:                }
        -: 2470:                return false;
        -: 2471:            }
        -: 2472:
        -: 2473:            std::string describe() const override {
        -: 2474:                return "Contains: " + ::Catch::Detail::stringify( m_comparator );
        -: 2475:            }
        -: 2476:
        -: 2477:            T const& m_comparator;
        -: 2478:        };
        -: 2479:
        -: 2480:        template<typename T>
        -: 2481:        struct ContainsMatcher : MatcherBase<std::vector<T>> {
        -: 2482:
        -: 2483:            ContainsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}
        -: 2484:
        -: 2485:            bool match(std::vector<T> const &v) const override {
        -: 2486:                // !TBD: see note in EqualsMatcher
        -: 2487:                if (m_comparator.size() > v.size())
        -: 2488:                    return false;
        -: 2489:                for (auto const& comparator : m_comparator) {
        -: 2490:                    auto present = false;
        -: 2491:                    for (const auto& el : v) {
        -: 2492:                        if (el == comparator) {
        -: 2493:                            present = true;
        -: 2494:                            break;
        -: 2495:                        }
        -: 2496:                    }
        -: 2497:                    if (!present) {
        -: 2498:                        return false;
        -: 2499:                    }
        -: 2500:                }
        -: 2501:                return true;
        -: 2502:            }
        -: 2503:            std::string describe() const override {
        -: 2504:                return "Contains: " + ::Catch::Detail::stringify( m_comparator );
        -: 2505:            }
        -: 2506:
        -: 2507:            std::vector<T> const& m_comparator;
        -: 2508:        };
        -: 2509:
        -: 2510:        template<typename T>
        -: 2511:        struct EqualsMatcher : MatcherBase<std::vector<T>> {
        -: 2512:
        -: 2513:            EqualsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}
        -: 2514:
        -: 2515:            bool match(std::vector<T> const &v) const override {
        -: 2516:                // !TBD: This currently works if all elements can be compared using !=
        -: 2517:                // - a more general approach would be via a compare template that defaults
        -: 2518:                // to using !=. but could be specialised for, e.g. std::vector<T> etc
        -: 2519:                // - then just call that directly
        -: 2520:                if (m_comparator.size() != v.size())
        -: 2521:                    return false;
        -: 2522:                for (std::size_t i = 0; i < v.size(); ++i)
        -: 2523:                    if (m_comparator[i] != v[i])
        -: 2524:                        return false;
        -: 2525:                return true;
        -: 2526:            }
        -: 2527:            std::string describe() const override {
        -: 2528:                return "Equals: " + ::Catch::Detail::stringify( m_comparator );
        -: 2529:            }
        -: 2530:            std::vector<T> const& m_comparator;
        -: 2531:        };
        -: 2532:
        -: 2533:        template<typename T>
        -: 2534:        struct UnorderedEqualsMatcher : MatcherBase<std::vector<T>> {
        -: 2535:            UnorderedEqualsMatcher(std::vector<T> const& target) : m_target(target) {}
        -: 2536:            bool match(std::vector<T> const& vec) const override {
        -: 2537:                // Note: This is a reimplementation of std::is_permutation,
        -: 2538:                //       because I don't want to include <algorithm> inside the common path
        -: 2539:                if (m_target.size() != vec.size()) {
        -: 2540:                    return false;
        -: 2541:                }
        -: 2542:                auto lfirst = m_target.begin(), llast = m_target.end();
        -: 2543:                auto rfirst = vec.begin(), rlast = vec.end();
        -: 2544:                // Cut common prefix to optimize checking of permuted parts
        -: 2545:                while (lfirst != llast && *lfirst != *rfirst) {
        -: 2546:                    ++lfirst; ++rfirst;
        -: 2547:                }
        -: 2548:                if (lfirst == llast) {
        -: 2549:                    return true;
        -: 2550:                }
        -: 2551:
        -: 2552:                for (auto mid = lfirst; mid != llast; ++mid) {
        -: 2553:                    // Skip already counted items
        -: 2554:                    if (Detail::contains(lfirst, mid, *mid)) {
        -: 2555:                        continue;
        -: 2556:                    }
        -: 2557:                    size_t num_vec = Detail::count(rfirst, rlast, *mid);
        -: 2558:                    if (num_vec == 0 || Detail::count(lfirst, llast, *mid) != num_vec) {
        -: 2559:                        return false;
        -: 2560:                    }
        -: 2561:                }
        -: 2562:
        -: 2563:                return true;
        -: 2564:            }
        -: 2565:
        -: 2566:            std::string describe() const override {
        -: 2567:                return "UnorderedEquals: " + ::Catch::Detail::stringify(m_target);
        -: 2568:            }
        -: 2569:        private:
        -: 2570:            std::vector<T> const& m_target;
        -: 2571:        };
        -: 2572:
        -: 2573:    } // namespace Vector
        -: 2574:
        -: 2575:    // The following functions create the actual matcher objects.
        -: 2576:    // This allows the types to be inferred
        -: 2577:
        -: 2578:    template<typename T>
        -: 2579:    Vector::ContainsMatcher<T> Contains( std::vector<T> const& comparator ) {
        -: 2580:        return Vector::ContainsMatcher<T>( comparator );
        -: 2581:    }
        -: 2582:
        -: 2583:    template<typename T>
        -: 2584:    Vector::ContainsElementMatcher<T> VectorContains( T const& comparator ) {
        -: 2585:        return Vector::ContainsElementMatcher<T>( comparator );
        -: 2586:    }
        -: 2587:
        -: 2588:    template<typename T>
        -: 2589:    Vector::EqualsMatcher<T> Equals( std::vector<T> const& comparator ) {
        -: 2590:        return Vector::EqualsMatcher<T>( comparator );
        -: 2591:    }
        -: 2592:
        -: 2593:    template<typename T>
        -: 2594:    Vector::UnorderedEqualsMatcher<T> UnorderedEquals(std::vector<T> const& target) {
        -: 2595:        return Vector::UnorderedEqualsMatcher<T>(target);
        -: 2596:    }
        -: 2597:
        -: 2598:} // namespace Matchers
        -: 2599:} // namespace Catch
        -: 2600:
        -: 2601:// end catch_matchers_vector.h
        -: 2602:namespace Catch {
        -: 2603:
        -: 2604:    template<typename ArgT, typename MatcherT>
        -: 2605:    class MatchExpr : public ITransientExpression {
        -: 2606:        ArgT const& m_arg;
        -: 2607:        MatcherT m_matcher;
        -: 2608:        StringRef m_matcherString;
        -: 2609:    public:
    #####: 2610:        MatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef matcherString )
    #####: 2611:        :   ITransientExpression{ true, matcher.match( arg ) },
    #####: 2612:            m_arg( arg ),
    #####: 2613:            m_matcher( matcher ),
    #####: 2614:            m_matcherString( matcherString )
    #####: 2615:        {}
        -: 2616:
    #####: 2617:        void streamReconstructedExpression( std::ostream &os ) const override {
    #####: 2618:            auto matcherAsString = m_matcher.toString();
    #####: 2619:            os << Catch::Detail::stringify( m_arg ) << ' ';
    #####: 2620:            if( matcherAsString == Detail::unprintableString )
    #####: 2621:                os << m_matcherString;
        -: 2622:            else
    #####: 2623:                os << matcherAsString;
    #####: 2624:        }
        -: 2625:    };
        -: 2626:
        -: 2627:    using StringMatcher = Matchers::Impl::MatcherBase<std::string>;
        -: 2628:
        -: 2629:    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef matcherString  );
        -: 2630:
        -: 2631:    template<typename ArgT, typename MatcherT>
        -: 2632:    auto makeMatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef matcherString  ) -> MatchExpr<ArgT, MatcherT> {
        -: 2633:        return MatchExpr<ArgT, MatcherT>( arg, matcher, matcherString );
        -: 2634:    }
        -: 2635:
        -: 2636:} // namespace Catch
        -: 2637:
        -: 2638:///////////////////////////////////////////////////////////////////////////////
        -: 2639:#define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \
        -: 2640:    do { \
        -: 2641:        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        -: 2642:        INTERNAL_CATCH_TRY { \
        -: 2643:            catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, #matcher ) ); \
        -: 2644:        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
        -: 2645:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 2646:    } while( false )
        -: 2647:
        -: 2648:///////////////////////////////////////////////////////////////////////////////
        -: 2649:#define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \
        -: 2650:    do { \
        -: 2651:        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(exceptionType) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        -: 2652:        if( catchAssertionHandler.allowThrows() ) \
        -: 2653:            try { \
        -: 2654:                static_cast<void>(__VA_ARGS__ ); \
        -: 2655:                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
        -: 2656:            } \
        -: 2657:            catch( exceptionType const& ex ) { \
        -: 2658:                catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, #matcher ) ); \
        -: 2659:            } \
        -: 2660:            catch( ... ) { \
        -: 2661:                catchAssertionHandler.handleUnexpectedInflightException(); \
        -: 2662:            } \
        -: 2663:        else \
        -: 2664:            catchAssertionHandler.handleThrowingCallSkipped(); \
        -: 2665:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 2666:    } while( false )
        -: 2667:
        -: 2668:// end catch_capture_matchers.h
        -: 2669:#endif
        -: 2670:
        -: 2671:// These files are included here so the single_include script doesn't put them
        -: 2672:// in the conditionally compiled sections
        -: 2673:// start catch_test_case_info.h
        -: 2674:
        -: 2675:#include <string>
        -: 2676:#include <vector>
        -: 2677:#include <memory>
        -: 2678:
        -: 2679:#ifdef __clang__
        -: 2680:#pragma clang diagnostic push
        -: 2681:#pragma clang diagnostic ignored "-Wpadded"
        -: 2682:#endif
        -: 2683:
        -: 2684:namespace Catch {
        -: 2685:
        -: 2686:    struct ITestInvoker;
        -: 2687:
        -: 2688:    struct TestCaseInfo {
        -: 2689:        enum SpecialProperties{
        -: 2690:            None = 0,
        -: 2691:            IsHidden = 1 << 1,
        -: 2692:            ShouldFail = 1 << 2,
        -: 2693:            MayFail = 1 << 3,
        -: 2694:            Throws = 1 << 4,
        -: 2695:            NonPortable = 1 << 5,
        -: 2696:            Benchmark = 1 << 6
        -: 2697:        };
        -: 2698:
        -: 2699:        TestCaseInfo(   std::string const& _name,
        -: 2700:                        std::string const& _className,
        -: 2701:                        std::string const& _description,
        -: 2702:                        std::vector<std::string> const& _tags,
        -: 2703:                        SourceLineInfo const& _lineInfo );
        -: 2704:
        -: 2705:        friend void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags );
        -: 2706:
        -: 2707:        bool isHidden() const;
        -: 2708:        bool throws() const;
        -: 2709:        bool okToFail() const;
        -: 2710:        bool expectedToFail() const;
        -: 2711:
        -: 2712:        std::string tagsAsString() const;
        -: 2713:
        -: 2714:        std::string name;
        -: 2715:        std::string className;
        -: 2716:        std::string description;
        -: 2717:        std::vector<std::string> tags;
        -: 2718:        std::vector<std::string> lcaseTags;
        -: 2719:        SourceLineInfo lineInfo;
        -: 2720:        SpecialProperties properties;
        -: 2721:    };
        -: 2722:
        -: 2723:    class TestCase : public TestCaseInfo {
        -: 2724:    public:
        -: 2725:
        -: 2726:        TestCase( ITestInvoker* testCase, TestCaseInfo&& info );
        -: 2727:
        -: 2728:        TestCase withName( std::string const& _newName ) const;
        -: 2729:
        -: 2730:        void invoke() const;
        -: 2731:
        -: 2732:        TestCaseInfo const& getTestCaseInfo() const;
        -: 2733:
        -: 2734:        bool operator == ( TestCase const& other ) const;
        -: 2735:        bool operator < ( TestCase const& other ) const;
        -: 2736:
        -: 2737:    private:
        -: 2738:        std::shared_ptr<ITestInvoker> test;
        -: 2739:    };
        -: 2740:
        -: 2741:    TestCase makeTestCase(  ITestInvoker* testCase,
        -: 2742:                            std::string const& className,
        -: 2743:                            NameAndTags const& nameAndTags,
        -: 2744:                            SourceLineInfo const& lineInfo );
        -: 2745:}
        -: 2746:
        -: 2747:#ifdef __clang__
        -: 2748:#pragma clang diagnostic pop
        -: 2749:#endif
        -: 2750:
        -: 2751:// end catch_test_case_info.h
        -: 2752:// start catch_interfaces_runner.h
        -: 2753:
        -: 2754:namespace Catch {
        -: 2755:
        -: 2756:    struct IRunner {
        -: 2757:        virtual ~IRunner();
        -: 2758:        virtual bool aborting() const = 0;
        -: 2759:    };
        -: 2760:}
        -: 2761:
        -: 2762:// end catch_interfaces_runner.h
        -: 2763:
        -: 2764:#ifdef __OBJC__
        -: 2765:// start catch_objc.hpp
        -: 2766:
        -: 2767:#import <objc/runtime.h>
        -: 2768:
        -: 2769:#include <string>
        -: 2770:
        -: 2771:// NB. Any general catch headers included here must be included
        -: 2772:// in catch.hpp first to make sure they are included by the single
        -: 2773:// header for non obj-usage
        -: 2774:
        -: 2775:///////////////////////////////////////////////////////////////////////////////
        -: 2776:// This protocol is really only here for (self) documenting purposes, since
        -: 2777:// all its methods are optional.
        -: 2778:@protocol OcFixture
        -: 2779:
        -: 2780:@optional
        -: 2781:
        -: 2782:-(void) setUp;
        -: 2783:-(void) tearDown;
        -: 2784:
        -: 2785:@end
        -: 2786:
        -: 2787:namespace Catch {
        -: 2788:
        -: 2789:    class OcMethod : public ITestInvoker {
        -: 2790:
        -: 2791:    public:
        -: 2792:        OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}
        -: 2793:
        -: 2794:        virtual void invoke() const {
        -: 2795:            id obj = [[m_cls alloc] init];
        -: 2796:
        -: 2797:            performOptionalSelector( obj, @selector(setUp)  );
        -: 2798:            performOptionalSelector( obj, m_sel );
        -: 2799:            performOptionalSelector( obj, @selector(tearDown)  );
        -: 2800:
        -: 2801:            arcSafeRelease( obj );
        -: 2802:        }
        -: 2803:    private:
        -: 2804:        virtual ~OcMethod() {}
        -: 2805:
        -: 2806:        Class m_cls;
        -: 2807:        SEL m_sel;
        -: 2808:    };
        -: 2809:
        -: 2810:    namespace Detail{
        -: 2811:
        -: 2812:        inline std::string getAnnotation(   Class cls,
        -: 2813:                                            std::string const& annotationName,
        -: 2814:                                            std::string const& testCaseName ) {
        -: 2815:            NSString* selStr = [[NSString alloc] initWithFormat:@"Catch_%s_%s", annotationName.c_str(), testCaseName.c_str()];
        -: 2816:            SEL sel = NSSelectorFromString( selStr );
        -: 2817:            arcSafeRelease( selStr );
        -: 2818:            id value = performOptionalSelector( cls, sel );
        -: 2819:            if( value )
        -: 2820:                return [(NSString*)value UTF8String];
        -: 2821:            return "";
        -: 2822:        }
        -: 2823:    }
        -: 2824:
        -: 2825:    inline std::size_t registerTestMethods() {
        -: 2826:        std::size_t noTestMethods = 0;
        -: 2827:        int noClasses = objc_getClassList( nullptr, 0 );
        -: 2828:
        -: 2829:        Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);
        -: 2830:        objc_getClassList( classes, noClasses );
        -: 2831:
        -: 2832:        for( int c = 0; c < noClasses; c++ ) {
        -: 2833:            Class cls = classes[c];
        -: 2834:            {
        -: 2835:                u_int count;
        -: 2836:                Method* methods = class_copyMethodList( cls, &count );
        -: 2837:                for( u_int m = 0; m < count ; m++ ) {
        -: 2838:                    SEL selector = method_getName(methods[m]);
        -: 2839:                    std::string methodName = sel_getName(selector);
        -: 2840:                    if( startsWith( methodName, "Catch_TestCase_" ) ) {
        -: 2841:                        std::string testCaseName = methodName.substr( 15 );
        -: 2842:                        std::string name = Detail::getAnnotation( cls, "Name", testCaseName );
        -: 2843:                        std::string desc = Detail::getAnnotation( cls, "Description", testCaseName );
        -: 2844:                        const char* className = class_getName( cls );
        -: 2845:
        -: 2846:                        getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, name.c_str(), desc.c_str(), SourceLineInfo("",0) ) );
        -: 2847:                        noTestMethods++;
        -: 2848:                    }
        -: 2849:                }
        -: 2850:                free(methods);
        -: 2851:            }
        -: 2852:        }
        -: 2853:        return noTestMethods;
        -: 2854:    }
        -: 2855:
        -: 2856:#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -: 2857:
        -: 2858:    namespace Matchers {
        -: 2859:        namespace Impl {
        -: 2860:        namespace NSStringMatchers {
        -: 2861:
        -: 2862:            struct StringHolder : MatcherBase<NSString*>{
        -: 2863:                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}
        -: 2864:                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}
        -: 2865:                StringHolder() {
        -: 2866:                    arcSafeRelease( m_substr );
        -: 2867:                }
        -: 2868:
        -: 2869:                bool match( NSString* arg ) const override {
        -: 2870:                    return false;
        -: 2871:                }
        -: 2872:
        -: 2873:                NSString* CATCH_ARC_STRONG m_substr;
        -: 2874:            };
        -: 2875:
        -: 2876:            struct Equals : StringHolder {
        -: 2877:                Equals( NSString* substr ) : StringHolder( substr ){}
        -: 2878:
        -: 2879:                bool match( NSString* str ) const override {
        -: 2880:                    return  (str != nil || m_substr == nil ) &&
        -: 2881:                            [str isEqualToString:m_substr];
        -: 2882:                }
        -: 2883:
        -: 2884:                std::string describe() const override {
        -: 2885:                    return "equals string: " + Catch::Detail::stringify( m_substr );
        -: 2886:                }
        -: 2887:            };
        -: 2888:
        -: 2889:            struct Contains : StringHolder {
        -: 2890:                Contains( NSString* substr ) : StringHolder( substr ){}
        -: 2891:
        -: 2892:                bool match( NSString* str ) const {
        -: 2893:                    return  (str != nil || m_substr == nil ) &&
        -: 2894:                            [str rangeOfString:m_substr].location != NSNotFound;
        -: 2895:                }
        -: 2896:
        -: 2897:                std::string describe() const override {
        -: 2898:                    return "contains string: " + Catch::Detail::stringify( m_substr );
        -: 2899:                }
        -: 2900:            };
        -: 2901:
        -: 2902:            struct StartsWith : StringHolder {
        -: 2903:                StartsWith( NSString* substr ) : StringHolder( substr ){}
        -: 2904:
        -: 2905:                bool match( NSString* str ) const override {
        -: 2906:                    return  (str != nil || m_substr == nil ) &&
        -: 2907:                            [str rangeOfString:m_substr].location == 0;
        -: 2908:                }
        -: 2909:
        -: 2910:                std::string describe() const override {
        -: 2911:                    return "starts with: " + Catch::Detail::stringify( m_substr );
        -: 2912:                }
        -: 2913:            };
        -: 2914:            struct EndsWith : StringHolder {
        -: 2915:                EndsWith( NSString* substr ) : StringHolder( substr ){}
        -: 2916:
        -: 2917:                bool match( NSString* str ) const override {
        -: 2918:                    return  (str != nil || m_substr == nil ) &&
        -: 2919:                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];
        -: 2920:                }
        -: 2921:
        -: 2922:                std::string describe() const override {
        -: 2923:                    return "ends with: " + Catch::Detail::stringify( m_substr );
        -: 2924:                }
        -: 2925:            };
        -: 2926:
        -: 2927:        } // namespace NSStringMatchers
        -: 2928:        } // namespace Impl
        -: 2929:
        -: 2930:        inline Impl::NSStringMatchers::Equals
        -: 2931:            Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }
        -: 2932:
        -: 2933:        inline Impl::NSStringMatchers::Contains
        -: 2934:            Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }
        -: 2935:
        -: 2936:        inline Impl::NSStringMatchers::StartsWith
        -: 2937:            StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }
        -: 2938:
        -: 2939:        inline Impl::NSStringMatchers::EndsWith
        -: 2940:            EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }
        -: 2941:
        -: 2942:    } // namespace Matchers
        -: 2943:
        -: 2944:    using namespace Matchers;
        -: 2945:
        -: 2946:#endif // CATCH_CONFIG_DISABLE_MATCHERS
        -: 2947:
        -: 2948:} // namespace Catch
        -: 2949:
        -: 2950:///////////////////////////////////////////////////////////////////////////////
        -: 2951:#define OC_MAKE_UNIQUE_NAME( root, uniqueSuffix ) root##uniqueSuffix
        -: 2952:#define OC_TEST_CASE2( name, desc, uniqueSuffix ) \
        -: 2953:+(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Name_test_, uniqueSuffix ) \
        -: 2954:{ \
        -: 2955:return @ name; \
        -: 2956:} \
        -: 2957:+(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Description_test_, uniqueSuffix ) \
        -: 2958:{ \
        -: 2959:return @ desc; \
        -: 2960:} \
        -: 2961:-(void) OC_MAKE_UNIQUE_NAME( Catch_TestCase_test_, uniqueSuffix )
        -: 2962:
        -: 2963:#define OC_TEST_CASE( name, desc ) OC_TEST_CASE2( name, desc, __LINE__ )
        -: 2964:
        -: 2965:// end catch_objc.hpp
        -: 2966:#endif
        -: 2967:
        -: 2968:#ifdef CATCH_CONFIG_EXTERNAL_INTERFACES
        -: 2969:// start catch_external_interfaces.h
        -: 2970:
        -: 2971:// start catch_reporter_bases.hpp
        -: 2972:
        -: 2973:// start catch_interfaces_reporter.h
        -: 2974:
        -: 2975:// start catch_config.hpp
        -: 2976:
        -: 2977:// start catch_test_spec_parser.h
        -: 2978:
        -: 2979:#ifdef __clang__
        -: 2980:#pragma clang diagnostic push
        -: 2981:#pragma clang diagnostic ignored "-Wpadded"
        -: 2982:#endif
        -: 2983:
        -: 2984:// start catch_test_spec.h
        -: 2985:
        -: 2986:#ifdef __clang__
        -: 2987:#pragma clang diagnostic push
        -: 2988:#pragma clang diagnostic ignored "-Wpadded"
        -: 2989:#endif
        -: 2990:
        -: 2991:// start catch_wildcard_pattern.h
        -: 2992:
        -: 2993:namespace Catch
        -: 2994:{
        -: 2995:    class WildcardPattern {
        -: 2996:        enum WildcardPosition {
        -: 2997:            NoWildcard = 0,
        -: 2998:            WildcardAtStart = 1,
        -: 2999:            WildcardAtEnd = 2,
        -: 3000:            WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd
        -: 3001:        };
        -: 3002:
        -: 3003:    public:
        -: 3004:
        -: 3005:        WildcardPattern( std::string const& pattern, CaseSensitive::Choice caseSensitivity );
    #####: 3006:        virtual ~WildcardPattern() = default;
------------------
_ZN5Catch15WildcardPatternD0Ev:
    #####: 3006:        virtual ~WildcardPattern() = default;
------------------
_ZN5Catch15WildcardPatternD2Ev:
    #####: 3006:        virtual ~WildcardPattern() = default;
------------------
        -: 3007:        virtual bool matches( std::string const& str ) const;
        -: 3008:
        -: 3009:    private:
        -: 3010:        std::string adjustCase( std::string const& str ) const;
        -: 3011:        CaseSensitive::Choice m_caseSensitivity;
        -: 3012:        WildcardPosition m_wildcard = NoWildcard;
        -: 3013:        std::string m_pattern;
        -: 3014:    };
        -: 3015:}
        -: 3016:
        -: 3017:// end catch_wildcard_pattern.h
        -: 3018:#include <string>
        -: 3019:#include <vector>
        -: 3020:#include <memory>
        -: 3021:
        -: 3022:namespace Catch {
        -: 3023:
        -: 3024:    class TestSpec {
        -: 3025:        struct Pattern {
        -: 3026:            virtual ~Pattern();
        -: 3027:            virtual bool matches( TestCaseInfo const& testCase ) const = 0;
        -: 3028:        };
        -: 3029:        using PatternPtr = std::shared_ptr<Pattern>;
        -: 3030:
        -: 3031:        class NamePattern : public Pattern {
        -: 3032:        public:
        -: 3033:            NamePattern( std::string const& name );
        -: 3034:            virtual ~NamePattern();
        -: 3035:            virtual bool matches( TestCaseInfo const& testCase ) const override;
        -: 3036:        private:
        -: 3037:            WildcardPattern m_wildcardPattern;
        -: 3038:        };
        -: 3039:
        -: 3040:        class TagPattern : public Pattern {
        -: 3041:        public:
        -: 3042:            TagPattern( std::string const& tag );
        -: 3043:            virtual ~TagPattern();
        -: 3044:            virtual bool matches( TestCaseInfo const& testCase ) const override;
        -: 3045:        private:
        -: 3046:            std::string m_tag;
        -: 3047:        };
        -: 3048:
        -: 3049:        class ExcludedPattern : public Pattern {
        -: 3050:        public:
        -: 3051:            ExcludedPattern( PatternPtr const& underlyingPattern );
        -: 3052:            virtual ~ExcludedPattern();
        -: 3053:            virtual bool matches( TestCaseInfo const& testCase ) const override;
        -: 3054:        private:
        -: 3055:            PatternPtr m_underlyingPattern;
        -: 3056:        };
        -: 3057:
        -: 3058:        struct Filter {
        -: 3059:            std::vector<PatternPtr> m_patterns;
        -: 3060:
        -: 3061:            bool matches( TestCaseInfo const& testCase ) const;
        -: 3062:        };
        -: 3063:
        -: 3064:    public:
        -: 3065:        bool hasFilters() const;
        -: 3066:        bool matches( TestCaseInfo const& testCase ) const;
        -: 3067:
        -: 3068:    private:
        -: 3069:        std::vector<Filter> m_filters;
        -: 3070:
        -: 3071:        friend class TestSpecParser;
        -: 3072:    };
        -: 3073:}
        -: 3074:
        -: 3075:#ifdef __clang__
        -: 3076:#pragma clang diagnostic pop
        -: 3077:#endif
        -: 3078:
        -: 3079:// end catch_test_spec.h
        -: 3080:// start catch_interfaces_tag_alias_registry.h
        -: 3081:
        -: 3082:#include <string>
        -: 3083:
        -: 3084:namespace Catch {
        -: 3085:
        -: 3086:    struct TagAlias;
        -: 3087:
        -: 3088:    struct ITagAliasRegistry {
        -: 3089:        virtual ~ITagAliasRegistry();
        -: 3090:        // Nullptr if not present
        -: 3091:        virtual TagAlias const* find( std::string const& alias ) const = 0;
        -: 3092:        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;
        -: 3093:
        -: 3094:        static ITagAliasRegistry const& get();
        -: 3095:    };
        -: 3096:
        -: 3097:} // end namespace Catch
        -: 3098:
        -: 3099:// end catch_interfaces_tag_alias_registry.h
        -: 3100:namespace Catch {
        -: 3101:
        -: 3102:    class TestSpecParser {
        -: 3103:        enum Mode{ None, Name, QuotedName, Tag, EscapedName };
        -: 3104:        Mode m_mode = None;
        -: 3105:        bool m_exclusion = false;
        -: 3106:        std::size_t m_start = std::string::npos, m_pos = 0;
        -: 3107:        std::string m_arg;
        -: 3108:        std::vector<std::size_t> m_escapeChars;
        -: 3109:        TestSpec::Filter m_currentFilter;
        -: 3110:        TestSpec m_testSpec;
        -: 3111:        ITagAliasRegistry const* m_tagAliases = nullptr;
        -: 3112:
        -: 3113:    public:
        -: 3114:        TestSpecParser( ITagAliasRegistry const& tagAliases );
        -: 3115:
        -: 3116:        TestSpecParser& parse( std::string const& arg );
        -: 3117:        TestSpec testSpec();
        -: 3118:
        -: 3119:    private:
        -: 3120:        void visitChar( char c );
        -: 3121:        void startNewMode( Mode mode, std::size_t start );
        -: 3122:        void escape();
        -: 3123:        std::string subString() const;
        -: 3124:
        -: 3125:        template<typename T>
       1*: 3126:        void addPattern() {
       1*: 3127:            std::string token = subString();
       1*: 3128:            for( std::size_t i = 0; i < m_escapeChars.size(); ++i )
    #####: 3129:                token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );
       1*: 3130:            m_escapeChars.clear();
       1*: 3131:            if( startsWith( token, "exclude:" ) ) {
    #####: 3132:                m_exclusion = true;
    #####: 3133:                token = token.substr( 8 );
        -: 3134:            }
       1*: 3135:            if( !token.empty() ) {
       1*: 3136:                TestSpec::PatternPtr pattern = std::make_shared<T>( token );
       1*: 3137:                if( m_exclusion )
       1*: 3138:                    pattern = std::make_shared<TestSpec::ExcludedPattern>( pattern );
       1*: 3139:                m_currentFilter.m_patterns.push_back( pattern );
       1*: 3140:            }
       1*: 3141:            m_exclusion = false;
       1*: 3142:            m_mode = None;
       1*: 3143:        }
------------------
_ZN5Catch14TestSpecParser10addPatternINS_8TestSpec10TagPatternEEEvv:
        1: 3126:        void addPattern() {
        1: 3127:            std::string token = subString();
       1*: 3128:            for( std::size_t i = 0; i < m_escapeChars.size(); ++i )
    #####: 3129:                token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );
        1: 3130:            m_escapeChars.clear();
        1: 3131:            if( startsWith( token, "exclude:" ) ) {
    #####: 3132:                m_exclusion = true;
    #####: 3133:                token = token.substr( 8 );
        -: 3134:            }
        1: 3135:            if( !token.empty() ) {
        1: 3136:                TestSpec::PatternPtr pattern = std::make_shared<T>( token );
        1: 3137:                if( m_exclusion )
        1: 3138:                    pattern = std::make_shared<TestSpec::ExcludedPattern>( pattern );
        1: 3139:                m_currentFilter.m_patterns.push_back( pattern );
        1: 3140:            }
        1: 3141:            m_exclusion = false;
        1: 3142:            m_mode = None;
        1: 3143:        }
------------------
_ZN5Catch14TestSpecParser10addPatternINS_8TestSpec11NamePatternEEEvv:
    #####: 3126:        void addPattern() {
    #####: 3127:            std::string token = subString();
    #####: 3128:            for( std::size_t i = 0; i < m_escapeChars.size(); ++i )
    #####: 3129:                token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );
    #####: 3130:            m_escapeChars.clear();
    #####: 3131:            if( startsWith( token, "exclude:" ) ) {
    #####: 3132:                m_exclusion = true;
    #####: 3133:                token = token.substr( 8 );
        -: 3134:            }
    #####: 3135:            if( !token.empty() ) {
    #####: 3136:                TestSpec::PatternPtr pattern = std::make_shared<T>( token );
    #####: 3137:                if( m_exclusion )
    #####: 3138:                    pattern = std::make_shared<TestSpec::ExcludedPattern>( pattern );
    #####: 3139:                m_currentFilter.m_patterns.push_back( pattern );
    #####: 3140:            }
    #####: 3141:            m_exclusion = false;
    #####: 3142:            m_mode = None;
    #####: 3143:        }
------------------
        -: 3144:
        -: 3145:        void addFilter();
        -: 3146:    };
        -: 3147:    TestSpec parseTestSpec( std::string const& arg );
        -: 3148:
        -: 3149:} // namespace Catch
        -: 3150:
        -: 3151:#ifdef __clang__
        -: 3152:#pragma clang diagnostic pop
        -: 3153:#endif
        -: 3154:
        -: 3155:// end catch_test_spec_parser.h
        -: 3156:// start catch_interfaces_config.h
        -: 3157:
        -: 3158:#include <iosfwd>
        -: 3159:#include <string>
        -: 3160:#include <vector>
        -: 3161:#include <memory>
        -: 3162:
        -: 3163:namespace Catch {
        -: 3164:
        -: 3165:    enum class Verbosity {
        -: 3166:        Quiet = 0,
        -: 3167:        Normal,
        -: 3168:        High
        -: 3169:    };
        -: 3170:
        -: 3171:    struct WarnAbout { enum What {
        -: 3172:        Nothing = 0x00,
        -: 3173:        NoAssertions = 0x01,
        -: 3174:        NoTests = 0x02
        -: 3175:    }; };
        -: 3176:
        -: 3177:    struct ShowDurations { enum OrNot {
        -: 3178:        DefaultForReporter,
        -: 3179:        Always,
        -: 3180:        Never
        -: 3181:    }; };
        -: 3182:    struct RunTests { enum InWhatOrder {
        -: 3183:        InDeclarationOrder,
        -: 3184:        InLexicographicalOrder,
        -: 3185:        InRandomOrder
        -: 3186:    }; };
        -: 3187:    struct UseColour { enum YesOrNo {
        -: 3188:        Auto,
        -: 3189:        Yes,
        -: 3190:        No
        -: 3191:    }; };
        -: 3192:    struct WaitForKeypress { enum When {
        -: 3193:        Never,
        -: 3194:        BeforeStart = 1,
        -: 3195:        BeforeExit = 2,
        -: 3196:        BeforeStartAndExit = BeforeStart | BeforeExit
        -: 3197:    }; };
        -: 3198:
        -: 3199:    class TestSpec;
        -: 3200:
        -: 3201:    struct IConfig : NonCopyable {
        -: 3202:
        -: 3203:        virtual ~IConfig();
        -: 3204:
        -: 3205:        virtual bool allowThrows() const = 0;
        -: 3206:        virtual std::ostream& stream() const = 0;
        -: 3207:        virtual std::string name() const = 0;
        -: 3208:        virtual bool includeSuccessfulResults() const = 0;
        -: 3209:        virtual bool shouldDebugBreak() const = 0;
        -: 3210:        virtual bool warnAboutMissingAssertions() const = 0;
        -: 3211:        virtual bool warnAboutNoTests() const = 0;
        -: 3212:        virtual int abortAfter() const = 0;
        -: 3213:        virtual bool showInvisibles() const = 0;
        -: 3214:        virtual ShowDurations::OrNot showDurations() const = 0;
        -: 3215:        virtual TestSpec const& testSpec() const = 0;
        -: 3216:        virtual bool hasTestFilters() const = 0;
        -: 3217:        virtual RunTests::InWhatOrder runOrder() const = 0;
        -: 3218:        virtual unsigned int rngSeed() const = 0;
        -: 3219:        virtual int benchmarkResolutionMultiple() const = 0;
        -: 3220:        virtual UseColour::YesOrNo useColour() const = 0;
        -: 3221:        virtual std::vector<std::string> const& getSectionsToRun() const = 0;
        -: 3222:        virtual Verbosity verbosity() const = 0;
        -: 3223:    };
        -: 3224:
        -: 3225:    using IConfigPtr = std::shared_ptr<IConfig const>;
        -: 3226:}
        -: 3227:
        -: 3228:// end catch_interfaces_config.h
        -: 3229:// Libstdc++ doesn't like incomplete classes for unique_ptr
        -: 3230:
        -: 3231:#include <memory>
        -: 3232:#include <vector>
        -: 3233:#include <string>
        -: 3234:
        -: 3235:#ifndef CATCH_CONFIG_CONSOLE_WIDTH
        -: 3236:#define CATCH_CONFIG_CONSOLE_WIDTH 80
        -: 3237:#endif
        -: 3238:
        -: 3239:namespace Catch {
        -: 3240:
        -: 3241:    struct IStream;
        -: 3242:
        -: 3243:    struct ConfigData {
        -: 3244:        bool listTests = false;
        -: 3245:        bool listTags = false;
        -: 3246:        bool listReporters = false;
        -: 3247:        bool listTestNamesOnly = false;
        -: 3248:
        -: 3249:        bool showSuccessfulTests = false;
        -: 3250:        bool shouldDebugBreak = false;
        -: 3251:        bool noThrow = false;
        -: 3252:        bool showHelp = false;
        -: 3253:        bool showInvisibles = false;
        -: 3254:        bool filenamesAsTags = false;
        -: 3255:        bool libIdentify = false;
        -: 3256:
        -: 3257:        int abortAfter = -1;
        -: 3258:        unsigned int rngSeed = 0;
        -: 3259:        int benchmarkResolutionMultiple = 100;
        -: 3260:
        -: 3261:        Verbosity verbosity = Verbosity::Normal;
        -: 3262:        WarnAbout::What warnings = WarnAbout::Nothing;
        -: 3263:        ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;
        -: 3264:        RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;
        -: 3265:        UseColour::YesOrNo useColour = UseColour::Auto;
        -: 3266:        WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;
        -: 3267:
        -: 3268:        std::string outputFilename;
        -: 3269:        std::string name;
        -: 3270:        std::string processName;
        -: 3271:
        -: 3272:        std::vector<std::string> reporterNames;
        -: 3273:        std::vector<std::string> testsOrTags;
        -: 3274:        std::vector<std::string> sectionsToRun;
        -: 3275:    };
        -: 3276:
        -: 3277:    class Config : public IConfig {
        -: 3278:    public:
        -: 3279:
        -: 3280:        Config() = default;
        -: 3281:        Config( ConfigData const& data );
       1*: 3282:        virtual ~Config() = default;
------------------
_ZN5Catch6ConfigD0Ev:
    #####: 3282:        virtual ~Config() = default;
------------------
_ZN5Catch6ConfigD2Ev:
        1: 3282:        virtual ~Config() = default;
------------------
        -: 3283:
        -: 3284:        std::string const& getFilename() const;
        -: 3285:
        -: 3286:        bool listTests() const;
        -: 3287:        bool listTestNamesOnly() const;
        -: 3288:        bool listTags() const;
        -: 3289:        bool listReporters() const;
        -: 3290:
        -: 3291:        std::string getProcessName() const;
        -: 3292:
        -: 3293:        std::vector<std::string> const& getReporterNames() const;
        -: 3294:        std::vector<std::string> const& getTestsOrTags() const;
        -: 3295:        std::vector<std::string> const& getSectionsToRun() const override;
        -: 3296:
        -: 3297:        virtual TestSpec const& testSpec() const override;
        -: 3298:        bool hasTestFilters() const override;
        -: 3299:
        -: 3300:        bool showHelp() const;
        -: 3301:
        -: 3302:        // IConfig interface
        -: 3303:        bool allowThrows() const override;
        -: 3304:        std::ostream& stream() const override;
        -: 3305:        std::string name() const override;
        -: 3306:        bool includeSuccessfulResults() const override;
        -: 3307:        bool warnAboutMissingAssertions() const override;
        -: 3308:        bool warnAboutNoTests() const override;
        -: 3309:        ShowDurations::OrNot showDurations() const override;
        -: 3310:        RunTests::InWhatOrder runOrder() const override;
        -: 3311:        unsigned int rngSeed() const override;
        -: 3312:        int benchmarkResolutionMultiple() const override;
        -: 3313:        UseColour::YesOrNo useColour() const override;
        -: 3314:        bool shouldDebugBreak() const override;
        -: 3315:        int abortAfter() const override;
        -: 3316:        bool showInvisibles() const override;
        -: 3317:        Verbosity verbosity() const override;
        -: 3318:
        -: 3319:    private:
        -: 3320:
        -: 3321:        IStream const* openStream();
        -: 3322:        ConfigData m_data;
        -: 3323:
        -: 3324:        std::unique_ptr<IStream const> m_stream;
        -: 3325:        TestSpec m_testSpec;
        -: 3326:        bool m_hasTestFilters = false;
        -: 3327:    };
        -: 3328:
        -: 3329:} // end namespace Catch
        -: 3330:
        -: 3331:// end catch_config.hpp
        -: 3332:// start catch_assertionresult.h
        -: 3333:
        -: 3334:#include <string>
        -: 3335:
        -: 3336:namespace Catch {
        -: 3337:
        -: 3338:    struct AssertionResultData
        -: 3339:    {
        -: 3340:        AssertionResultData() = delete;
        -: 3341:
        -: 3342:        AssertionResultData( ResultWas::OfType _resultType, LazyExpression const& _lazyExpression );
        -: 3343:
        -: 3344:        std::string message;
        -: 3345:        mutable std::string reconstructedExpression;
        -: 3346:        LazyExpression lazyExpression;
        -: 3347:        ResultWas::OfType resultType;
        -: 3348:
        -: 3349:        std::string reconstructExpression() const;
        -: 3350:    };
        -: 3351:
        -: 3352:    class AssertionResult {
        -: 3353:    public:
        -: 3354:        AssertionResult() = delete;
        -: 3355:        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );
        -: 3356:
        -: 3357:        bool isOk() const;
        -: 3358:        bool succeeded() const;
        -: 3359:        ResultWas::OfType getResultType() const;
        -: 3360:        bool hasExpression() const;
        -: 3361:        bool hasMessage() const;
        -: 3362:        std::string getExpression() const;
        -: 3363:        std::string getExpressionInMacro() const;
        -: 3364:        bool hasExpandedExpression() const;
        -: 3365:        std::string getExpandedExpression() const;
        -: 3366:        std::string getMessage() const;
        -: 3367:        SourceLineInfo getSourceInfo() const;
        -: 3368:        StringRef getTestMacroName() const;
        -: 3369:
        -: 3370:    //protected:
        -: 3371:        AssertionInfo m_info;
        -: 3372:        AssertionResultData m_resultData;
        -: 3373:    };
        -: 3374:
        -: 3375:} // end namespace Catch
        -: 3376:
        -: 3377:// end catch_assertionresult.h
        -: 3378:// start catch_option.hpp
        -: 3379:
        -: 3380:namespace Catch {
        -: 3381:
        -: 3382:    // An optional type
        -: 3383:    template<typename T>
        -: 3384:    class Option {
        -: 3385:    public:
        5: 3386:        Option() : nullableValue( nullptr ) {}
------------------
_ZN5Catch6OptionINS_12TestCaseInfoEEC2Ev:
        1: 3386:        Option() : nullableValue( nullptr ) {}
------------------
_ZN5Catch6OptionINS_9GroupInfoEEC2Ev:
        1: 3386:        Option() : nullableValue( nullptr ) {}
------------------
_ZN5Catch6OptionINS_11TestRunInfoEEC2Ev:
        1: 3386:        Option() : nullableValue( nullptr ) {}
------------------
_ZN5Catch6OptionINS_15AssertionResultEEC2Ev:
        1: 3386:        Option() : nullableValue( nullptr ) {}
------------------
_ZN5Catch6OptionImEC2Ev:
        1: 3386:        Option() : nullableValue( nullptr ) {}
------------------
        -: 3387:        Option( T const& _value )
        -: 3388:        : nullableValue( new( storage ) T( _value ) )
        -: 3389:        {}
        -: 3390:        Option( Option const& _other )
        -: 3391:        : nullableValue( _other ? new( storage ) T( *_other ) : nullptr )
        -: 3392:        {}
        -: 3393:
        5: 3394:        ~Option() {
        5: 3395:            reset();
        5: 3396:        }
------------------
_ZN5Catch6OptionINS_12TestCaseInfoEED2Ev:
        1: 3394:        ~Option() {
        1: 3395:            reset();
        1: 3396:        }
------------------
_ZN5Catch6OptionINS_9GroupInfoEED2Ev:
        1: 3394:        ~Option() {
        1: 3395:            reset();
        1: 3396:        }
------------------
_ZN5Catch6OptionINS_11TestRunInfoEED2Ev:
        1: 3394:        ~Option() {
        1: 3395:            reset();
        1: 3396:        }
------------------
_ZN5Catch6OptionINS_15AssertionResultEED2Ev:
        1: 3394:        ~Option() {
        1: 3395:            reset();
        1: 3396:        }
------------------
_ZN5Catch6OptionImED2Ev:
        1: 3394:        ~Option() {
        1: 3395:            reset();
        1: 3396:        }
------------------
        -: 3397:
        -: 3398:        Option& operator= ( Option const& _other ) {
        -: 3399:            if( &_other != this ) {
        -: 3400:                reset();
        -: 3401:                if( _other )
        -: 3402:                    nullableValue = new( storage ) T( *_other );
        -: 3403:            }
        -: 3404:            return *this;
        -: 3405:        }
       6*: 3406:        Option& operator = ( T const& _value ) {
       6*: 3407:            reset();
       6*: 3408:            nullableValue = new( storage ) T( _value );
       6*: 3409:            return *this;
        -: 3410:        }
------------------
_ZN5Catch6OptionINS_12TestCaseInfoEEaSERKS1_:
        4: 3406:        Option& operator = ( T const& _value ) {
        4: 3407:            reset();
        4: 3408:            nullableValue = new( storage ) T( _value );
        4: 3409:            return *this;
        -: 3410:        }
------------------
_ZN5Catch6OptionINS_9GroupInfoEEaSERKS1_:
        1: 3406:        Option& operator = ( T const& _value ) {
        1: 3407:            reset();
        1: 3408:            nullableValue = new( storage ) T( _value );
        1: 3409:            return *this;
        -: 3410:        }
------------------
_ZN5Catch6OptionINS_11TestRunInfoEEaSERKS1_:
        1: 3406:        Option& operator = ( T const& _value ) {
        1: 3407:            reset();
        1: 3408:            nullableValue = new( storage ) T( _value );
        1: 3409:            return *this;
        -: 3410:        }
------------------
_ZN5Catch6OptionINS_15AssertionResultEEaSERKS1_:
    #####: 3406:        Option& operator = ( T const& _value ) {
    #####: 3407:            reset();
    #####: 3408:            nullableValue = new( storage ) T( _value );
    #####: 3409:            return *this;
        -: 3410:        }
------------------
_ZN5Catch6OptionImEaSERKm:
    #####: 3406:        Option& operator = ( T const& _value ) {
    #####: 3407:            reset();
    #####: 3408:            nullableValue = new( storage ) T( _value );
    #####: 3409:            return *this;
        -: 3410:        }
------------------
        -: 3411:
       19: 3412:        void reset() {
       19: 3413:            if( nullableValue )
       6*: 3414:                nullableValue->~T();
       19: 3415:            nullableValue = nullptr;
       19: 3416:        }
------------------
_ZN5Catch6OptionINS_12TestCaseInfoEE5resetEv:
       10: 3412:        void reset() {
       10: 3413:            if( nullableValue )
        4: 3414:                nullableValue->~T();
       10: 3415:            nullableValue = nullptr;
       10: 3416:        }
------------------
_ZN5Catch6OptionINS_9GroupInfoEE5resetEv:
        4: 3412:        void reset() {
        4: 3413:            if( nullableValue )
        1: 3414:                nullableValue->~T();
        4: 3415:            nullableValue = nullptr;
        4: 3416:        }
------------------
_ZN5Catch6OptionINS_11TestRunInfoEE5resetEv:
        3: 3412:        void reset() {
        3: 3413:            if( nullableValue )
        1: 3414:                nullableValue->~T();
        3: 3415:            nullableValue = nullptr;
        3: 3416:        }
------------------
_ZN5Catch6OptionINS_15AssertionResultEE5resetEv:
        1: 3412:        void reset() {
        1: 3413:            if( nullableValue )
    #####: 3414:                nullableValue->~T();
        1: 3415:            nullableValue = nullptr;
        1: 3416:        }
------------------
_ZN5Catch6OptionImE5resetEv:
        1: 3412:        void reset() {
        1: 3413:            if( nullableValue )
    #####: 3414:                nullableValue->~T();
        1: 3415:            nullableValue = nullptr;
        1: 3416:        }
------------------
        -: 3417:
    #####: 3418:        T& operator*() { return *nullableValue; }
    #####: 3419:        T const& operator*() const { return *nullableValue; }
    #####: 3420:        T* operator->() { return nullableValue; }
------------------
_ZN5Catch6OptionINS_12TestCaseInfoEEptEv:
    #####: 3420:        T* operator->() { return nullableValue; }
------------------
_ZN5Catch6OptionINS_9GroupInfoEEptEv:
    #####: 3420:        T* operator->() { return nullableValue; }
------------------
_ZN5Catch6OptionINS_11TestRunInfoEEptEv:
    #####: 3420:        T* operator->() { return nullableValue; }
------------------
        -: 3421:        const T* operator->() const { return nullableValue; }
        -: 3422:
    #####: 3423:        T valueOr( T const& defaultValue ) const {
    #####: 3424:            return nullableValue ? *nullableValue : defaultValue;
        -: 3425:        }
        -: 3426:
        1: 3427:        bool some() const { return nullableValue != nullptr; }
        -: 3428:        bool none() const { return nullableValue == nullptr; }
        -: 3429:
        -: 3430:        bool operator !() const { return nullableValue == nullptr; }
        1: 3431:        explicit operator bool() const {
        1: 3432:            return some();
        -: 3433:        }
        -: 3434:
        -: 3435:    private:
        -: 3436:        T *nullableValue;
        -: 3437:        alignas(alignof(T)) char storage[sizeof(T)];
        -: 3438:    };
        -: 3439:
        -: 3440:} // end namespace Catch
        -: 3441:
        -: 3442:// end catch_option.hpp
        -: 3443:#include <string>
        -: 3444:#include <iosfwd>
        -: 3445:#include <map>
        -: 3446:#include <set>
        -: 3447:#include <memory>
        -: 3448:
        -: 3449:namespace Catch {
        -: 3450:
        -: 3451:    struct ReporterConfig {
        -: 3452:        explicit ReporterConfig( IConfigPtr const& _fullConfig );
        -: 3453:
        -: 3454:        ReporterConfig( IConfigPtr const& _fullConfig, std::ostream& _stream );
        -: 3455:
        -: 3456:        std::ostream& stream() const;
        -: 3457:        IConfigPtr fullConfig() const;
        -: 3458:
        -: 3459:    private:
        -: 3460:        std::ostream* m_stream;
        -: 3461:        IConfigPtr m_fullConfig;
        -: 3462:    };
        -: 3463:
        -: 3464:    struct ReporterPreferences {
        -: 3465:        bool shouldRedirectStdOut = false;
        -: 3466:    };
        -: 3467:
        -: 3468:    template<typename T>
        -: 3469:    struct LazyStat : Option<T> {
        6: 3470:        LazyStat& operator=( T const& _value ) {
        6: 3471:            Option<T>::operator=( _value );
        6: 3472:            used = false;
        6: 3473:            return *this;
        -: 3474:        }
------------------
_ZN5Catch8LazyStatINS_12TestCaseInfoEEaSERKS1_:
        4: 3470:        LazyStat& operator=( T const& _value ) {
        4: 3471:            Option<T>::operator=( _value );
        4: 3472:            used = false;
        4: 3473:            return *this;
        -: 3474:        }
------------------
_ZN5Catch8LazyStatINS_9GroupInfoEEaSERKS1_:
        1: 3470:        LazyStat& operator=( T const& _value ) {
        1: 3471:            Option<T>::operator=( _value );
        1: 3472:            used = false;
        1: 3473:            return *this;
        -: 3474:        }
------------------
_ZN5Catch8LazyStatINS_11TestRunInfoEEaSERKS1_:
        1: 3470:        LazyStat& operator=( T const& _value ) {
        1: 3471:            Option<T>::operator=( _value );
        1: 3472:            used = false;
        1: 3473:            return *this;
        -: 3474:        }
------------------
        8: 3475:        void reset() {
        8: 3476:            Option<T>::reset();
        8: 3477:            used = false;
        8: 3478:        }
------------------
_ZN5Catch8LazyStatINS_11TestRunInfoEE5resetEv:
        1: 3475:        void reset() {
        1: 3476:            Option<T>::reset();
        1: 3477:            used = false;
        1: 3478:        }
------------------
_ZN5Catch8LazyStatINS_9GroupInfoEE5resetEv:
        2: 3475:        void reset() {
        2: 3476:            Option<T>::reset();
        2: 3477:            used = false;
        2: 3478:        }
------------------
_ZN5Catch8LazyStatINS_12TestCaseInfoEE5resetEv:
        5: 3475:        void reset() {
        5: 3476:            Option<T>::reset();
        5: 3477:            used = false;
        5: 3478:        }
------------------
        -: 3479:        bool used = false;
        -: 3480:    };
        -: 3481:
        -: 3482:    struct TestRunInfo {
        -: 3483:        TestRunInfo( std::string const& _name );
        -: 3484:        std::string name;
        -: 3485:    };
        -: 3486:    struct GroupInfo {
        -: 3487:        GroupInfo(  std::string const& _name,
        -: 3488:                    std::size_t _groupIndex,
        -: 3489:                    std::size_t _groupsCount );
        -: 3490:
        -: 3491:        std::string name;
        -: 3492:        std::size_t groupIndex;
        -: 3493:        std::size_t groupsCounts;
        -: 3494:    };
        -: 3495:
        -: 3496:    struct AssertionStats {
        -: 3497:        AssertionStats( AssertionResult const& _assertionResult,
        -: 3498:                        std::vector<MessageInfo> const& _infoMessages,
        -: 3499:                        Totals const& _totals );
        -: 3500:
    #####: 3501:        AssertionStats( AssertionStats const& )              = default;
        -: 3502:        AssertionStats( AssertionStats && )                  = default;
        -: 3503:        AssertionStats& operator = ( AssertionStats const& ) = default;
        -: 3504:        AssertionStats& operator = ( AssertionStats && )     = default;
        -: 3505:        virtual ~AssertionStats();
        -: 3506:
        -: 3507:        AssertionResult assertionResult;
        -: 3508:        std::vector<MessageInfo> infoMessages;
        -: 3509:        Totals totals;
        -: 3510:    };
        -: 3511:
        -: 3512:    struct SectionStats {
        -: 3513:        SectionStats(   SectionInfo const& _sectionInfo,
        -: 3514:                        Counts const& _assertions,
        -: 3515:                        double _durationInSeconds,
        -: 3516:                        bool _missingAssertions );
    #####: 3517:        SectionStats( SectionStats const& )              = default;
        -: 3518:        SectionStats( SectionStats && )                  = default;
    #####: 3519:        SectionStats& operator = ( SectionStats const& ) = default;
        -: 3520:        SectionStats& operator = ( SectionStats && )     = default;
        -: 3521:        virtual ~SectionStats();
        -: 3522:
        -: 3523:        SectionInfo sectionInfo;
        -: 3524:        Counts assertions;
        -: 3525:        double durationInSeconds;
        -: 3526:        bool missingAssertions;
        -: 3527:    };
        -: 3528:
        -: 3529:    struct TestCaseStats {
        -: 3530:        TestCaseStats(  TestCaseInfo const& _testInfo,
        -: 3531:                        Totals const& _totals,
        -: 3532:                        std::string const& _stdOut,
        -: 3533:                        std::string const& _stdErr,
        -: 3534:                        bool _aborting );
        -: 3535:
    #####: 3536:        TestCaseStats( TestCaseStats const& )              = default;
        -: 3537:        TestCaseStats( TestCaseStats && )                  = default;
        -: 3538:        TestCaseStats& operator = ( TestCaseStats const& ) = default;
        -: 3539:        TestCaseStats& operator = ( TestCaseStats && )     = default;
        -: 3540:        virtual ~TestCaseStats();
        -: 3541:
        -: 3542:        TestCaseInfo testInfo;
        -: 3543:        Totals totals;
        -: 3544:        std::string stdOut;
        -: 3545:        std::string stdErr;
        -: 3546:        bool aborting;
        -: 3547:    };
        -: 3548:
        -: 3549:    struct TestGroupStats {
        -: 3550:        TestGroupStats( GroupInfo const& _groupInfo,
        -: 3551:                        Totals const& _totals,
        -: 3552:                        bool _aborting );
        -: 3553:        TestGroupStats( GroupInfo const& _groupInfo );
        -: 3554:
    #####: 3555:        TestGroupStats( TestGroupStats const& )              = default;
        -: 3556:        TestGroupStats( TestGroupStats && )                  = default;
        -: 3557:        TestGroupStats& operator = ( TestGroupStats const& ) = default;
        -: 3558:        TestGroupStats& operator = ( TestGroupStats && )     = default;
        -: 3559:        virtual ~TestGroupStats();
        -: 3560:
        -: 3561:        GroupInfo groupInfo;
        -: 3562:        Totals totals;
        -: 3563:        bool aborting;
        -: 3564:    };
        -: 3565:
        -: 3566:    struct TestRunStats {
        -: 3567:        TestRunStats(   TestRunInfo const& _runInfo,
        -: 3568:                        Totals const& _totals,
        -: 3569:                        bool _aborting );
        -: 3570:
    #####: 3571:        TestRunStats( TestRunStats const& )              = default;
        -: 3572:        TestRunStats( TestRunStats && )                  = default;
        -: 3573:        TestRunStats& operator = ( TestRunStats const& ) = default;
        -: 3574:        TestRunStats& operator = ( TestRunStats && )     = default;
        -: 3575:        virtual ~TestRunStats();
        -: 3576:
        -: 3577:        TestRunInfo runInfo;
        -: 3578:        Totals totals;
        -: 3579:        bool aborting;
        -: 3580:    };
        -: 3581:
        -: 3582:    struct BenchmarkInfo {
        -: 3583:        std::string name;
        -: 3584:    };
        -: 3585:    struct BenchmarkStats {
        -: 3586:        BenchmarkInfo info;
        -: 3587:        std::size_t iterations;
        -: 3588:        uint64_t elapsedTimeInNanoseconds;
        -: 3589:    };
        -: 3590:
        -: 3591:    struct IStreamingReporter {
       1*: 3592:        virtual ~IStreamingReporter() = default;
------------------
_ZN5Catch18IStreamingReporterD0Ev:
    #####: 3592:        virtual ~IStreamingReporter() = default;
------------------
_ZN5Catch18IStreamingReporterD2Ev:
        1: 3592:        virtual ~IStreamingReporter() = default;
------------------
        -: 3593:
        -: 3594:        // Implementing class must also provide the following static methods:
        -: 3595:        // static std::string getDescription();
        -: 3596:        // static std::set<Verbosity> getSupportedVerbosities()
        -: 3597:
        -: 3598:        virtual ReporterPreferences getPreferences() const = 0;
        -: 3599:
        -: 3600:        virtual void noMatchingTestCases( std::string const& spec ) = 0;
        -: 3601:
        -: 3602:        virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;
        -: 3603:        virtual void testGroupStarting( GroupInfo const& groupInfo ) = 0;
        -: 3604:
        -: 3605:        virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;
        -: 3606:        virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;
        -: 3607:
        -: 3608:        // *** experimental ***
    #####: 3609:        virtual void benchmarkStarting( BenchmarkInfo const& ) {}
        -: 3610:
        -: 3611:        virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;
        -: 3612:
        -: 3613:        // The return value indicates if the messages buffer should be cleared:
        -: 3614:        virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;
        -: 3615:
        -: 3616:        // *** experimental ***
    #####: 3617:        virtual void benchmarkEnded( BenchmarkStats const& ) {}
        -: 3618:
        -: 3619:        virtual void sectionEnded( SectionStats const& sectionStats ) = 0;
        -: 3620:        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;
        -: 3621:        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;
        -: 3622:        virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;
        -: 3623:
        -: 3624:        virtual void skipTest( TestCaseInfo const& testInfo ) = 0;
        -: 3625:
        -: 3626:        // Default empty implementation provided
        -: 3627:        virtual void fatalErrorEncountered( StringRef name );
        -: 3628:
        -: 3629:        virtual bool isMulti() const;
        -: 3630:    };
        -: 3631:    using IStreamingReporterPtr = std::unique_ptr<IStreamingReporter>;
        -: 3632:
        -: 3633:    struct IReporterFactory {
        -: 3634:        virtual ~IReporterFactory();
        -: 3635:        virtual IStreamingReporterPtr create( ReporterConfig const& config ) const = 0;
        -: 3636:        virtual std::string getDescription() const = 0;
        -: 3637:    };
        -: 3638:    using IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;
        -: 3639:
        -: 3640:    struct IReporterRegistry {
        -: 3641:        using FactoryMap = std::map<std::string, IReporterFactoryPtr>;
        -: 3642:        using Listeners = std::vector<IReporterFactoryPtr>;
        -: 3643:
        -: 3644:        virtual ~IReporterRegistry();
        -: 3645:        virtual IStreamingReporterPtr create( std::string const& name, IConfigPtr const& config ) const = 0;
        -: 3646:        virtual FactoryMap const& getFactories() const = 0;
        -: 3647:        virtual Listeners const& getListeners() const = 0;
        -: 3648:    };
        -: 3649:
        -: 3650:    void addReporter( IStreamingReporterPtr& existingReporter, IStreamingReporterPtr&& additionalReporter );
        -: 3651:
        -: 3652:} // end namespace Catch
        -: 3653:
        -: 3654:// end catch_interfaces_reporter.h
        -: 3655:#include <algorithm>
        -: 3656:#include <cstring>
        -: 3657:#include <cfloat>
        -: 3658:#include <cstdio>
        -: 3659:#include <assert.h>
        -: 3660:#include <memory>
        -: 3661:#include <ostream>
        -: 3662:
        -: 3663:namespace Catch {
        -: 3664:    void prepareExpandedExpression(AssertionResult& result);
        -: 3665:
        -: 3666:    // Returns double formatted as %.3f (format expected on output)
        -: 3667:    std::string getFormattedDuration( double duration );
        -: 3668:
        -: 3669:    template<typename DerivedT>
        -: 3670:    struct StreamingReporterBase : IStreamingReporter {
        -: 3671:
       1*: 3672:        StreamingReporterBase( ReporterConfig const& _config )
       1*: 3673:        :   m_config( _config.fullConfig() ),
       1*: 3674:            stream( _config.stream() )
        -: 3675:        {
       1*: 3676:            m_reporterPrefs.shouldRedirectStdOut = false;
       1*: 3677:            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )
    #####: 3678:                throw std::domain_error( "Verbosity level not supported by this reporter" );
       1*: 3679:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEEC2ERKNS_14ReporterConfigE:
    #####: 3672:        StreamingReporterBase( ReporterConfig const& _config )
    #####: 3673:        :   m_config( _config.fullConfig() ),
    #####: 3674:            stream( _config.stream() )
        -: 3675:        {
    #####: 3676:            m_reporterPrefs.shouldRedirectStdOut = false;
    #####: 3677:            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )
    #####: 3678:                throw std::domain_error( "Verbosity level not supported by this reporter" );
    #####: 3679:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEEC2ERKNS_14ReporterConfigE:
    #####: 3672:        StreamingReporterBase( ReporterConfig const& _config )
    #####: 3673:        :   m_config( _config.fullConfig() ),
    #####: 3674:            stream( _config.stream() )
        -: 3675:        {
    #####: 3676:            m_reporterPrefs.shouldRedirectStdOut = false;
    #####: 3677:            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )
    #####: 3678:                throw std::domain_error( "Verbosity level not supported by this reporter" );
    #####: 3679:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEEC2ERKNS_14ReporterConfigE:
        1: 3672:        StreamingReporterBase( ReporterConfig const& _config )
        1: 3673:        :   m_config( _config.fullConfig() ),
        1: 3674:            stream( _config.stream() )
        -: 3675:        {
        1: 3676:            m_reporterPrefs.shouldRedirectStdOut = false;
        1: 3677:            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )
    #####: 3678:                throw std::domain_error( "Verbosity level not supported by this reporter" );
        1: 3679:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEEC2ERKNS_14ReporterConfigE:
    #####: 3672:        StreamingReporterBase( ReporterConfig const& _config )
    #####: 3673:        :   m_config( _config.fullConfig() ),
    #####: 3674:            stream( _config.stream() )
        -: 3675:        {
    #####: 3676:            m_reporterPrefs.shouldRedirectStdOut = false;
    #####: 3677:            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )
    #####: 3678:                throw std::domain_error( "Verbosity level not supported by this reporter" );
    #####: 3679:        }
------------------
        -: 3680:
      10*: 3681:        ReporterPreferences getPreferences() const override {
      10*: 3682:            return m_reporterPrefs;
        -: 3683:        }
------------------
_ZNK5Catch21StreamingReporterBaseINS_15CompactReporterEE14getPreferencesEv:
    #####: 3681:        ReporterPreferences getPreferences() const override {
    #####: 3682:            return m_reporterPrefs;
        -: 3683:        }
------------------
_ZNK5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEE14getPreferencesEv:
    #####: 3681:        ReporterPreferences getPreferences() const override {
    #####: 3682:            return m_reporterPrefs;
        -: 3683:        }
------------------
_ZNK5Catch21StreamingReporterBaseINS_15ConsoleReporterEE14getPreferencesEv:
       10: 3681:        ReporterPreferences getPreferences() const override {
       10: 3682:            return m_reporterPrefs;
        -: 3683:        }
------------------
_ZNK5Catch21StreamingReporterBaseINS_11XmlReporterEE14getPreferencesEv:
    #####: 3681:        ReporterPreferences getPreferences() const override {
    #####: 3682:            return m_reporterPrefs;
        -: 3683:        }
------------------
        -: 3684:
       1*: 3685:        static std::set<Verbosity> getSupportedVerbosities() {
       1*: 3686:            return { Verbosity::Normal };
        -: 3687:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEE23getSupportedVerbositiesEv:
    #####: 3685:        static std::set<Verbosity> getSupportedVerbosities() {
    #####: 3686:            return { Verbosity::Normal };
        -: 3687:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEE23getSupportedVerbositiesEv:
    #####: 3685:        static std::set<Verbosity> getSupportedVerbosities() {
    #####: 3686:            return { Verbosity::Normal };
        -: 3687:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEE23getSupportedVerbositiesEv:
        1: 3685:        static std::set<Verbosity> getSupportedVerbosities() {
        1: 3686:            return { Verbosity::Normal };
        -: 3687:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEE23getSupportedVerbositiesEv:
    #####: 3685:        static std::set<Verbosity> getSupportedVerbosities() {
    #####: 3686:            return { Verbosity::Normal };
        -: 3687:        }
------------------
        -: 3688:
       1*: 3689:        ~StreamingReporterBase() override = default;
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEED0Ev:
    #####: 3689:        ~StreamingReporterBase() override = default;
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEED2Ev:
    #####: 3689:        ~StreamingReporterBase() override = default;
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEED0Ev:
    #####: 3689:        ~StreamingReporterBase() override = default;
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEED2Ev:
        1: 3689:        ~StreamingReporterBase() override = default;
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEED0Ev:
    #####: 3689:        ~StreamingReporterBase() override = default;
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEED2Ev:
    #####: 3689:        ~StreamingReporterBase() override = default;
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEED0Ev:
    #####: 3689:        ~StreamingReporterBase() override = default;
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEED2Ev:
    #####: 3689:        ~StreamingReporterBase() override = default;
------------------
        -: 3690:
    #####: 3691:        void noMatchingTestCases(std::string const&) override {}
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEE19noMatchingTestCasesERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 3691:        void noMatchingTestCases(std::string const&) override {}
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEE19noMatchingTestCasesERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 3691:        void noMatchingTestCases(std::string const&) override {}
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEE19noMatchingTestCasesERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 3691:        void noMatchingTestCases(std::string const&) override {}
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEE19noMatchingTestCasesERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 3691:        void noMatchingTestCases(std::string const&) override {}
------------------
        -: 3692:
       1*: 3693:        void testRunStarting(TestRunInfo const& _testRunInfo) override {
       1*: 3694:            currentTestRunInfo = _testRunInfo;
       1*: 3695:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEE15testRunStartingERKNS_11TestRunInfoE:
    #####: 3693:        void testRunStarting(TestRunInfo const& _testRunInfo) override {
    #####: 3694:            currentTestRunInfo = _testRunInfo;
    #####: 3695:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEE15testRunStartingERKNS_11TestRunInfoE:
    #####: 3693:        void testRunStarting(TestRunInfo const& _testRunInfo) override {
    #####: 3694:            currentTestRunInfo = _testRunInfo;
    #####: 3695:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEE15testRunStartingERKNS_11TestRunInfoE:
        1: 3693:        void testRunStarting(TestRunInfo const& _testRunInfo) override {
        1: 3694:            currentTestRunInfo = _testRunInfo;
        1: 3695:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEE15testRunStartingERKNS_11TestRunInfoE:
    #####: 3693:        void testRunStarting(TestRunInfo const& _testRunInfo) override {
    #####: 3694:            currentTestRunInfo = _testRunInfo;
    #####: 3695:        }
------------------
       1*: 3696:        void testGroupStarting(GroupInfo const& _groupInfo) override {
       1*: 3697:            currentGroupInfo = _groupInfo;
       1*: 3698:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEE17testGroupStartingERKNS_9GroupInfoE:
    #####: 3696:        void testGroupStarting(GroupInfo const& _groupInfo) override {
    #####: 3697:            currentGroupInfo = _groupInfo;
    #####: 3698:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEE17testGroupStartingERKNS_9GroupInfoE:
    #####: 3696:        void testGroupStarting(GroupInfo const& _groupInfo) override {
    #####: 3697:            currentGroupInfo = _groupInfo;
    #####: 3698:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEE17testGroupStartingERKNS_9GroupInfoE:
        1: 3696:        void testGroupStarting(GroupInfo const& _groupInfo) override {
        1: 3697:            currentGroupInfo = _groupInfo;
        1: 3698:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEE17testGroupStartingERKNS_9GroupInfoE:
    #####: 3696:        void testGroupStarting(GroupInfo const& _groupInfo) override {
    #####: 3697:            currentGroupInfo = _groupInfo;
    #####: 3698:        }
------------------
        -: 3699:
       4*: 3700:        void testCaseStarting(TestCaseInfo const& _testInfo) override  {
       4*: 3701:            currentTestCaseInfo = _testInfo;
       4*: 3702:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEE16testCaseStartingERKNS_12TestCaseInfoE:
    #####: 3700:        void testCaseStarting(TestCaseInfo const& _testInfo) override  {
    #####: 3701:            currentTestCaseInfo = _testInfo;
    #####: 3702:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEE16testCaseStartingERKNS_12TestCaseInfoE:
    #####: 3700:        void testCaseStarting(TestCaseInfo const& _testInfo) override  {
    #####: 3701:            currentTestCaseInfo = _testInfo;
    #####: 3702:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEE16testCaseStartingERKNS_12TestCaseInfoE:
        4: 3700:        void testCaseStarting(TestCaseInfo const& _testInfo) override  {
        4: 3701:            currentTestCaseInfo = _testInfo;
        4: 3702:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEE16testCaseStartingERKNS_12TestCaseInfoE:
    #####: 3700:        void testCaseStarting(TestCaseInfo const& _testInfo) override  {
    #####: 3701:            currentTestCaseInfo = _testInfo;
    #####: 3702:        }
------------------
      19*: 3703:        void sectionStarting(SectionInfo const& _sectionInfo) override {
      19*: 3704:            m_sectionStack.push_back(_sectionInfo);
      19*: 3705:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEE15sectionStartingERKNS_11SectionInfoE:
    #####: 3703:        void sectionStarting(SectionInfo const& _sectionInfo) override {
    #####: 3704:            m_sectionStack.push_back(_sectionInfo);
    #####: 3705:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEE15sectionStartingERKNS_11SectionInfoE:
    #####: 3703:        void sectionStarting(SectionInfo const& _sectionInfo) override {
    #####: 3704:            m_sectionStack.push_back(_sectionInfo);
    #####: 3705:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEE15sectionStartingERKNS_11SectionInfoE:
    #####: 3703:        void sectionStarting(SectionInfo const& _sectionInfo) override {
    #####: 3704:            m_sectionStack.push_back(_sectionInfo);
    #####: 3705:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEE15sectionStartingERKNS_11SectionInfoE:
       19: 3703:        void sectionStarting(SectionInfo const& _sectionInfo) override {
       19: 3704:            m_sectionStack.push_back(_sectionInfo);
       19: 3705:        }
------------------
        -: 3706:
      19*: 3707:        void sectionEnded(SectionStats const& /* _sectionStats */) override {
      19*: 3708:            m_sectionStack.pop_back();
      19*: 3709:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEE12sectionEndedERKNS_12SectionStatsE:
    #####: 3707:        void sectionEnded(SectionStats const& /* _sectionStats */) override {
    #####: 3708:            m_sectionStack.pop_back();
    #####: 3709:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEE12sectionEndedERKNS_12SectionStatsE:
    #####: 3707:        void sectionEnded(SectionStats const& /* _sectionStats */) override {
    #####: 3708:            m_sectionStack.pop_back();
    #####: 3709:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEE12sectionEndedERKNS_12SectionStatsE:
    #####: 3707:        void sectionEnded(SectionStats const& /* _sectionStats */) override {
    #####: 3708:            m_sectionStack.pop_back();
    #####: 3709:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEE12sectionEndedERKNS_12SectionStatsE:
       19: 3707:        void sectionEnded(SectionStats const& /* _sectionStats */) override {
       19: 3708:            m_sectionStack.pop_back();
       19: 3709:        }
------------------
       4*: 3710:        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override {
       4*: 3711:            currentTestCaseInfo.reset();
       4*: 3712:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEE13testCaseEndedERKNS_13TestCaseStatsE:
    #####: 3710:        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override {
    #####: 3711:            currentTestCaseInfo.reset();
    #####: 3712:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEE13testCaseEndedERKNS_13TestCaseStatsE:
    #####: 3710:        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override {
    #####: 3711:            currentTestCaseInfo.reset();
    #####: 3712:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEE13testCaseEndedERKNS_13TestCaseStatsE:
    #####: 3710:        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override {
    #####: 3711:            currentTestCaseInfo.reset();
    #####: 3712:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEE13testCaseEndedERKNS_13TestCaseStatsE:
        4: 3710:        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override {
        4: 3711:            currentTestCaseInfo.reset();
        4: 3712:        }
------------------
       1*: 3713:        void testGroupEnded(TestGroupStats const& /* _testGroupStats */) override {
       1*: 3714:            currentGroupInfo.reset();
       1*: 3715:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEE14testGroupEndedERKNS_14TestGroupStatsE:
    #####: 3713:        void testGroupEnded(TestGroupStats const& /* _testGroupStats */) override {
    #####: 3714:            currentGroupInfo.reset();
    #####: 3715:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEE14testGroupEndedERKNS_14TestGroupStatsE:
    #####: 3713:        void testGroupEnded(TestGroupStats const& /* _testGroupStats */) override {
    #####: 3714:            currentGroupInfo.reset();
    #####: 3715:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEE14testGroupEndedERKNS_14TestGroupStatsE:
    #####: 3713:        void testGroupEnded(TestGroupStats const& /* _testGroupStats */) override {
    #####: 3714:            currentGroupInfo.reset();
    #####: 3715:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEE14testGroupEndedERKNS_14TestGroupStatsE:
        1: 3713:        void testGroupEnded(TestGroupStats const& /* _testGroupStats */) override {
        1: 3714:            currentGroupInfo.reset();
        1: 3715:        }
------------------
       1*: 3716:        void testRunEnded(TestRunStats const& /* _testRunStats */) override {
       1*: 3717:            currentTestCaseInfo.reset();
       1*: 3718:            currentGroupInfo.reset();
       1*: 3719:            currentTestRunInfo.reset();
       1*: 3720:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEE12testRunEndedERKNS_12TestRunStatsE:
    #####: 3716:        void testRunEnded(TestRunStats const& /* _testRunStats */) override {
    #####: 3717:            currentTestCaseInfo.reset();
    #####: 3718:            currentGroupInfo.reset();
    #####: 3719:            currentTestRunInfo.reset();
    #####: 3720:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEE12testRunEndedERKNS_12TestRunStatsE:
    #####: 3716:        void testRunEnded(TestRunStats const& /* _testRunStats */) override {
    #####: 3717:            currentTestCaseInfo.reset();
    #####: 3718:            currentGroupInfo.reset();
    #####: 3719:            currentTestRunInfo.reset();
    #####: 3720:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEE12testRunEndedERKNS_12TestRunStatsE:
        1: 3716:        void testRunEnded(TestRunStats const& /* _testRunStats */) override {
        1: 3717:            currentTestCaseInfo.reset();
        1: 3718:            currentGroupInfo.reset();
        1: 3719:            currentTestRunInfo.reset();
        1: 3720:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEE12testRunEndedERKNS_12TestRunStatsE:
    #####: 3716:        void testRunEnded(TestRunStats const& /* _testRunStats */) override {
    #####: 3717:            currentTestCaseInfo.reset();
    #####: 3718:            currentGroupInfo.reset();
    #####: 3719:            currentTestRunInfo.reset();
    #####: 3720:        }
------------------
        -: 3721:
    #####: 3722:        void skipTest(TestCaseInfo const&) override {
        -: 3723:            // Don't do anything with this by default.
        -: 3724:            // It can optionally be overridden in the derived class.
    #####: 3725:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_21TestEventListenerBaseEE8skipTestERKNS_12TestCaseInfoE:
    #####: 3722:        void skipTest(TestCaseInfo const&) override {
        -: 3723:            // Don't do anything with this by default.
        -: 3724:            // It can optionally be overridden in the derived class.
    #####: 3725:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15CompactReporterEE8skipTestERKNS_12TestCaseInfoE:
    #####: 3722:        void skipTest(TestCaseInfo const&) override {
        -: 3723:            // Don't do anything with this by default.
        -: 3724:            // It can optionally be overridden in the derived class.
    #####: 3725:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_15ConsoleReporterEE8skipTestERKNS_12TestCaseInfoE:
    #####: 3722:        void skipTest(TestCaseInfo const&) override {
        -: 3723:            // Don't do anything with this by default.
        -: 3724:            // It can optionally be overridden in the derived class.
    #####: 3725:        }
------------------
_ZN5Catch21StreamingReporterBaseINS_11XmlReporterEE8skipTestERKNS_12TestCaseInfoE:
    #####: 3722:        void skipTest(TestCaseInfo const&) override {
        -: 3723:            // Don't do anything with this by default.
        -: 3724:            // It can optionally be overridden in the derived class.
    #####: 3725:        }
------------------
        -: 3726:
        -: 3727:        IConfigPtr m_config;
        -: 3728:        std::ostream& stream;
        -: 3729:
        -: 3730:        LazyStat<TestRunInfo> currentTestRunInfo;
        -: 3731:        LazyStat<GroupInfo> currentGroupInfo;
        -: 3732:        LazyStat<TestCaseInfo> currentTestCaseInfo;
        -: 3733:
        -: 3734:        std::vector<SectionInfo> m_sectionStack;
        -: 3735:        ReporterPreferences m_reporterPrefs;
        -: 3736:    };
        -: 3737:
        -: 3738:    template<typename DerivedT>
        -: 3739:    struct CumulativeReporterBase : IStreamingReporter {
        -: 3740:        template<typename T, typename ChildNodeT>
        -: 3741:        struct Node {
    #####: 3742:            explicit Node( T const& _value ) : value( _value ) {}
------------------
_ZN5Catch22CumulativeReporterBaseINS_13JunitReporterEE4NodeINS_12TestRunStatsENS3_INS_14TestGroupStatsENS3_INS_13TestCaseStatsENS2_11SectionNodeEEEEEEC2ERKS4_:
    #####: 3742:            explicit Node( T const& _value ) : value( _value ) {}
------------------
_ZN5Catch22CumulativeReporterBaseINS_13JunitReporterEE4NodeINS_14TestGroupStatsENS3_INS_13TestCaseStatsENS2_11SectionNodeEEEEC2ERKS4_:
    #####: 3742:            explicit Node( T const& _value ) : value( _value ) {}
------------------
_ZN5Catch22CumulativeReporterBaseINS_13JunitReporterEE4NodeINS_13TestCaseStatsENS2_11SectionNodeEEC2ERKS4_:
    #####: 3742:            explicit Node( T const& _value ) : value( _value ) {}
------------------
    #####: 3743:            virtual ~Node() {}
------------------
_ZN5Catch22CumulativeReporterBaseINS_13JunitReporterEE4NodeINS_12TestRunStatsENS3_INS_14TestGroupStatsENS3_INS_13TestCaseStatsENS2_11SectionNodeEEEEEED0Ev:
    #####: 3743:            virtual ~Node() {}
------------------
_ZN5Catch22CumulativeReporterBaseINS_13JunitReporterEE4NodeINS_12TestRunStatsENS3_INS_14TestGroupStatsENS3_INS_13TestCaseStatsENS2_11SectionNodeEEEEEED2Ev:
    #####: 3743:            virtual ~Node() {}
------------------
_ZN5Catch22CumulativeReporterBaseINS_13JunitReporterEE4NodeINS_14TestGroupStatsENS3_INS_13TestCaseStatsENS2_11SectionNodeEEEED0Ev:
    #####: 3743:            virtual ~Node() {}
------------------
_ZN5Catch22CumulativeReporterBaseINS_13JunitReporterEE4NodeINS_14TestGroupStatsENS3_INS_13TestCaseStatsENS2_11SectionNodeEEEED2Ev:
    #####: 3743:            virtual ~Node() {}
------------------
_ZN5Catch22CumulativeReporterBaseINS_13JunitReporterEE4NodeINS_13TestCaseStatsENS2_11SectionNodeEED0Ev:
    #####: 3743:            virtual ~Node() {}
------------------
_ZN5Catch22CumulativeReporterBaseINS_13JunitReporterEE4NodeINS_13TestCaseStatsENS2_11SectionNodeEED2Ev:
    #####: 3743:            virtual ~Node() {}
------------------
        -: 3744:
        -: 3745:            using ChildNodes = std::vector<std::shared_ptr<ChildNodeT>>;
        -: 3746:            T value;
        -: 3747:            ChildNodes children;
        -: 3748:        };
        -: 3749:        struct SectionNode {
    #####: 3750:            explicit SectionNode(SectionStats const& _stats) : stats(_stats) {}
    #####: 3751:            virtual ~SectionNode() = default;
------------------
_ZN5Catch22CumulativeReporterBaseINS_13JunitReporterEE11SectionNodeD0Ev:
    #####: 3751:            virtual ~SectionNode() = default;
------------------
_ZN5Catch22CumulativeReporterBaseINS_13JunitReporterEE11SectionNodeD2Ev:
    #####: 3751:            virtual ~SectionNode() = default;
------------------
        -: 3752:
        -: 3753:            bool operator == (SectionNode const& other) const {
        -: 3754:                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;
        -: 3755:            }
        -: 3756:            bool operator == (std::shared_ptr<SectionNode> const& other) const {
        -: 3757:                return operator==(*other);
        -: 3758:            }
        -: 3759:
        -: 3760:            SectionStats stats;
        -: 3761:            using ChildSections = std::vector<std::shared_ptr<SectionNode>>;
        -: 3762:            using Assertions = std::vector<AssertionStats>;
        -: 3763:            ChildSections childSections;
        -: 3764:            Assertions assertions;
        -: 3765:            std::string stdOut;
        -: 3766:            std::string stdErr;
        -: 3767:        };
        -: 3768:
        -: 3769:        struct BySectionInfo {
    #####: 3770:            BySectionInfo( SectionInfo const& other ) : m_other( other ) {}
    #####: 3771:            BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}
    #####: 3772:            bool operator() (std::shared_ptr<SectionNode> const& node) const {
    #####: 3773:                return ((node->stats.sectionInfo.name == m_other.name) &&
    #####: 3774:                        (node->stats.sectionInfo.lineInfo == m_other.lineInfo));
        -: 3775:            }
        -: 3776:            void operator=(BySectionInfo const&) = delete;
        -: 3777:
        -: 3778:        private:
        -: 3779:            SectionInfo const& m_other;
        -: 3780:        };
        -: 3781:
        -: 3782:        using TestCaseNode = Node<TestCaseStats, SectionNode>;
        -: 3783:        using TestGroupNode = Node<TestGroupStats, TestCaseNode>;
        -: 3784:        using TestRunNode = Node<TestRunStats, TestGroupNode>;
        -: 3785:
    #####: 3786:        CumulativeReporterBase( ReporterConfig const& _config )
    #####: 3787:        :   m_config( _config.fullConfig() ),
    #####: 3788:            stream( _config.stream() )
        -: 3789:        {
    #####: 3790:            m_reporterPrefs.shouldRedirectStdOut = false;
    #####: 3791:            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )
    #####: 3792:                throw std::domain_error( "Verbosity level not supported by this reporter" );
    #####: 3793:        }
    #####: 3794:        ~CumulativeReporterBase() override = default;
------------------
_ZN5Catch22CumulativeReporterBaseINS_13JunitReporterEED0Ev:
    #####: 3794:        ~CumulativeReporterBase() override = default;
------------------
_ZN5Catch22CumulativeReporterBaseINS_13JunitReporterEED2Ev:
    #####: 3794:        ~CumulativeReporterBase() override = default;
------------------
        -: 3795:
    #####: 3796:        ReporterPreferences getPreferences() const override {
    #####: 3797:            return m_reporterPrefs;
        -: 3798:        }
        -: 3799:
    #####: 3800:        static std::set<Verbosity> getSupportedVerbosities() {
    #####: 3801:            return { Verbosity::Normal };
        -: 3802:        }
        -: 3803:
    #####: 3804:        void testRunStarting( TestRunInfo const& ) override {}
    #####: 3805:        void testGroupStarting( GroupInfo const& ) override {}
        -: 3806:
    #####: 3807:        void testCaseStarting( TestCaseInfo const& ) override {}
        -: 3808:
    #####: 3809:        void sectionStarting( SectionInfo const& sectionInfo ) override {
    #####: 3810:            SectionStats incompleteStats( sectionInfo, Counts(), 0, false );
    #####: 3811:            std::shared_ptr<SectionNode> node;
    #####: 3812:            if( m_sectionStack.empty() ) {
    #####: 3813:                if( !m_rootSection )
    #####: 3814:                    m_rootSection = std::make_shared<SectionNode>( incompleteStats );
    #####: 3815:                node = m_rootSection;
        -: 3816:            }
        -: 3817:            else {
    #####: 3818:                SectionNode& parentNode = *m_sectionStack.back();
        -: 3819:                auto it =
    #####: 3820:                    std::find_if(   parentNode.childSections.begin(),
        -: 3821:                                    parentNode.childSections.end(),
    #####: 3822:                                    BySectionInfo( sectionInfo ) );
    #####: 3823:                if( it == parentNode.childSections.end() ) {
    #####: 3824:                    node = std::make_shared<SectionNode>( incompleteStats );
    #####: 3825:                    parentNode.childSections.push_back( node );
        -: 3826:                }
        -: 3827:                else
    #####: 3828:                    node = *it;
        -: 3829:            }
    #####: 3830:            m_sectionStack.push_back( node );
    #####: 3831:            m_deepestSection = std::move(node);
    #####: 3832:        }
        -: 3833:
    #####: 3834:        void assertionStarting(AssertionInfo const&) override {}
        -: 3835:
    #####: 3836:        bool assertionEnded(AssertionStats const& assertionStats) override {
    #####: 3837:            assert(!m_sectionStack.empty());
        -: 3838:            // AssertionResult holds a pointer to a temporary DecomposedExpression,
        -: 3839:            // which getExpandedExpression() calls to build the expression string.
        -: 3840:            // Our section stack copy of the assertionResult will likely outlive the
        -: 3841:            // temporary, so it must be expanded or discarded now to avoid calling
        -: 3842:            // a destroyed object later.
    #####: 3843:            prepareExpandedExpression(const_cast<AssertionResult&>( assertionStats.assertionResult ) );
    #####: 3844:            SectionNode& sectionNode = *m_sectionStack.back();
    #####: 3845:            sectionNode.assertions.push_back(assertionStats);
    #####: 3846:            return true;
        -: 3847:        }
    #####: 3848:        void sectionEnded(SectionStats const& sectionStats) override {
    #####: 3849:            assert(!m_sectionStack.empty());
    #####: 3850:            SectionNode& node = *m_sectionStack.back();
    #####: 3851:            node.stats = sectionStats;
    #####: 3852:            m_sectionStack.pop_back();
    #####: 3853:        }
    #####: 3854:        void testCaseEnded(TestCaseStats const& testCaseStats) override {
    #####: 3855:            auto node = std::make_shared<TestCaseNode>(testCaseStats);
    #####: 3856:            assert(m_sectionStack.size() == 0);
    #####: 3857:            node->children.push_back(m_rootSection);
    #####: 3858:            m_testCases.push_back(node);
    #####: 3859:            m_rootSection.reset();
        -: 3860:
    #####: 3861:            assert(m_deepestSection);
    #####: 3862:            m_deepestSection->stdOut = testCaseStats.stdOut;
    #####: 3863:            m_deepestSection->stdErr = testCaseStats.stdErr;
    #####: 3864:        }
    #####: 3865:        void testGroupEnded(TestGroupStats const& testGroupStats) override {
    #####: 3866:            auto node = std::make_shared<TestGroupNode>(testGroupStats);
    #####: 3867:            node->children.swap(m_testCases);
    #####: 3868:            m_testGroups.push_back(node);
    #####: 3869:        }
    #####: 3870:        void testRunEnded(TestRunStats const& testRunStats) override {
    #####: 3871:            auto node = std::make_shared<TestRunNode>(testRunStats);
    #####: 3872:            node->children.swap(m_testGroups);
    #####: 3873:            m_testRuns.push_back(node);
    #####: 3874:            testRunEndedCumulative();
    #####: 3875:        }
        -: 3876:        virtual void testRunEndedCumulative() = 0;
        -: 3877:
    #####: 3878:        void skipTest(TestCaseInfo const&) override {}
        -: 3879:
        -: 3880:        IConfigPtr m_config;
        -: 3881:        std::ostream& stream;
        -: 3882:        std::vector<AssertionStats> m_assertions;
        -: 3883:        std::vector<std::vector<std::shared_ptr<SectionNode>>> m_sections;
        -: 3884:        std::vector<std::shared_ptr<TestCaseNode>> m_testCases;
        -: 3885:        std::vector<std::shared_ptr<TestGroupNode>> m_testGroups;
        -: 3886:
        -: 3887:        std::vector<std::shared_ptr<TestRunNode>> m_testRuns;
        -: 3888:
        -: 3889:        std::shared_ptr<SectionNode> m_rootSection;
        -: 3890:        std::shared_ptr<SectionNode> m_deepestSection;
        -: 3891:        std::vector<std::shared_ptr<SectionNode>> m_sectionStack;
        -: 3892:        ReporterPreferences m_reporterPrefs;
        -: 3893:    };
        -: 3894:
        -: 3895:    template<char C>
    #####: 3896:    char const* getLineOfChars() {
        -: 3897:        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
    #####: 3898:        if( !*line ) {
    #####: 3899:            std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
    #####: 3900:            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
        -: 3901:        }
    #####: 3902:        return line;
        -: 3903:    }
------------------
_ZN5Catch14getLineOfCharsILc46EEEPKcv:
    #####: 3896:    char const* getLineOfChars() {
        -: 3897:        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
    #####: 3898:        if( !*line ) {
    #####: 3899:            std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
    #####: 3900:            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
        -: 3901:        }
    #####: 3902:        return line;
        -: 3903:    }
------------------
_ZN5Catch14getLineOfCharsILc126EEEPKcv:
    #####: 3896:    char const* getLineOfChars() {
        -: 3897:        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
    #####: 3898:        if( !*line ) {
    #####: 3899:            std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
    #####: 3900:            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
        -: 3901:        }
    #####: 3902:        return line;
        -: 3903:    }
------------------
_ZN5Catch14getLineOfCharsILc45EEEPKcv:
    #####: 3896:    char const* getLineOfChars() {
        -: 3897:        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
    #####: 3898:        if( !*line ) {
    #####: 3899:            std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
    #####: 3900:            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
        -: 3901:        }
    #####: 3902:        return line;
        -: 3903:    }
------------------
        -: 3904:
        -: 3905:    struct TestEventListenerBase : StreamingReporterBase<TestEventListenerBase> {
        -: 3906:        TestEventListenerBase( ReporterConfig const& _config );
        -: 3907:
        -: 3908:        void assertionStarting(AssertionInfo const&) override;
        -: 3909:        bool assertionEnded(AssertionStats const&) override;
        -: 3910:    };
        -: 3911:
        -: 3912:} // end namespace Catch
        -: 3913:
        -: 3914:// end catch_reporter_bases.hpp
        -: 3915:// start catch_console_colour.h
        -: 3916:
        -: 3917:namespace Catch {
        -: 3918:
        -: 3919:    struct Colour {
        -: 3920:        enum Code {
        -: 3921:            None = 0,
        -: 3922:
        -: 3923:            White,
        -: 3924:            Red,
        -: 3925:            Green,
        -: 3926:            Blue,
        -: 3927:            Cyan,
        -: 3928:            Yellow,
        -: 3929:            Grey,
        -: 3930:
        -: 3931:            Bright = 0x10,
        -: 3932:
        -: 3933:            BrightRed = Bright | Red,
        -: 3934:            BrightGreen = Bright | Green,
        -: 3935:            LightGrey = Bright | Grey,
        -: 3936:            BrightWhite = Bright | White,
        -: 3937:            BrightYellow = Bright | Yellow,
        -: 3938:
        -: 3939:            // By intention
        -: 3940:            FileName = LightGrey,
        -: 3941:            Warning = BrightYellow,
        -: 3942:            ResultError = BrightRed,
        -: 3943:            ResultSuccess = BrightGreen,
        -: 3944:            ResultExpectedFailure = Warning,
        -: 3945:
        -: 3946:            Error = BrightRed,
        -: 3947:            Success = Green,
        -: 3948:
        -: 3949:            OriginalExpression = Cyan,
        -: 3950:            ReconstructedExpression = BrightYellow,
        -: 3951:
        -: 3952:            SecondaryText = LightGrey,
        -: 3953:            Headers = White
        -: 3954:        };
        -: 3955:
        -: 3956:        // Use constructed object for RAII guard
        -: 3957:        Colour( Code _colourCode );
        -: 3958:        Colour( Colour&& other ) noexcept;
        -: 3959:        Colour& operator=( Colour&& other ) noexcept;
        -: 3960:        ~Colour();
        -: 3961:
        -: 3962:        // Use static method for one-shot changes
        -: 3963:        static void use( Code _colourCode );
        -: 3964:
        -: 3965:    private:
        -: 3966:        bool m_moved = false;
        -: 3967:    };
        -: 3968:
        -: 3969:    std::ostream& operator << ( std::ostream& os, Colour const& );
        -: 3970:
        -: 3971:} // end namespace Catch
        -: 3972:
        -: 3973:// end catch_console_colour.h
        -: 3974:// start catch_reporter_registrars.hpp
        -: 3975:
        -: 3976:
        -: 3977:namespace Catch {
        -: 3978:
        -: 3979:    template<typename T>
        -: 3980:    class ReporterRegistrar {
        -: 3981:
        -: 3982:        class ReporterFactory : public IReporterFactory {
        -: 3983:
       1*: 3984:            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {
       1*: 3985:                return std::unique_ptr<T>( new T( config ) );
        -: 3986:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_15CompactReporterEE15ReporterFactory6createERKNS_14ReporterConfigE:
    #####: 3984:            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {
    #####: 3985:                return std::unique_ptr<T>( new T( config ) );
        -: 3986:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_15ConsoleReporterEE15ReporterFactory6createERKNS_14ReporterConfigE:
        1: 3984:            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {
        1: 3985:                return std::unique_ptr<T>( new T( config ) );
        -: 3986:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_13JunitReporterEE15ReporterFactory6createERKNS_14ReporterConfigE:
    #####: 3984:            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {
    #####: 3985:                return std::unique_ptr<T>( new T( config ) );
        -: 3986:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_11XmlReporterEE15ReporterFactory6createERKNS_14ReporterConfigE:
    #####: 3984:            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {
    #####: 3985:                return std::unique_ptr<T>( new T( config ) );
        -: 3986:            }
------------------
        -: 3987:
    #####: 3988:            virtual std::string getDescription() const override {
    #####: 3989:                return T::getDescription();
        -: 3990:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_15CompactReporterEE15ReporterFactory14getDescriptionB5cxx11Ev:
    #####: 3988:            virtual std::string getDescription() const override {
    #####: 3989:                return T::getDescription();
        -: 3990:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_15ConsoleReporterEE15ReporterFactory14getDescriptionB5cxx11Ev:
    #####: 3988:            virtual std::string getDescription() const override {
    #####: 3989:                return T::getDescription();
        -: 3990:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_13JunitReporterEE15ReporterFactory14getDescriptionB5cxx11Ev:
    #####: 3988:            virtual std::string getDescription() const override {
    #####: 3989:                return T::getDescription();
        -: 3990:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_11XmlReporterEE15ReporterFactory14getDescriptionB5cxx11Ev:
    #####: 3988:            virtual std::string getDescription() const override {
    #####: 3989:                return T::getDescription();
        -: 3990:            }
------------------
        -: 3991:        };
        -: 3992:
        -: 3993:    public:
        -: 3994:
        4: 3995:        explicit ReporterRegistrar( std::string const& name ) {
        4: 3996:            getMutableRegistryHub().registerReporter( name, std::make_shared<ReporterFactory>() );
        4: 3997:        }
------------------
_ZN5Catch17ReporterRegistrarINS_11XmlReporterEEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 3995:        explicit ReporterRegistrar( std::string const& name ) {
        1: 3996:            getMutableRegistryHub().registerReporter( name, std::make_shared<ReporterFactory>() );
        1: 3997:        }
------------------
_ZN5Catch17ReporterRegistrarINS_13JunitReporterEEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 3995:        explicit ReporterRegistrar( std::string const& name ) {
        1: 3996:            getMutableRegistryHub().registerReporter( name, std::make_shared<ReporterFactory>() );
        1: 3997:        }
------------------
_ZN5Catch17ReporterRegistrarINS_15ConsoleReporterEEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 3995:        explicit ReporterRegistrar( std::string const& name ) {
        1: 3996:            getMutableRegistryHub().registerReporter( name, std::make_shared<ReporterFactory>() );
        1: 3997:        }
------------------
_ZN5Catch17ReporterRegistrarINS_15CompactReporterEEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 3995:        explicit ReporterRegistrar( std::string const& name ) {
        1: 3996:            getMutableRegistryHub().registerReporter( name, std::make_shared<ReporterFactory>() );
        1: 3997:        }
------------------
        -: 3998:    };
        -: 3999:
        -: 4000:    template<typename T>
        -: 4001:    class ListenerRegistrar {
        -: 4002:
        -: 4003:        class ListenerFactory : public IReporterFactory {
        -: 4004:
        -: 4005:            virtual IStreamingReporterPtr create( ReporterConfig const& config ) const override {
        -: 4006:                return std::unique_ptr<T>( new T( config ) );
        -: 4007:            }
        -: 4008:            virtual std::string getDescription() const override {
        -: 4009:                return std::string();
        -: 4010:            }
        -: 4011:        };
        -: 4012:
        -: 4013:    public:
        -: 4014:
        -: 4015:        ListenerRegistrar() {
        -: 4016:            getMutableRegistryHub().registerListener( std::make_shared<ListenerFactory>() );
        -: 4017:        }
        -: 4018:    };
        -: 4019:}
        -: 4020:
        -: 4021:#if !defined(CATCH_CONFIG_DISABLE)
        -: 4022:
        -: 4023:#define CATCH_REGISTER_REPORTER( name, reporterType ) \
        -: 4024:    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS          \
        -: 4025:    namespace{ Catch::ReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); } \
        -: 4026:    CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS
        -: 4027:
        -: 4028:#define CATCH_REGISTER_LISTENER( listenerType ) \
        -: 4029:     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS   \
        -: 4030:     namespace{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; } \
        -: 4031:     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
        -: 4032:#else // CATCH_CONFIG_DISABLE
        -: 4033:
        -: 4034:#define CATCH_REGISTER_REPORTER(name, reporterType)
        -: 4035:#define CATCH_REGISTER_LISTENER(listenerType)
        -: 4036:
        -: 4037:#endif // CATCH_CONFIG_DISABLE
        -: 4038:
        -: 4039:// end catch_reporter_registrars.hpp
        -: 4040:// Allow users to base their work off existing reporters
        -: 4041:// start catch_reporter_compact.h
        -: 4042:
        -: 4043:namespace Catch {
        -: 4044:
        -: 4045:    struct CompactReporter : StreamingReporterBase<CompactReporter> {
        -: 4046:
        -: 4047:        using StreamingReporterBase::StreamingReporterBase;
        -: 4048:
        -: 4049:        ~CompactReporter() override;
        -: 4050:
        -: 4051:        static std::string getDescription();
        -: 4052:
        -: 4053:        ReporterPreferences getPreferences() const override;
        -: 4054:
        -: 4055:        void noMatchingTestCases(std::string const& spec) override;
        -: 4056:
        -: 4057:        void assertionStarting(AssertionInfo const&) override;
        -: 4058:
        -: 4059:        bool assertionEnded(AssertionStats const& _assertionStats) override;
        -: 4060:
        -: 4061:        void sectionEnded(SectionStats const& _sectionStats) override;
        -: 4062:
        -: 4063:        void testRunEnded(TestRunStats const& _testRunStats) override;
        -: 4064:
        -: 4065:    };
        -: 4066:
        -: 4067:} // end namespace Catch
        -: 4068:
        -: 4069:// end catch_reporter_compact.h
        -: 4070:// start catch_reporter_console.h
        -: 4071:
        -: 4072:#if defined(_MSC_VER)
        -: 4073:#pragma warning(push)
        -: 4074:#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
        -: 4075:                              // Note that 4062 (not all labels are handled
        -: 4076:                              // and default is missing) is enabled
        -: 4077:#endif
        -: 4078:
        -: 4079:namespace Catch {
        -: 4080:    // Fwd decls
        -: 4081:    struct SummaryColumn;
        -: 4082:    class TablePrinter;
        -: 4083:
        -: 4084:    struct ConsoleReporter : StreamingReporterBase<ConsoleReporter> {
        -: 4085:        std::unique_ptr<TablePrinter> m_tablePrinter;
        -: 4086:
        -: 4087:        ConsoleReporter(ReporterConfig const& config);
        -: 4088:        ~ConsoleReporter() override;
        -: 4089:        static std::string getDescription();
        -: 4090:
        -: 4091:        void noMatchingTestCases(std::string const& spec) override;
        -: 4092:
        -: 4093:        void assertionStarting(AssertionInfo const&) override;
        -: 4094:
        -: 4095:        bool assertionEnded(AssertionStats const& _assertionStats) override;
        -: 4096:
        -: 4097:        void sectionStarting(SectionInfo const& _sectionInfo) override;
        -: 4098:        void sectionEnded(SectionStats const& _sectionStats) override;
        -: 4099:
        -: 4100:        void benchmarkStarting(BenchmarkInfo const& info) override;
        -: 4101:        void benchmarkEnded(BenchmarkStats const& stats) override;
        -: 4102:
        -: 4103:        void testCaseEnded(TestCaseStats const& _testCaseStats) override;
        -: 4104:        void testGroupEnded(TestGroupStats const& _testGroupStats) override;
        -: 4105:        void testRunEnded(TestRunStats const& _testRunStats) override;
        -: 4106:
        -: 4107:    private:
        -: 4108:
        -: 4109:        void lazyPrint();
        -: 4110:
        -: 4111:        void lazyPrintWithoutClosingBenchmarkTable();
        -: 4112:        void lazyPrintRunInfo();
        -: 4113:        void lazyPrintGroupInfo();
        -: 4114:        void printTestCaseAndSectionHeader();
        -: 4115:
        -: 4116:        void printClosedHeader(std::string const& _name);
        -: 4117:        void printOpenHeader(std::string const& _name);
        -: 4118:
        -: 4119:        // if string has a : in first line will set indent to follow it on
        -: 4120:        // subsequent lines
        -: 4121:        void printHeaderString(std::string const& _string, std::size_t indent = 0);
        -: 4122:
        -: 4123:        void printTotals(Totals const& totals);
        -: 4124:        void printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row);
        -: 4125:
        -: 4126:        void printTotalsDivider(Totals const& totals);
        -: 4127:        void printSummaryDivider();
        -: 4128:
        -: 4129:    private:
        -: 4130:        bool m_headerPrinted = false;
        -: 4131:    };
        -: 4132:
        -: 4133:} // end namespace Catch
        -: 4134:
        -: 4135:#if defined(_MSC_VER)
        -: 4136:#pragma warning(pop)
        -: 4137:#endif
        -: 4138:
        -: 4139:// end catch_reporter_console.h
        -: 4140:// start catch_reporter_junit.h
        -: 4141:
        -: 4142:// start catch_xmlwriter.h
        -: 4143:
        -: 4144:#include <vector>
        -: 4145:
        -: 4146:namespace Catch {
        -: 4147:
        -: 4148:    class XmlEncode {
        -: 4149:    public:
        -: 4150:        enum ForWhat { ForTextNodes, ForAttributes };
        -: 4151:
        -: 4152:        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes );
        -: 4153:
        -: 4154:        void encodeTo( std::ostream& os ) const;
        -: 4155:
        -: 4156:        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode );
        -: 4157:
        -: 4158:    private:
        -: 4159:        std::string m_str;
        -: 4160:        ForWhat m_forWhat;
        -: 4161:    };
        -: 4162:
        -: 4163:    class XmlWriter {
        -: 4164:    public:
        -: 4165:
        -: 4166:        class ScopedElement {
        -: 4167:        public:
        -: 4168:            ScopedElement( XmlWriter* writer );
        -: 4169:
        -: 4170:            ScopedElement( ScopedElement&& other ) noexcept;
        -: 4171:            ScopedElement& operator=( ScopedElement&& other ) noexcept;
        -: 4172:
        -: 4173:            ~ScopedElement();
        -: 4174:
        -: 4175:            ScopedElement& writeText( std::string const& text, bool indent = true );
        -: 4176:
        -: 4177:            template<typename T>
    #####: 4178:            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 4179:                m_writer->writeAttribute( name, attribute );
    #####: 4180:                return *this;
        -: 4181:            }
------------------
_ZN5Catch9XmlWriter13ScopedElement14writeAttributeIbEERS1_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####: 4178:            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 4179:                m_writer->writeAttribute( name, attribute );
    #####: 4180:                return *this;
        -: 4181:            }
------------------
_ZN5Catch9XmlWriter13ScopedElement14writeAttributeIdEERS1_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####: 4178:            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 4179:                m_writer->writeAttribute( name, attribute );
    #####: 4180:                return *this;
        -: 4181:            }
------------------
_ZN5Catch9XmlWriter13ScopedElement14writeAttributeImEERS1_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####: 4178:            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 4179:                m_writer->writeAttribute( name, attribute );
    #####: 4180:                return *this;
        -: 4181:            }
------------------
        -: 4182:
        -: 4183:        private:
        -: 4184:            mutable XmlWriter* m_writer = nullptr;
        -: 4185:        };
        -: 4186:
        -: 4187:        XmlWriter( std::ostream& os = Catch::cout() );
        -: 4188:        ~XmlWriter();
        -: 4189:
        -: 4190:        XmlWriter( XmlWriter const& ) = delete;
        -: 4191:        XmlWriter& operator=( XmlWriter const& ) = delete;
        -: 4192:
        -: 4193:        XmlWriter& startElement( std::string const& name );
        -: 4194:
        -: 4195:        ScopedElement scopedElement( std::string const& name );
        -: 4196:
        -: 4197:        XmlWriter& endElement();
        -: 4198:
        -: 4199:        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute );
        -: 4200:
        -: 4201:        XmlWriter& writeAttribute( std::string const& name, bool attribute );
        -: 4202:
        -: 4203:        template<typename T>
    #####: 4204:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 4205:            ReusableStringStream rss;
    #####: 4206:            rss << attribute;
    #####: 4207:            return writeAttribute( name, rss.str() );
    #####: 4208:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeIPKcEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####: 4204:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 4205:            ReusableStringStream rss;
    #####: 4206:            rss << attribute;
    #####: 4207:            return writeAttribute( name, rss.str() );
    #####: 4208:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeINS_9StringRefEEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####: 4204:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 4205:            ReusableStringStream rss;
    #####: 4206:            rss << attribute;
    #####: 4207:            return writeAttribute( name, rss.str() );
    #####: 4208:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeIA5_cEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####: 4204:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 4205:            ReusableStringStream rss;
    #####: 4206:            rss << attribute;
    #####: 4207:            return writeAttribute( name, rss.str() );
    #####: 4208:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeIdEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####: 4204:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 4205:            ReusableStringStream rss;
    #####: 4206:            rss << attribute;
    #####: 4207:            return writeAttribute( name, rss.str() );
    #####: 4208:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeIA1_cEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####: 4204:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 4205:            ReusableStringStream rss;
    #####: 4206:            rss << attribute;
    #####: 4207:            return writeAttribute( name, rss.str() );
    #####: 4208:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeIA4_cEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####: 4204:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 4205:            ReusableStringStream rss;
    #####: 4206:            rss << attribute;
    #####: 4207:            return writeAttribute( name, rss.str() );
    #####: 4208:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeImEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####: 4204:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 4205:            ReusableStringStream rss;
    #####: 4206:            rss << attribute;
    #####: 4207:            return writeAttribute( name, rss.str() );
    #####: 4208:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeIjEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####: 4204:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 4205:            ReusableStringStream rss;
    #####: 4206:            rss << attribute;
    #####: 4207:            return writeAttribute( name, rss.str() );
    #####: 4208:        }
------------------
        -: 4209:
        -: 4210:        XmlWriter& writeText( std::string const& text, bool indent = true );
        -: 4211:
        -: 4212:        XmlWriter& writeComment( std::string const& text );
        -: 4213:
        -: 4214:        void writeStylesheetRef( std::string const& url );
        -: 4215:
        -: 4216:        XmlWriter& writeBlankLine();
        -: 4217:
        -: 4218:        void ensureTagClosed();
        -: 4219:
        -: 4220:    private:
        -: 4221:
        -: 4222:        void writeDeclaration();
        -: 4223:
        -: 4224:        void newlineIfNecessary();
        -: 4225:
        -: 4226:        bool m_tagIsOpen = false;
        -: 4227:        bool m_needsNewline = false;
        -: 4228:        std::vector<std::string> m_tags;
        -: 4229:        std::string m_indent;
        -: 4230:        std::ostream& m_os;
        -: 4231:    };
        -: 4232:
        -: 4233:}
        -: 4234:
        -: 4235:// end catch_xmlwriter.h
        -: 4236:namespace Catch {
        -: 4237:
        -: 4238:    class JunitReporter : public CumulativeReporterBase<JunitReporter> {
        -: 4239:    public:
        -: 4240:        JunitReporter(ReporterConfig const& _config);
        -: 4241:
        -: 4242:        ~JunitReporter() override;
        -: 4243:
        -: 4244:        static std::string getDescription();
        -: 4245:
        -: 4246:        void noMatchingTestCases(std::string const& /*spec*/) override;
        -: 4247:
        -: 4248:        void testRunStarting(TestRunInfo const& runInfo) override;
        -: 4249:
        -: 4250:        void testGroupStarting(GroupInfo const& groupInfo) override;
        -: 4251:
        -: 4252:        void testCaseStarting(TestCaseInfo const& testCaseInfo) override;
        -: 4253:        bool assertionEnded(AssertionStats const& assertionStats) override;
        -: 4254:
        -: 4255:        void testCaseEnded(TestCaseStats const& testCaseStats) override;
        -: 4256:
        -: 4257:        void testGroupEnded(TestGroupStats const& testGroupStats) override;
        -: 4258:
        -: 4259:        void testRunEndedCumulative() override;
        -: 4260:
        -: 4261:        void writeGroup(TestGroupNode const& groupNode, double suiteTime);
        -: 4262:
        -: 4263:        void writeTestCase(TestCaseNode const& testCaseNode);
        -: 4264:
        -: 4265:        void writeSection(std::string const& className,
        -: 4266:                          std::string const& rootName,
        -: 4267:                          SectionNode const& sectionNode);
        -: 4268:
        -: 4269:        void writeAssertions(SectionNode const& sectionNode);
        -: 4270:        void writeAssertion(AssertionStats const& stats);
        -: 4271:
        -: 4272:        XmlWriter xml;
        -: 4273:        Timer suiteTimer;
        -: 4274:        std::string stdOutForSuite;
        -: 4275:        std::string stdErrForSuite;
        -: 4276:        unsigned int unexpectedExceptions = 0;
        -: 4277:        bool m_okToFail = false;
        -: 4278:    };
        -: 4279:
        -: 4280:} // end namespace Catch
        -: 4281:
        -: 4282:// end catch_reporter_junit.h
        -: 4283:// start catch_reporter_xml.h
        -: 4284:
        -: 4285:namespace Catch {
        -: 4286:    class XmlReporter : public StreamingReporterBase<XmlReporter> {
        -: 4287:    public:
        -: 4288:        XmlReporter(ReporterConfig const& _config);
        -: 4289:
        -: 4290:        ~XmlReporter() override;
        -: 4291:
        -: 4292:        static std::string getDescription();
        -: 4293:
        -: 4294:        virtual std::string getStylesheetRef() const;
        -: 4295:
        -: 4296:        void writeSourceInfo(SourceLineInfo const& sourceInfo);
        -: 4297:
        -: 4298:    public: // StreamingReporterBase
        -: 4299:
        -: 4300:        void noMatchingTestCases(std::string const& s) override;
        -: 4301:
        -: 4302:        void testRunStarting(TestRunInfo const& testInfo) override;
        -: 4303:
        -: 4304:        void testGroupStarting(GroupInfo const& groupInfo) override;
        -: 4305:
        -: 4306:        void testCaseStarting(TestCaseInfo const& testInfo) override;
        -: 4307:
        -: 4308:        void sectionStarting(SectionInfo const& sectionInfo) override;
        -: 4309:
        -: 4310:        void assertionStarting(AssertionInfo const&) override;
        -: 4311:
        -: 4312:        bool assertionEnded(AssertionStats const& assertionStats) override;
        -: 4313:
        -: 4314:        void sectionEnded(SectionStats const& sectionStats) override;
        -: 4315:
        -: 4316:        void testCaseEnded(TestCaseStats const& testCaseStats) override;
        -: 4317:
        -: 4318:        void testGroupEnded(TestGroupStats const& testGroupStats) override;
        -: 4319:
        -: 4320:        void testRunEnded(TestRunStats const& testRunStats) override;
        -: 4321:
        -: 4322:    private:
        -: 4323:        Timer m_testCaseTimer;
        -: 4324:        XmlWriter m_xml;
        -: 4325:        int m_sectionDepth = 0;
        -: 4326:    };
        -: 4327:
        -: 4328:} // end namespace Catch
        -: 4329:
        -: 4330:// end catch_reporter_xml.h
        -: 4331:
        -: 4332:// end catch_external_interfaces.h
        -: 4333:#endif
        -: 4334:
        -: 4335:#endif // ! CATCH_CONFIG_IMPL_ONLY
        -: 4336:
        -: 4337:#ifdef CATCH_IMPL
        -: 4338:// start catch_impl.hpp
        -: 4339:
        -: 4340:#ifdef __clang__
        -: 4341:#pragma clang diagnostic push
        -: 4342:#pragma clang diagnostic ignored "-Wweak-vtables"
        -: 4343:#endif
        -: 4344:
        -: 4345:// Keep these here for external reporters
        -: 4346:// start catch_test_case_tracker.h
        -: 4347:
        -: 4348:#include <string>
        -: 4349:#include <vector>
        -: 4350:#include <memory>
        -: 4351:
        -: 4352:namespace Catch {
        -: 4353:namespace TestCaseTracking {
        -: 4354:
        -: 4355:    struct NameAndLocation {
        -: 4356:        std::string name;
        -: 4357:        SourceLineInfo location;
        -: 4358:
        -: 4359:        NameAndLocation( std::string const& _name, SourceLineInfo const& _location );
        -: 4360:    };
        -: 4361:
        -: 4362:    struct ITracker;
        -: 4363:
        -: 4364:    using ITrackerPtr = std::shared_ptr<ITracker>;
        -: 4365:
        -: 4366:    struct ITracker {
        -: 4367:        virtual ~ITracker();
        -: 4368:
        -: 4369:        // static queries
        -: 4370:        virtual NameAndLocation const& nameAndLocation() const = 0;
        -: 4371:
        -: 4372:        // dynamic queries
        -: 4373:        virtual bool isComplete() const = 0; // Successfully completed or failed
        -: 4374:        virtual bool isSuccessfullyCompleted() const = 0;
        -: 4375:        virtual bool isOpen() const = 0; // Started but not complete
        -: 4376:        virtual bool hasChildren() const = 0;
        -: 4377:
        -: 4378:        virtual ITracker& parent() = 0;
        -: 4379:
        -: 4380:        // actions
        -: 4381:        virtual void close() = 0; // Successfully complete
        -: 4382:        virtual void fail() = 0;
        -: 4383:        virtual void markAsNeedingAnotherRun() = 0;
        -: 4384:
        -: 4385:        virtual void addChild( ITrackerPtr const& child ) = 0;
        -: 4386:        virtual ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) = 0;
        -: 4387:        virtual void openChild() = 0;
        -: 4388:
        -: 4389:        // Debug/ checking
        -: 4390:        virtual bool isSectionTracker() const = 0;
        -: 4391:        virtual bool isIndexTracker() const = 0;
        -: 4392:    };
        -: 4393:
        -: 4394:    class TrackerContext {
        -: 4395:
        -: 4396:        enum RunState {
        -: 4397:            NotStarted,
        -: 4398:            Executing,
        -: 4399:            CompletedCycle
        -: 4400:        };
        -: 4401:
        -: 4402:        ITrackerPtr m_rootTracker;
        -: 4403:        ITracker* m_currentTracker = nullptr;
        -: 4404:        RunState m_runState = NotStarted;
        -: 4405:
        -: 4406:    public:
        -: 4407:
        -: 4408:        static TrackerContext& instance();
        -: 4409:
        -: 4410:        ITracker& startRun();
        -: 4411:        void endRun();
        -: 4412:
        -: 4413:        void startCycle();
        -: 4414:        void completeCycle();
        -: 4415:
        -: 4416:        bool completedCycle() const;
        -: 4417:        ITracker& currentTracker();
        -: 4418:        void setCurrentTracker( ITracker* tracker );
        -: 4419:    };
        -: 4420:
        -: 4421:    class TrackerBase : public ITracker {
        -: 4422:    protected:
        -: 4423:        enum CycleState {
        -: 4424:            NotStarted,
        -: 4425:            Executing,
        -: 4426:            ExecutingChildren,
        -: 4427:            NeedsAnotherRun,
        -: 4428:            CompletedSuccessfully,
        -: 4429:            Failed
        -: 4430:        };
        -: 4431:
        -: 4432:        class TrackerHasName {
        -: 4433:            NameAndLocation m_nameAndLocation;
        -: 4434:        public:
        -: 4435:            TrackerHasName( NameAndLocation const& nameAndLocation );
        -: 4436:            bool operator ()( ITrackerPtr const& tracker ) const;
        -: 4437:        };
        -: 4438:
        -: 4439:        using Children = std::vector<ITrackerPtr>;
        -: 4440:        NameAndLocation m_nameAndLocation;
        -: 4441:        TrackerContext& m_ctx;
        -: 4442:        ITracker* m_parent;
        -: 4443:        Children m_children;
        -: 4444:        CycleState m_runState = NotStarted;
        -: 4445:
        -: 4446:    public:
        -: 4447:        TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );
        -: 4448:
        -: 4449:        NameAndLocation const& nameAndLocation() const override;
        -: 4450:        bool isComplete() const override;
        -: 4451:        bool isSuccessfullyCompleted() const override;
        -: 4452:        bool isOpen() const override;
        -: 4453:        bool hasChildren() const override;
        -: 4454:
        -: 4455:        void addChild( ITrackerPtr const& child ) override;
        -: 4456:
        -: 4457:        ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) override;
        -: 4458:        ITracker& parent() override;
        -: 4459:
        -: 4460:        void openChild() override;
        -: 4461:
        -: 4462:        bool isSectionTracker() const override;
        -: 4463:        bool isIndexTracker() const override;
        -: 4464:
        -: 4465:        void open();
        -: 4466:
        -: 4467:        void close() override;
        -: 4468:        void fail() override;
        -: 4469:        void markAsNeedingAnotherRun() override;
        -: 4470:
        -: 4471:    private:
        -: 4472:        void moveToParent();
        -: 4473:        void moveToThis();
        -: 4474:    };
        -: 4475:
        -: 4476:    class SectionTracker : public TrackerBase {
        -: 4477:        std::vector<std::string> m_filters;
        -: 4478:    public:
        -: 4479:        SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );
        -: 4480:
        -: 4481:        bool isSectionTracker() const override;
        -: 4482:
        -: 4483:        static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation );
        -: 4484:
        -: 4485:        void tryOpen();
        -: 4486:
        -: 4487:        void addInitialFilters( std::vector<std::string> const& filters );
        -: 4488:        void addNextFilters( std::vector<std::string> const& filters );
        -: 4489:    };
        -: 4490:
        -: 4491:    class IndexTracker : public TrackerBase {
        -: 4492:        int m_size;
        -: 4493:        int m_index = -1;
        -: 4494:    public:
        -: 4495:        IndexTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent, int size );
        -: 4496:
        -: 4497:        bool isIndexTracker() const override;
        -: 4498:        void close() override;
        -: 4499:
        -: 4500:        static IndexTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation, int size );
        -: 4501:
        -: 4502:        int index() const;
        -: 4503:
        -: 4504:        void moveNext();
        -: 4505:    };
        -: 4506:
        -: 4507:} // namespace TestCaseTracking
        -: 4508:
        -: 4509:using TestCaseTracking::ITracker;
        -: 4510:using TestCaseTracking::TrackerContext;
        -: 4511:using TestCaseTracking::SectionTracker;
        -: 4512:using TestCaseTracking::IndexTracker;
        -: 4513:
        -: 4514:} // namespace Catch
        -: 4515:
        -: 4516:// end catch_test_case_tracker.h
        -: 4517:
        -: 4518:// start catch_leak_detector.h
        -: 4519:
        -: 4520:namespace Catch {
        -: 4521:
        -: 4522:    struct LeakDetector {
        -: 4523:        LeakDetector();
        -: 4524:    };
        -: 4525:
        -: 4526:}
        -: 4527:// end catch_leak_detector.h
        -: 4528:// Cpp files will be included in the single-header file here
        -: 4529:// start catch_approx.cpp
        -: 4530:
        -: 4531:#include <cmath>
        -: 4532:#include <limits>
        -: 4533:
        -: 4534:namespace {
        -: 4535:
        -: 4536:// Performs equivalent check of std::fabs(lhs - rhs) <= margin
        -: 4537:// But without the subtraction to allow for INFINITY in comparison
    #####: 4538:bool marginComparison(double lhs, double rhs, double margin) {
    #####: 4539:    return (lhs + margin >= rhs) && (rhs + margin >= lhs);
        -: 4540:}
        -: 4541:
        -: 4542:}
        -: 4543:
        -: 4544:namespace Catch {
        -: 4545:namespace Detail {
        -: 4546:
    #####: 4547:    Approx::Approx ( double value )
    #####: 4548:    :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),
    #####: 4549:        m_margin( 0.0 ),
    #####: 4550:        m_scale( 0.0 ),
    #####: 4551:        m_value( value )
    #####: 4552:    {}
        -: 4553:
    #####: 4554:    Approx Approx::custom() {
    #####: 4555:        return Approx( 0 );
        -: 4556:    }
        -: 4557:
    #####: 4558:    std::string Approx::toString() const {
    #####: 4559:        ReusableStringStream rss;
    #####: 4560:        rss << "Approx( " << ::Catch::Detail::stringify( m_value ) << " )";
    #####: 4561:        return rss.str();
    #####: 4562:    }
        -: 4563:
    #####: 4564:    bool Approx::equalityComparisonImpl(const double other) const {
        -: 4565:        // First try with fixed margin, then compute margin based on epsilon, scale and Approx's value
        -: 4566:        // Thanks to Richard Harris for his help refining the scaled margin value
    #####: 4567:        return marginComparison(m_value, other, m_margin) || marginComparison(m_value, other, m_epsilon * (m_scale + std::fabs(m_value)));
        -: 4568:    }
        -: 4569:
        -: 4570:} // end namespace Detail
        -: 4571:
    #####: 4572:std::string StringMaker<Catch::Detail::Approx>::convert(Catch::Detail::Approx const& value) {
    #####: 4573:    return value.toString();
        -: 4574:}
        -: 4575:
        -: 4576:} // end namespace Catch
        -: 4577:// end catch_approx.cpp
        -: 4578:// start catch_assertionhandler.cpp
        -: 4579:
        -: 4580:// start catch_context.h
        -: 4581:
        -: 4582:#include <memory>
        -: 4583:
        -: 4584:namespace Catch {
        -: 4585:
        -: 4586:    struct IResultCapture;
        -: 4587:    struct IRunner;
        -: 4588:    struct IConfig;
        -: 4589:    struct IMutableContext;
        -: 4590:
        -: 4591:    using IConfigPtr = std::shared_ptr<IConfig const>;
        -: 4592:
        -: 4593:    struct IContext
        -: 4594:    {
        -: 4595:        virtual ~IContext();
        -: 4596:
        -: 4597:        virtual IResultCapture* getResultCapture() = 0;
        -: 4598:        virtual IRunner* getRunner() = 0;
        -: 4599:        virtual IConfigPtr const& getConfig() const = 0;
        -: 4600:    };
        -: 4601:
        -: 4602:    struct IMutableContext : IContext
        -: 4603:    {
        -: 4604:        virtual ~IMutableContext();
        -: 4605:        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;
        -: 4606:        virtual void setRunner( IRunner* runner ) = 0;
        -: 4607:        virtual void setConfig( IConfigPtr const& config ) = 0;
        -: 4608:
        -: 4609:    private:
        -: 4610:        static IMutableContext *currentContext;
        -: 4611:        friend IMutableContext& getCurrentMutableContext();
        -: 4612:        friend void cleanUpContext();
        -: 4613:        static void createContext();
        -: 4614:    };
        -: 4615:
       85: 4616:    inline IMutableContext& getCurrentMutableContext()
        -: 4617:    {
       85: 4618:        if( !IMutableContext::currentContext )
        1: 4619:            IMutableContext::createContext();
       85: 4620:        return *IMutableContext::currentContext;
        -: 4621:    }
        -: 4622:
       84: 4623:    inline IContext& getCurrentContext()
        -: 4624:    {
       84: 4625:        return getCurrentMutableContext();
        -: 4626:    }
        -: 4627:
        -: 4628:    void cleanUpContext();
        -: 4629:}
        -: 4630:
        -: 4631:// end catch_context.h
        -: 4632:// start catch_debugger.h
        -: 4633:
        -: 4634:namespace Catch {
        -: 4635:    bool isDebuggerActive();
        -: 4636:}
        -: 4637:
        -: 4638:#ifdef CATCH_PLATFORM_MAC
        -: 4639:
        -: 4640:    #define CATCH_TRAP() __asm__("int $3\n" : : ) /* NOLINT */
        -: 4641:
        -: 4642:#elif defined(CATCH_PLATFORM_LINUX)
        -: 4643:    // If we can use inline assembler, do it because this allows us to break
        -: 4644:    // directly at the location of the failing check instead of breaking inside
        -: 4645:    // raise() called from it, i.e. one stack frame below.
        -: 4646:    #if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))
        -: 4647:        #define CATCH_TRAP() asm volatile ("int $3") /* NOLINT */
        -: 4648:    #else // Fall back to the generic way.
        -: 4649:        #include <signal.h>
        -: 4650:
        -: 4651:        #define CATCH_TRAP() raise(SIGTRAP)
        -: 4652:    #endif
        -: 4653:#elif defined(_MSC_VER)
        -: 4654:    #define CATCH_TRAP() __debugbreak()
        -: 4655:#elif defined(__MINGW32__)
        -: 4656:    extern "C" __declspec(dllimport) void __stdcall DebugBreak();
        -: 4657:    #define CATCH_TRAP() DebugBreak()
        -: 4658:#endif
        -: 4659:
        -: 4660:#ifdef CATCH_TRAP
        -: 4661:    #define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) { CATCH_TRAP(); }
        -: 4662:#else
        -: 4663:    namespace Catch {
        -: 4664:        inline void doNothing() {}
        -: 4665:    }
        -: 4666:    #define CATCH_BREAK_INTO_DEBUGGER() Catch::doNothing()
        -: 4667:#endif
        -: 4668:
        -: 4669:// end catch_debugger.h
        -: 4670:// start catch_run_context.h
        -: 4671:
        -: 4672:// start catch_fatal_condition.h
        -: 4673:
        -: 4674:// start catch_windows_h_proxy.h
        -: 4675:
        -: 4676:
        -: 4677:#if defined(CATCH_PLATFORM_WINDOWS)
        -: 4678:
        -: 4679:#if !defined(NOMINMAX) && !defined(CATCH_CONFIG_NO_NOMINMAX)
        -: 4680:#  define CATCH_DEFINED_NOMINMAX
        -: 4681:#  define NOMINMAX
        -: 4682:#endif
        -: 4683:#if !defined(WIN32_LEAN_AND_MEAN) && !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)
        -: 4684:#  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN
        -: 4685:#  define WIN32_LEAN_AND_MEAN
        -: 4686:#endif
        -: 4687:
        -: 4688:#ifdef __AFXDLL
        -: 4689:#include <AfxWin.h>
        -: 4690:#else
        -: 4691:#include <windows.h>
        -: 4692:#endif
        -: 4693:
        -: 4694:#ifdef CATCH_DEFINED_NOMINMAX
        -: 4695:#  undef NOMINMAX
        -: 4696:#endif
        -: 4697:#ifdef CATCH_DEFINED_WIN32_LEAN_AND_MEAN
        -: 4698:#  undef WIN32_LEAN_AND_MEAN
        -: 4699:#endif
        -: 4700:
        -: 4701:#endif // defined(CATCH_PLATFORM_WINDOWS)
        -: 4702:
        -: 4703:// end catch_windows_h_proxy.h
        -: 4704:#if defined( CATCH_CONFIG_WINDOWS_SEH )
        -: 4705:
        -: 4706:namespace Catch {
        -: 4707:
        -: 4708:    struct FatalConditionHandler {
        -: 4709:
        -: 4710:        static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo);
        -: 4711:        FatalConditionHandler();
        -: 4712:        static void reset();
        -: 4713:        ~FatalConditionHandler();
        -: 4714:
        -: 4715:    private:
        -: 4716:        static bool isSet;
        -: 4717:        static ULONG guaranteeSize;
        -: 4718:        static PVOID exceptionHandlerHandle;
        -: 4719:    };
        -: 4720:
        -: 4721:} // namespace Catch
        -: 4722:
        -: 4723:#elif defined ( CATCH_CONFIG_POSIX_SIGNALS )
        -: 4724:
        -: 4725:#include <signal.h>
        -: 4726:
        -: 4727:namespace Catch {
        -: 4728:
        -: 4729:    struct FatalConditionHandler {
        -: 4730:
        -: 4731:        static bool isSet;
        -: 4732:        static struct sigaction oldSigActions[];
        -: 4733:        static stack_t oldSigStack;
        -: 4734:        static char altStackMem[];
        -: 4735:
        -: 4736:        static void handleSignal( int sig );
        -: 4737:
        -: 4738:        FatalConditionHandler();
        -: 4739:        ~FatalConditionHandler();
        -: 4740:        static void reset();
        -: 4741:    };
        -: 4742:
        -: 4743:} // namespace Catch
        -: 4744:
        -: 4745:#else
        -: 4746:
        -: 4747:namespace Catch {
        -: 4748:    struct FatalConditionHandler {
        -: 4749:        void reset();
        -: 4750:    };
        -: 4751:}
        -: 4752:
        -: 4753:#endif
        -: 4754:
        -: 4755:// end catch_fatal_condition.h
        -: 4756:#include <string>
        -: 4757:
        -: 4758:namespace Catch {
        -: 4759:
        -: 4760:    struct IMutableContext;
        -: 4761:
        -: 4762:    ///////////////////////////////////////////////////////////////////////////
        -: 4763:
        -: 4764:    class RunContext : public IResultCapture, public IRunner {
        -: 4765:
        -: 4766:    public:
        -: 4767:        RunContext( RunContext const& ) = delete;
        -: 4768:        RunContext& operator =( RunContext const& ) = delete;
        -: 4769:
        -: 4770:        explicit RunContext( IConfigPtr const& _config, IStreamingReporterPtr&& reporter );
        -: 4771:
        -: 4772:        ~RunContext() override;
        -: 4773:
        -: 4774:        void testGroupStarting( std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount );
        -: 4775:        void testGroupEnded( std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount );
        -: 4776:
        -: 4777:        Totals runTest(TestCase const& testCase);
        -: 4778:
        -: 4779:        IConfigPtr config() const;
        -: 4780:        IStreamingReporter& reporter() const;
        -: 4781:
        -: 4782:    public: // IResultCapture
        -: 4783:
        -: 4784:        // Assertion handlers
        -: 4785:        void handleExpr
        -: 4786:                (   AssertionInfo const& info,
        -: 4787:                    ITransientExpression const& expr,
        -: 4788:                    AssertionReaction& reaction ) override;
        -: 4789:        void handleMessage
        -: 4790:                (   AssertionInfo const& info,
        -: 4791:                    ResultWas::OfType resultType,
        -: 4792:                    StringRef const& message,
        -: 4793:                    AssertionReaction& reaction ) override;
        -: 4794:        void handleUnexpectedExceptionNotThrown
        -: 4795:                (   AssertionInfo const& info,
        -: 4796:                    AssertionReaction& reaction ) override;
        -: 4797:        void handleUnexpectedInflightException
        -: 4798:                (   AssertionInfo const& info,
        -: 4799:                    std::string const& message,
        -: 4800:                    AssertionReaction& reaction ) override;
        -: 4801:        void handleIncomplete
        -: 4802:                (   AssertionInfo const& info ) override;
        -: 4803:        void handleNonExpr
        -: 4804:                (   AssertionInfo const &info,
        -: 4805:                    ResultWas::OfType resultType,
        -: 4806:                    AssertionReaction &reaction ) override;
        -: 4807:
        -: 4808:        bool sectionStarted( SectionInfo const& sectionInfo, Counts& assertions ) override;
        -: 4809:
        -: 4810:        void sectionEnded( SectionEndInfo const& endInfo ) override;
        -: 4811:        void sectionEndedEarly( SectionEndInfo const& endInfo ) override;
        -: 4812:
        -: 4813:        void benchmarkStarting( BenchmarkInfo const& info ) override;
        -: 4814:        void benchmarkEnded( BenchmarkStats const& stats ) override;
        -: 4815:
        -: 4816:        void pushScopedMessage( MessageInfo const& message ) override;
        -: 4817:        void popScopedMessage( MessageInfo const& message ) override;
        -: 4818:
        -: 4819:        std::string getCurrentTestName() const override;
        -: 4820:
        -: 4821:        const AssertionResult* getLastResult() const override;
        -: 4822:
        -: 4823:        void exceptionEarlyReported() override;
        -: 4824:
        -: 4825:        void handleFatalErrorCondition( StringRef message ) override;
        -: 4826:
        -: 4827:        bool lastAssertionPassed() override;
        -: 4828:
        -: 4829:        void assertionPassed() override;
        -: 4830:
        -: 4831:    public:
        -: 4832:        // !TBD We need to do this another way!
        -: 4833:        bool aborting() const override;
        -: 4834:
        -: 4835:    private:
        -: 4836:
        -: 4837:        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr );
        -: 4838:        void invokeActiveTestCase();
        -: 4839:
        -: 4840:        void resetAssertionInfo();
        -: 4841:        bool testForMissingAssertions( Counts& assertions );
        -: 4842:
        -: 4843:        void assertionEnded( AssertionResult const& result );
        -: 4844:        void reportExpr
        -: 4845:                (   AssertionInfo const &info,
        -: 4846:                    ResultWas::OfType resultType,
        -: 4847:                    ITransientExpression const *expr,
        -: 4848:                    bool negated );
        -: 4849:
        -: 4850:        void populateReaction( AssertionReaction& reaction );
        -: 4851:
        -: 4852:    private:
        -: 4853:
        -: 4854:        void handleUnfinishedSections();
        -: 4855:
        -: 4856:        TestRunInfo m_runInfo;
        -: 4857:        IMutableContext& m_context;
        -: 4858:        TestCase const* m_activeTestCase = nullptr;
        -: 4859:        ITracker* m_testCaseTracker;
        -: 4860:        Option<AssertionResult> m_lastResult;
        -: 4861:
        -: 4862:        IConfigPtr m_config;
        -: 4863:        Totals m_totals;
        -: 4864:        IStreamingReporterPtr m_reporter;
        -: 4865:        std::vector<MessageInfo> m_messages;
        -: 4866:        AssertionInfo m_lastAssertionInfo;
        -: 4867:        std::vector<SectionEndInfo> m_unfinishedSections;
        -: 4868:        std::vector<ITracker*> m_activeSections;
        -: 4869:        TrackerContext m_trackerContext;
        -: 4870:        bool m_lastAssertionPassed = false;
        -: 4871:        bool m_shouldReportUnexpected = true;
        -: 4872:        bool m_includeSuccessfulResults;
        -: 4873:    };
        -: 4874:
        -: 4875:} // end namespace Catch
        -: 4876:
        -: 4877:// end catch_run_context.h
        -: 4878:namespace Catch {
        -: 4879:
    #####: 4880:    auto operator <<( std::ostream& os, ITransientExpression const& expr ) -> std::ostream& {
    #####: 4881:        expr.streamReconstructedExpression( os );
    #####: 4882:        return os;
        -: 4883:    }
        -: 4884:
    #####: 4885:    LazyExpression::LazyExpression( bool isNegated )
    #####: 4886:    :   m_isNegated( isNegated )
    #####: 4887:    {}
        -: 4888:
    #####: 4889:    LazyExpression::LazyExpression( LazyExpression const& other ) : m_isNegated( other.m_isNegated ) {}
        -: 4890:
    #####: 4891:    LazyExpression::operator bool() const {
    #####: 4892:        return m_transientExpression != nullptr;
        -: 4893:    }
        -: 4894:
    #####: 4895:    auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream& {
    #####: 4896:        if( lazyExpr.m_isNegated )
    #####: 4897:            os << "!";
        -: 4898:
    #####: 4899:        if( lazyExpr ) {
    #####: 4900:            if( lazyExpr.m_isNegated && lazyExpr.m_transientExpression->isBinaryExpression() )
    #####: 4901:                os << "(" << *lazyExpr.m_transientExpression << ")";
        -: 4902:            else
    #####: 4903:                os << *lazyExpr.m_transientExpression;
        -: 4904:        }
        -: 4905:        else {
    #####: 4906:            os << "{** error - unchecked empty expression requested **}";
        -: 4907:        }
    #####: 4908:        return os;
        -: 4909:    }
        -: 4910:
       41: 4911:    AssertionHandler::AssertionHandler
        -: 4912:        (   StringRef macroName,
        -: 4913:            SourceLineInfo const& lineInfo,
        -: 4914:            StringRef capturedExpression,
       41: 4915:            ResultDisposition::Flags resultDisposition )
       41: 4916:    :   m_assertionInfo{ macroName, lineInfo, capturedExpression, resultDisposition },
       41: 4917:        m_resultCapture( getResultCapture() )
       41: 4918:    {}
        -: 4919:
       41: 4920:    void AssertionHandler::handleExpr( ITransientExpression const& expr ) {
       41: 4921:        m_resultCapture.handleExpr( m_assertionInfo, expr, m_reaction );
       41: 4922:    }
    #####: 4923:    void AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef const& message) {
    #####: 4924:        m_resultCapture.handleMessage( m_assertionInfo, resultType, message, m_reaction );
    #####: 4925:    }
        -: 4926:
    #####: 4927:    auto AssertionHandler::allowThrows() const -> bool {
    #####: 4928:        return getCurrentContext().getConfig()->allowThrows();
        -: 4929:    }
        -: 4930:
       41: 4931:    void AssertionHandler::complete() {
       41: 4932:        setCompleted();
       41: 4933:        if( m_reaction.shouldDebugBreak ) {
        -: 4934:
        -: 4935:            // If you find your debugger stopping you here then go one level up on the
        -: 4936:            // call-stack for the code that caused it (typically a failed assertion)
        -: 4937:
        -: 4938:            // (To go back to the test and change execution, jump over the throw, next)
    #####: 4939:            CATCH_BREAK_INTO_DEBUGGER();
        -: 4940:        }
       41: 4941:        if( m_reaction.shouldThrow )
    #####: 4942:            throw Catch::TestFailureException();
       41: 4943:    }
       41: 4944:    void AssertionHandler::setCompleted() {
       41: 4945:        m_completed = true;
       41: 4946:    }
        -: 4947:
    #####: 4948:    void AssertionHandler::handleUnexpectedInflightException() {
    #####: 4949:        m_resultCapture.handleUnexpectedInflightException( m_assertionInfo, Catch::translateActiveException(), m_reaction );
    #####: 4950:    }
        -: 4951:
    #####: 4952:    void AssertionHandler::handleExceptionThrownAsExpected() {
    #####: 4953:        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
    #####: 4954:    }
    #####: 4955:    void AssertionHandler::handleExceptionNotThrownAsExpected() {
    #####: 4956:        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
    #####: 4957:    }
        -: 4958:
    #####: 4959:    void AssertionHandler::handleUnexpectedExceptionNotThrown() {
    #####: 4960:        m_resultCapture.handleUnexpectedExceptionNotThrown( m_assertionInfo, m_reaction );
    #####: 4961:    }
        -: 4962:
    #####: 4963:    void AssertionHandler::handleThrowingCallSkipped() {
    #####: 4964:        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
    #####: 4965:    }
        -: 4966:
        -: 4967:    // This is the overload that takes a string and infers the Equals matcher from it
        -: 4968:    // The more general overload, that takes any string matcher, is in catch_capture_matchers.cpp
    #####: 4969:    void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef matcherString  ) {
    #####: 4970:        handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );
    #####: 4971:    }
        -: 4972:
        -: 4973:} // namespace Catch
        -: 4974:// end catch_assertionhandler.cpp
        -: 4975:// start catch_assertionresult.cpp
        -: 4976:
        -: 4977:namespace Catch {
    #####: 4978:    AssertionResultData::AssertionResultData(ResultWas::OfType _resultType, LazyExpression const & _lazyExpression):
    #####: 4979:        lazyExpression(_lazyExpression),
    #####: 4980:        resultType(_resultType) {}
        -: 4981:
    #####: 4982:    std::string AssertionResultData::reconstructExpression() const {
        -: 4983:
    #####: 4984:        if( reconstructedExpression.empty() ) {
    #####: 4985:            if( lazyExpression ) {
    #####: 4986:                ReusableStringStream rss;
    #####: 4987:                rss << lazyExpression;
    #####: 4988:                reconstructedExpression = rss.str();
    #####: 4989:            }
        -: 4990:        }
    #####: 4991:        return reconstructedExpression;
        -: 4992:    }
        -: 4993:
    #####: 4994:    AssertionResult::AssertionResult( AssertionInfo const& info, AssertionResultData const& data )
    #####: 4995:    :   m_info( info ),
    #####: 4996:        m_resultData( data )
    #####: 4997:    {}
        -: 4998:
        -: 4999:    // Result was a success
    #####: 5000:    bool AssertionResult::succeeded() const {
    #####: 5001:        return Catch::isOk( m_resultData.resultType );
        -: 5002:    }
        -: 5003:
        -: 5004:    // Result was a success, or failure is suppressed
    #####: 5005:    bool AssertionResult::isOk() const {
    #####: 5006:        return Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );
        -: 5007:    }
        -: 5008:
    #####: 5009:    ResultWas::OfType AssertionResult::getResultType() const {
    #####: 5010:        return m_resultData.resultType;
        -: 5011:    }
        -: 5012:
    #####: 5013:    bool AssertionResult::hasExpression() const {
    #####: 5014:        return m_info.capturedExpression[0] != 0;
        -: 5015:    }
        -: 5016:
    #####: 5017:    bool AssertionResult::hasMessage() const {
    #####: 5018:        return !m_resultData.message.empty();
        -: 5019:    }
        -: 5020:
    #####: 5021:    std::string AssertionResult::getExpression() const {
    #####: 5022:        if( isFalseTest( m_info.resultDisposition ) )
    #####: 5023:            return "!(" + m_info.capturedExpression + ")";
        -: 5024:        else
    #####: 5025:            return m_info.capturedExpression;
        -: 5026:    }
        -: 5027:
    #####: 5028:    std::string AssertionResult::getExpressionInMacro() const {
    #####: 5029:        std::string expr;
    #####: 5030:        if( m_info.macroName[0] == 0 )
    #####: 5031:            expr = m_info.capturedExpression;
        -: 5032:        else {
    #####: 5033:            expr.reserve( m_info.macroName.size() + m_info.capturedExpression.size() + 4 );
    #####: 5034:            expr += m_info.macroName;
    #####: 5035:            expr += "( ";
    #####: 5036:            expr += m_info.capturedExpression;
    #####: 5037:            expr += " )";
        -: 5038:        }
    #####: 5039:        return expr;
    =====: 5040:    }
        -: 5041:
    #####: 5042:    bool AssertionResult::hasExpandedExpression() const {
    #####: 5043:        return hasExpression() && getExpandedExpression() != getExpression();
        -: 5044:    }
        -: 5045:
    #####: 5046:    std::string AssertionResult::getExpandedExpression() const {
    #####: 5047:        std::string expr = m_resultData.reconstructExpression();
    #####: 5048:        return expr.empty()
        -: 5049:                ? getExpression()
    #####: 5050:                : expr;
    #####: 5051:    }
        -: 5052:
    #####: 5053:    std::string AssertionResult::getMessage() const {
    #####: 5054:        return m_resultData.message;
        -: 5055:    }
    #####: 5056:    SourceLineInfo AssertionResult::getSourceInfo() const {
    #####: 5057:        return m_info.lineInfo;
        -: 5058:    }
        -: 5059:
    #####: 5060:    StringRef AssertionResult::getTestMacroName() const {
    #####: 5061:        return m_info.macroName;
        -: 5062:    }
        -: 5063:
        -: 5064:} // end namespace Catch
        -: 5065:// end catch_assertionresult.cpp
        -: 5066:// start catch_benchmark.cpp
        -: 5067:
        -: 5068:namespace Catch {
        -: 5069:
    #####: 5070:    auto BenchmarkLooper::getResolution() -> uint64_t {
    #####: 5071:        return getEstimatedClockResolution() * getCurrentContext().getConfig()->benchmarkResolutionMultiple();
        -: 5072:    }
        -: 5073:
    #####: 5074:    void BenchmarkLooper::reportStart() {
    #####: 5075:        getResultCapture().benchmarkStarting( { m_name } );
    #####: 5076:    }
    #####: 5077:    auto BenchmarkLooper::needsMoreIterations() -> bool {
    #####: 5078:        auto elapsed = m_timer.getElapsedNanoseconds();
        -: 5079:
        -: 5080:        // Exponentially increasing iterations until we're confident in our timer resolution
    #####: 5081:        if( elapsed < m_resolution ) {
    #####: 5082:            m_iterationsToRun *= 10;
    #####: 5083:            return true;
        -: 5084:        }
        -: 5085:
    #####: 5086:        getResultCapture().benchmarkEnded( { { m_name }, m_count, elapsed } );
    #####: 5087:        return false;
        -: 5088:    }
        -: 5089:
        -: 5090:} // end namespace Catch
        -: 5091:// end catch_benchmark.cpp
        -: 5092:// start catch_capture_matchers.cpp
        -: 5093:
        -: 5094:namespace Catch {
        -: 5095:
        -: 5096:    using StringMatcher = Matchers::Impl::MatcherBase<std::string>;
        -: 5097:
        -: 5098:    // This is the general overload that takes a any string matcher
        -: 5099:    // There is another overload, in catch_assertionhandler.h/.cpp, that only takes a string and infers
        -: 5100:    // the Equals matcher (so the header does not mention matchers)
    #####: 5101:    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef matcherString  ) {
    #####: 5102:        std::string exceptionMessage = Catch::translateActiveException();
    #####: 5103:        MatchExpr<std::string, StringMatcher const&> expr( exceptionMessage, matcher, matcherString );
    #####: 5104:        handler.handleExpr( expr );
    #####: 5105:    }
        -: 5106:
        -: 5107:} // namespace Catch
        -: 5108:// end catch_capture_matchers.cpp
        -: 5109:// start catch_commandline.cpp
        -: 5110:
        -: 5111:// start catch_commandline.h
        -: 5112:
        -: 5113:// start catch_clara.h
        -: 5114:
        -: 5115:// Use Catch's value for console width (store Clara's off to the side, if present)
        -: 5116:#ifdef CLARA_CONFIG_CONSOLE_WIDTH
        -: 5117:#define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
        -: 5118:#undef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
        -: 5119:#endif
        -: 5120:#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH-1
        -: 5121:
        -: 5122:#ifdef __clang__
        -: 5123:#pragma clang diagnostic push
        -: 5124:#pragma clang diagnostic ignored "-Wweak-vtables"
        -: 5125:#pragma clang diagnostic ignored "-Wexit-time-destructors"
        -: 5126:#pragma clang diagnostic ignored "-Wshadow"
        -: 5127:#endif
        -: 5128:
        -: 5129:// start clara.hpp
        -: 5130:// Copyright 2017 Two Blue Cubes Ltd. All rights reserved.
        -: 5131://
        -: 5132:// Distributed under the Boost Software License, Version 1.0. (See accompanying
        -: 5133:// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -: 5134://
        -: 5135:// See https://github.com/philsquared/Clara for more details
        -: 5136:
        -: 5137:// Clara v1.1.4
        -: 5138:
        -: 5139:
        -: 5140:#ifndef CATCH_CLARA_CONFIG_CONSOLE_WIDTH
        -: 5141:#define CATCH_CLARA_CONFIG_CONSOLE_WIDTH 80
        -: 5142:#endif
        -: 5143:
        -: 5144:#ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
        -: 5145:#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CLARA_CONFIG_CONSOLE_WIDTH
        -: 5146:#endif
        -: 5147:
        -: 5148:#ifndef CLARA_CONFIG_OPTIONAL_TYPE
        -: 5149:#ifdef __has_include
        -: 5150:#if __has_include(<optional>) && __cplusplus >= 201703L
        -: 5151:#include <optional>
        -: 5152:#define CLARA_CONFIG_OPTIONAL_TYPE std::optional
        -: 5153:#endif
        -: 5154:#endif
        -: 5155:#endif
        -: 5156:
        -: 5157:// ----------- #included from clara_textflow.hpp -----------
        -: 5158:
        -: 5159:// TextFlowCpp
        -: 5160://
        -: 5161:// A single-header library for wrapping and laying out basic text, by Phil Nash
        -: 5162://
        -: 5163:// This work is licensed under the BSD 2-Clause license.
        -: 5164:// See the accompanying LICENSE file, or the one at https://opensource.org/licenses/BSD-2-Clause
        -: 5165://
        -: 5166:// This project is hosted at https://github.com/philsquared/textflowcpp
        -: 5167:
        -: 5168:
        -: 5169:#include <cassert>
        -: 5170:#include <ostream>
        -: 5171:#include <sstream>
        -: 5172:#include <vector>
        -: 5173:
        -: 5174:#ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
        -: 5175:#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH 80
        -: 5176:#endif
        -: 5177:
        -: 5178:namespace Catch { namespace clara { namespace TextFlow {
        -: 5179:
    #####: 5180:    inline auto isWhitespace( char c ) -> bool {
    #####: 5181:        static std::string chars = " \t\n\r";
    #####: 5182:        return chars.find( c ) != std::string::npos;
        -: 5183:    }
    #####: 5184:    inline auto isBreakableBefore( char c ) -> bool {
    #####: 5185:        static std::string chars = "[({<|";
    #####: 5186:        return chars.find( c ) != std::string::npos;
        -: 5187:    }
    #####: 5188:    inline auto isBreakableAfter( char c ) -> bool {
    #####: 5189:        static std::string chars = "])}>.,:;*+-=&/\\";
    #####: 5190:        return chars.find( c ) != std::string::npos;
        -: 5191:    }
        -: 5192:
        -: 5193:    class Columns;
        -: 5194:
        -: 5195:    class Column {
        -: 5196:        std::vector<std::string> m_strings;
        -: 5197:        size_t m_width = CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH;
        -: 5198:        size_t m_indent = 0;
        -: 5199:        size_t m_initialIndent = std::string::npos;
        -: 5200:
        -: 5201:    public:
        -: 5202:        class iterator {
        -: 5203:            friend Column;
        -: 5204:
        -: 5205:            Column const& m_column;
        -: 5206:            size_t m_stringIndex = 0;
        -: 5207:            size_t m_pos = 0;
        -: 5208:
        -: 5209:            size_t m_len = 0;
        -: 5210:            size_t m_end = 0;
        -: 5211:            bool m_suffix = false;
        -: 5212:
    #####: 5213:            iterator( Column const& column, size_t stringIndex )
    #####: 5214:            :   m_column( column ),
    #####: 5215:                m_stringIndex( stringIndex )
    #####: 5216:            {}
        -: 5217:
    #####: 5218:            auto line() const -> std::string const& { return m_column.m_strings[m_stringIndex]; }
        -: 5219:
    #####: 5220:            auto isBoundary( size_t at ) const -> bool {
    #####: 5221:                assert( at > 0 );
    #####: 5222:                assert( at <= line().size() );
        -: 5223:
    #####: 5224:                return at == line().size() ||
    #####: 5225:                       ( isWhitespace( line()[at] ) && !isWhitespace( line()[at-1] ) ) ||
    #####: 5226:                       isBreakableBefore( line()[at] ) ||
    #####: 5227:                       isBreakableAfter( line()[at-1] );
        -: 5228:            }
        -: 5229:
    #####: 5230:            void calcLength() {
    #####: 5231:                assert( m_stringIndex < m_column.m_strings.size() );
        -: 5232:
    #####: 5233:                m_suffix = false;
    #####: 5234:                auto width = m_column.m_width-indent();
    #####: 5235:                m_end = m_pos;
    #####: 5236:                while( m_end < line().size() && line()[m_end] != '\n' )
    #####: 5237:                    ++m_end;
        -: 5238:
    #####: 5239:                if( m_end < m_pos + width ) {
    #####: 5240:                    m_len = m_end - m_pos;
        -: 5241:                }
        -: 5242:                else {
    #####: 5243:                    size_t len = width;
    #####: 5244:                    while (len > 0 && !isBoundary(m_pos + len))
    #####: 5245:                        --len;
    #####: 5246:                    while (len > 0 && isWhitespace( line()[m_pos + len - 1] ))
    #####: 5247:                        --len;
        -: 5248:
    #####: 5249:                    if (len > 0) {
    #####: 5250:                        m_len = len;
        -: 5251:                    } else {
    #####: 5252:                        m_suffix = true;
    #####: 5253:                        m_len = width - 1;
        -: 5254:                    }
        -: 5255:                }
    #####: 5256:            }
        -: 5257:
    #####: 5258:            auto indent() const -> size_t {
    #####: 5259:                auto initial = m_pos == 0 && m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;
    #####: 5260:                return initial == std::string::npos ? m_column.m_indent : initial;
        -: 5261:            }
        -: 5262:
    #####: 5263:            auto addIndentAndSuffix(std::string const &plain) const -> std::string {
    #####: 5264:                return std::string( indent(), ' ' ) + (m_suffix ? plain + "-" : plain);
        -: 5265:            }
        -: 5266:
        -: 5267:        public:
    #####: 5268:            explicit iterator( Column const& column ) : m_column( column ) {
    #####: 5269:                assert( m_column.m_width > m_column.m_indent );
    #####: 5270:                assert( m_column.m_initialIndent == std::string::npos || m_column.m_width > m_column.m_initialIndent );
    #####: 5271:                calcLength();
    #####: 5272:                if( m_len == 0 )
    #####: 5273:                    m_stringIndex++; // Empty string
    #####: 5274:            }
        -: 5275:
    #####: 5276:            auto operator *() const -> std::string {
    #####: 5277:                assert( m_stringIndex < m_column.m_strings.size() );
    #####: 5278:                assert( m_pos <= m_end );
    #####: 5279:                if( m_pos + m_column.m_width < m_end )
    #####: 5280:                    return addIndentAndSuffix(line().substr(m_pos, m_len));
        -: 5281:                else
    #####: 5282:                    return addIndentAndSuffix(line().substr(m_pos, m_end - m_pos));
        -: 5283:            }
        -: 5284:
    #####: 5285:            auto operator ++() -> iterator& {
    #####: 5286:                m_pos += m_len;
    #####: 5287:                if( m_pos < line().size() && line()[m_pos] == '\n' )
    #####: 5288:                    m_pos += 1;
        -: 5289:                else
    #####: 5290:                    while( m_pos < line().size() && isWhitespace( line()[m_pos] ) )
    #####: 5291:                        ++m_pos;
        -: 5292:
    #####: 5293:                if( m_pos == line().size() ) {
    #####: 5294:                    m_pos = 0;
    #####: 5295:                    ++m_stringIndex;
        -: 5296:                }
    #####: 5297:                if( m_stringIndex < m_column.m_strings.size() )
    #####: 5298:                    calcLength();
    #####: 5299:                return *this;
        -: 5300:            }
        -: 5301:            auto operator ++(int) -> iterator {
        -: 5302:                iterator prev( *this );
        -: 5303:                operator++();
        -: 5304:                return prev;
        -: 5305:            }
        -: 5306:
    #####: 5307:            auto operator ==( iterator const& other ) const -> bool {
        -: 5308:                return
    #####: 5309:                    m_pos == other.m_pos &&
    #####: 5310:                    m_stringIndex == other.m_stringIndex &&
    #####: 5311:                    &m_column == &other.m_column;
        -: 5312:            }
    #####: 5313:            auto operator !=( iterator const& other ) const -> bool {
    #####: 5314:                return !operator==( other );
        -: 5315:            }
        -: 5316:        };
        -: 5317:        using const_iterator = iterator;
        -: 5318:
    #####: 5319:        explicit Column( std::string const& text ) { m_strings.push_back( text ); }
        -: 5320:
    #####: 5321:        auto width( size_t newWidth ) -> Column& {
    #####: 5322:            assert( newWidth > 0 );
    #####: 5323:            m_width = newWidth;
    #####: 5324:            return *this;
        -: 5325:        }
    #####: 5326:        auto indent( size_t newIndent ) -> Column& {
    #####: 5327:            m_indent = newIndent;
    #####: 5328:            return *this;
        -: 5329:        }
    #####: 5330:        auto initialIndent( size_t newIndent ) -> Column& {
    #####: 5331:            m_initialIndent = newIndent;
    #####: 5332:            return *this;
        -: 5333:        }
        -: 5334:
    #####: 5335:        auto width() const -> size_t { return m_width; }
    #####: 5336:        auto begin() const -> iterator { return iterator( *this ); }
    #####: 5337:        auto end() const -> iterator { return { *this, m_strings.size() }; }
        -: 5338:
    #####: 5339:        inline friend std::ostream& operator << ( std::ostream& os, Column const& col ) {
    #####: 5340:            bool first = true;
    #####: 5341:            for( auto line : col ) {
    #####: 5342:                if( first )
    #####: 5343:                    first = false;
        -: 5344:                else
    #####: 5345:                    os << "\n";
    #####: 5346:                os <<  line;
    #####: 5347:            }
    #####: 5348:            return os;
        -: 5349:        }
        -: 5350:
        -: 5351:        auto operator + ( Column const& other ) -> Columns;
        -: 5352:
        -: 5353:        auto toString() const -> std::string {
        -: 5354:            std::ostringstream oss;
        -: 5355:            oss << *this;
        -: 5356:            return oss.str();
        -: 5357:        }
        -: 5358:    };
        -: 5359:
        -: 5360:    class Spacer : public Column {
        -: 5361:
        -: 5362:    public:
    #####: 5363:        explicit Spacer( size_t spaceWidth ) : Column( "" ) {
    #####: 5364:            width( spaceWidth );
    #####: 5365:        }
        -: 5366:    };
        -: 5367:
        -: 5368:    class Columns {
        -: 5369:        std::vector<Column> m_columns;
        -: 5370:
        -: 5371:    public:
        -: 5372:
        -: 5373:        class iterator {
        -: 5374:            friend Columns;
        -: 5375:            struct EndTag {};
        -: 5376:
        -: 5377:            std::vector<Column> const& m_columns;
        -: 5378:            std::vector<Column::iterator> m_iterators;
        -: 5379:            size_t m_activeIterators;
        -: 5380:
    #####: 5381:            iterator( Columns const& columns, EndTag )
    #####: 5382:            :   m_columns( columns.m_columns ),
    #####: 5383:                m_activeIterators( 0 )
        -: 5384:            {
    #####: 5385:                m_iterators.reserve( m_columns.size() );
        -: 5386:
    #####: 5387:                for( auto const& col : m_columns )
    #####: 5388:                    m_iterators.push_back( col.end() );
    #####: 5389:            }
        -: 5390:
        -: 5391:        public:
    #####: 5392:            explicit iterator( Columns const& columns )
    #####: 5393:            :   m_columns( columns.m_columns ),
    #####: 5394:                m_activeIterators( m_columns.size() )
        -: 5395:            {
    #####: 5396:                m_iterators.reserve( m_columns.size() );
        -: 5397:
    #####: 5398:                for( auto const& col : m_columns )
    #####: 5399:                    m_iterators.push_back( col.begin() );
    #####: 5400:            }
        -: 5401:
        -: 5402:            auto operator ==( iterator const& other ) const -> bool {
        -: 5403:                return m_iterators == other.m_iterators;
        -: 5404:            }
    #####: 5405:            auto operator !=( iterator const& other ) const -> bool {
    #####: 5406:                return m_iterators != other.m_iterators;
        -: 5407:            }
    #####: 5408:            auto operator *() const -> std::string {
    #####: 5409:                std::string row, padding;
        -: 5410:
    #####: 5411:                for( size_t i = 0; i < m_columns.size(); ++i ) {
    #####: 5412:                    auto width = m_columns[i].width();
    #####: 5413:                    if( m_iterators[i] != m_columns[i].end() ) {
    #####: 5414:                        std::string col = *m_iterators[i];
    #####: 5415:                        row += padding + col;
    #####: 5416:                        if( col.size() < width )
    #####: 5417:                            padding = std::string( width - col.size(), ' ' );
        -: 5418:                        else
    #####: 5419:                            padding = "";
    #####: 5420:                    }
        -: 5421:                    else {
    #####: 5422:                        padding += std::string( width, ' ' );
        -: 5423:                    }
        -: 5424:                }
    #####: 5425:                return row;
    #####: 5426:            }
    #####: 5427:            auto operator ++() -> iterator& {
    #####: 5428:                for( size_t i = 0; i < m_columns.size(); ++i ) {
    #####: 5429:                    if (m_iterators[i] != m_columns[i].end())
    #####: 5430:                        ++m_iterators[i];
        -: 5431:                }
    #####: 5432:                return *this;
        -: 5433:            }
        -: 5434:            auto operator ++(int) -> iterator {
        -: 5435:                iterator prev( *this );
        -: 5436:                operator++();
        -: 5437:                return prev;
        -: 5438:            }
        -: 5439:        };
        -: 5440:        using const_iterator = iterator;
        -: 5441:
    #####: 5442:        auto begin() const -> iterator { return iterator( *this ); }
    #####: 5443:        auto end() const -> iterator { return { *this, iterator::EndTag() }; }
        -: 5444:
    #####: 5445:        auto operator += ( Column const& col ) -> Columns& {
    #####: 5446:            m_columns.push_back( col );
    #####: 5447:            return *this;
        -: 5448:        }
    #####: 5449:        auto operator + ( Column const& col ) -> Columns {
    #####: 5450:            Columns combined = *this;
    #####: 5451:            combined += col;
    #####: 5452:            return combined;
    =====: 5453:        }
        -: 5454:
    #####: 5455:        inline friend std::ostream& operator << ( std::ostream& os, Columns const& cols ) {
        -: 5456:
    #####: 5457:            bool first = true;
    #####: 5458:            for( auto line : cols ) {
    #####: 5459:                if( first )
    #####: 5460:                    first = false;
        -: 5461:                else
    #####: 5462:                    os << "\n";
    #####: 5463:                os << line;
    #####: 5464:            }
    #####: 5465:            return os;
        -: 5466:        }
        -: 5467:
        -: 5468:        auto toString() const -> std::string {
        -: 5469:            std::ostringstream oss;
        -: 5470:            oss << *this;
        -: 5471:            return oss.str();
        -: 5472:        }
        -: 5473:    };
        -: 5474:
    #####: 5475:    inline auto Column::operator + ( Column const& other ) -> Columns {
    #####: 5476:        Columns cols;
    #####: 5477:        cols += *this;
    #####: 5478:        cols += other;
    #####: 5479:        return cols;
    =====: 5480:    }
        -: 5481:}}} // namespace Catch::clara::TextFlow
        -: 5482:
        -: 5483:// ----------- end of #include from clara_textflow.hpp -----------
        -: 5484:// ........... back in clara.hpp
        -: 5485:
        -: 5486:#include <memory>
        -: 5487:#include <set>
        -: 5488:#include <algorithm>
        -: 5489:
        -: 5490:#if !defined(CATCH_PLATFORM_WINDOWS) && ( defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) )
        -: 5491:#define CATCH_PLATFORM_WINDOWS
        -: 5492:#endif
        -: 5493:
        -: 5494:namespace Catch { namespace clara {
        -: 5495:namespace detail {
        -: 5496:
        -: 5497:    // Traits for extracting arg and return type of lambdas (for single argument lambdas)
        -: 5498:    template<typename L>
        -: 5499:    struct UnaryLambdaTraits : UnaryLambdaTraits<decltype( &L::operator() )> {};
        -: 5500:
        -: 5501:    template<typename ClassT, typename ReturnT, typename... Args>
        -: 5502:    struct UnaryLambdaTraits<ReturnT( ClassT::* )( Args... ) const> {
        -: 5503:        static const bool isValid = false;
        -: 5504:    };
        -: 5505:
        -: 5506:    template<typename ClassT, typename ReturnT, typename ArgT>
        -: 5507:    struct UnaryLambdaTraits<ReturnT( ClassT::* )( ArgT ) const> {
        -: 5508:        static const bool isValid = true;
        -: 5509:        using ArgType = typename std::remove_const<typename std::remove_reference<ArgT>::type>::type;
        -: 5510:        using ReturnType = ReturnT;
        -: 5511:    };
        -: 5512:
        -: 5513:    class TokenStream;
        -: 5514:
        -: 5515:    // Transport for raw args (copied from main args, or supplied via init list for testing)
        -: 5516:    class Args {
        -: 5517:        friend TokenStream;
        -: 5518:        std::string m_exeName;
        -: 5519:        std::vector<std::string> m_args;
        -: 5520:
        -: 5521:    public:
        1: 5522:        Args( int argc, char const* const* argv )
        1: 5523:            : m_exeName(argv[0]),
        1: 5524:              m_args(argv + 1, argv + argc) {}
        -: 5525:
        -: 5526:        Args( std::initializer_list<std::string> args )
        -: 5527:        :   m_exeName( *args.begin() ),
        -: 5528:            m_args( args.begin()+1, args.end() )
        -: 5529:        {}
        -: 5530:
        1: 5531:        auto exeName() const -> std::string {
        1: 5532:            return m_exeName;
        -: 5533:        }
        -: 5534:    };
        -: 5535:
        -: 5536:    // Wraps a token coming from a token stream. These may not directly correspond to strings as a single string
        -: 5537:    // may encode an option + its argument if the : or = form is used
        -: 5538:    enum class TokenType {
        -: 5539:        Option, Argument
        -: 5540:    };
        -: 5541:    struct Token {
        -: 5542:        TokenType type;
        -: 5543:        std::string token;
        -: 5544:    };
        -: 5545:
    #####: 5546:    inline auto isOptPrefix( char c ) -> bool {
    #####: 5547:        return c == '-'
        -: 5548:#ifdef CATCH_PLATFORM_WINDOWS
        -: 5549:            || c == '/'
        -: 5550:#endif
        -: 5551:        ;
        -: 5552:    }
        -: 5553:
        -: 5554:    // Abstracts iterators into args as a stream of tokens, with option arguments uniformly handled
        -: 5555:    class TokenStream {
        -: 5556:        using Iterator = std::vector<std::string>::const_iterator;
        -: 5557:        Iterator it;
        -: 5558:        Iterator itEnd;
        -: 5559:        std::vector<Token> m_tokenBuffer;
        -: 5560:
        1: 5561:        void loadBuffer() {
        1: 5562:            m_tokenBuffer.resize( 0 );
        -: 5563:
        -: 5564:            // Skip any empty strings
       1*: 5565:            while( it != itEnd && it->empty() )
    #####: 5566:                ++it;
        -: 5567:
        1: 5568:            if( it != itEnd ) {
    #####: 5569:                auto const &next = *it;
    #####: 5570:                if( isOptPrefix( next[0] ) ) {
    #####: 5571:                    auto delimiterPos = next.find_first_of( " :=" );
    #####: 5572:                    if( delimiterPos != std::string::npos ) {
    #####: 5573:                        m_tokenBuffer.push_back( { TokenType::Option, next.substr( 0, delimiterPos ) } );
    #####: 5574:                        m_tokenBuffer.push_back( { TokenType::Argument, next.substr( delimiterPos + 1 ) } );
        -: 5575:                    } else {
    #####: 5576:                        if( next[1] != '-' && next.size() > 2 ) {
    #####: 5577:                            std::string opt = "- ";
    #####: 5578:                            for( size_t i = 1; i < next.size(); ++i ) {
    #####: 5579:                                opt[1] = next[i];
    #####: 5580:                                m_tokenBuffer.push_back( { TokenType::Option, opt } );
        -: 5581:                            }
    #####: 5582:                        } else {
    #####: 5583:                            m_tokenBuffer.push_back( { TokenType::Option, next } );
        -: 5584:                        }
        -: 5585:                    }
        -: 5586:                } else {
    #####: 5587:                    m_tokenBuffer.push_back( { TokenType::Argument, next } );
        -: 5588:                }
        -: 5589:            }
        1: 5590:        }
        -: 5591:
        -: 5592:    public:
        1: 5593:        explicit TokenStream( Args const &args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) {}
        -: 5594:
        1: 5595:        TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) {
        1: 5596:            loadBuffer();
        1: 5597:        }
        -: 5598:
        1: 5599:        explicit operator bool() const {
       1*: 5600:            return !m_tokenBuffer.empty() || it != itEnd;
        -: 5601:        }
        -: 5602:
        -: 5603:        auto count() const -> size_t { return m_tokenBuffer.size() + (itEnd - it); }
        -: 5604:
    #####: 5605:        auto operator*() const -> Token {
    #####: 5606:            assert( !m_tokenBuffer.empty() );
    #####: 5607:            return m_tokenBuffer.front();
        -: 5608:        }
        -: 5609:
    #####: 5610:        auto operator->() const -> Token const * {
    #####: 5611:            assert( !m_tokenBuffer.empty() );
    #####: 5612:            return &m_tokenBuffer.front();
        -: 5613:        }
        -: 5614:
    #####: 5615:        auto operator++() -> TokenStream & {
    #####: 5616:            if( m_tokenBuffer.size() >= 2 ) {
    #####: 5617:                m_tokenBuffer.erase( m_tokenBuffer.begin() );
        -: 5618:            } else {
    #####: 5619:                if( it != itEnd )
    #####: 5620:                    ++it;
    #####: 5621:                loadBuffer();
        -: 5622:            }
    #####: 5623:            return *this;
        -: 5624:        }
        -: 5625:    };
        -: 5626:
        -: 5627:    class ResultBase {
        -: 5628:    public:
        -: 5629:        enum Type {
        -: 5630:            Ok, LogicError, RuntimeError
        -: 5631:        };
        -: 5632:
        -: 5633:    protected:
        2: 5634:        ResultBase( Type type ) : m_type( type ) {}
       3*: 5635:        virtual ~ResultBase() = default;
------------------
_ZN5Catch5clara6detail10ResultBaseD0Ev:
    #####: 5635:        virtual ~ResultBase() = default;
------------------
_ZN5Catch5clara6detail10ResultBaseD2Ev:
        3: 5635:        virtual ~ResultBase() = default;
------------------
        -: 5636:
        -: 5637:        virtual void enforceOk() const = 0;
        -: 5638:
        -: 5639:        Type m_type;
        -: 5640:    };
        -: 5641:
        -: 5642:    template<typename T>
        -: 5643:    class ResultValueBase : public ResultBase {
        -: 5644:    public:
       1*: 5645:        auto value() const -> T const & {
       1*: 5646:            enforceOk();
       1*: 5647:            return m_value;
        -: 5648:        }
------------------
_ZNK5Catch5clara6detail15ResultValueBaseINS1_10ParseStateEE5valueEv:
        1: 5645:        auto value() const -> T const & {
        1: 5646:            enforceOk();
        1: 5647:            return m_value;
        -: 5648:        }
------------------
_ZNK5Catch5clara6detail15ResultValueBaseINS1_15ParseResultTypeEE5valueEv:
    #####: 5645:        auto value() const -> T const & {
    #####: 5646:            enforceOk();
    #####: 5647:            return m_value;
        -: 5648:        }
------------------
        -: 5649:
        -: 5650:    protected:
    #####: 5651:        ResultValueBase( Type type ) : ResultBase( type ) {}
------------------
_ZN5Catch5clara6detail15ResultValueBaseINS1_15ParseResultTypeEEC2ENS1_10ResultBase4TypeE:
    #####: 5651:        ResultValueBase( Type type ) : ResultBase( type ) {}
------------------
_ZN5Catch5clara6detail15ResultValueBaseINS1_10ParseStateEEC2ENS1_10ResultBase4TypeE:
    #####: 5651:        ResultValueBase( Type type ) : ResultBase( type ) {}
------------------
        -: 5652:
       1*: 5653:        ResultValueBase( ResultValueBase const &other ) : ResultBase( other ) {
       1*: 5654:            if( m_type == ResultBase::Ok )
       1*: 5655:                new( &m_value ) T( other.m_value );
       1*: 5656:        }
------------------
_ZN5Catch5clara6detail15ResultValueBaseINS1_10ParseStateEEC2ERKS4_:
        1: 5653:        ResultValueBase( ResultValueBase const &other ) : ResultBase( other ) {
        1: 5654:            if( m_type == ResultBase::Ok )
        1: 5655:                new( &m_value ) T( other.m_value );
        1: 5656:        }
------------------
_ZN5Catch5clara6detail15ResultValueBaseINS1_15ParseResultTypeEEC2ERKS4_:
    #####: 5653:        ResultValueBase( ResultValueBase const &other ) : ResultBase( other ) {
    #####: 5654:            if( m_type == ResultBase::Ok )
    #####: 5655:                new( &m_value ) T( other.m_value );
    #####: 5656:        }
------------------
        -: 5657:
        2: 5658:        ResultValueBase( Type, T const &value ) : ResultBase( Ok ) {
        2: 5659:            new( &m_value ) T( value );
        2: 5660:        }
------------------
_ZN5Catch5clara6detail15ResultValueBaseINS1_10ParseStateEEC2ENS1_10ResultBase4TypeERKS3_:
        1: 5658:        ResultValueBase( Type, T const &value ) : ResultBase( Ok ) {
        1: 5659:            new( &m_value ) T( value );
        1: 5660:        }
------------------
_ZN5Catch5clara6detail15ResultValueBaseINS1_15ParseResultTypeEEC2ENS1_10ResultBase4TypeERKS3_:
        1: 5658:        ResultValueBase( Type, T const &value ) : ResultBase( Ok ) {
        1: 5659:            new( &m_value ) T( value );
        1: 5660:        }
------------------
        -: 5661:
    #####: 5662:        auto operator=( ResultValueBase const &other ) -> ResultValueBase & {
    #####: 5663:            if( m_type == ResultBase::Ok )
    #####: 5664:                m_value.~T();
    #####: 5665:            ResultBase::operator=(other);
    #####: 5666:            if( m_type == ResultBase::Ok )
    #####: 5667:                new( &m_value ) T( other.m_value );
    #####: 5668:            return *this;
        -: 5669:        }
        -: 5670:
       3*: 5671:        ~ResultValueBase() override {
        3: 5672:            if( m_type == Ok )
        3: 5673:                m_value.~T();
       6*: 5674:        }
------------------
_ZN5Catch5clara6detail15ResultValueBaseINS1_10ParseStateEED0Ev:
    #####: 5671:        ~ResultValueBase() override {
        -: 5672:            if( m_type == Ok )
        -: 5673:                m_value.~T();
    #####: 5674:        }
------------------
_ZN5Catch5clara6detail15ResultValueBaseINS1_10ParseStateEED2Ev:
        2: 5671:        ~ResultValueBase() override {
        2: 5672:            if( m_type == Ok )
        2: 5673:                m_value.~T();
        4: 5674:        }
------------------
_ZN5Catch5clara6detail15ResultValueBaseINS1_15ParseResultTypeEED0Ev:
    #####: 5671:        ~ResultValueBase() override {
        -: 5672:            if( m_type == Ok )
        -: 5673:                m_value.~T();
    #####: 5674:        }
------------------
_ZN5Catch5clara6detail15ResultValueBaseINS1_15ParseResultTypeEED2Ev:
        1: 5671:        ~ResultValueBase() override {
        1: 5672:            if( m_type == Ok )
        1: 5673:                m_value.~T();
        2: 5674:        }
------------------
        -: 5675:
        -: 5676:        union {
        -: 5677:            T m_value;
        -: 5678:        };
        -: 5679:    };
        -: 5680:
        -: 5681:    template<>
        -: 5682:    class ResultValueBase<void> : public ResultBase {
        -: 5683:    protected:
        -: 5684:        using ResultBase::ResultBase;
        -: 5685:    };
        -: 5686:
        -: 5687:    template<typename T = void>
        -: 5688:    class BasicResult : public ResultValueBase<T> {
        -: 5689:    public:
        -: 5690:        template<typename U>
    #####: 5691:        explicit BasicResult( BasicResult<U> const &other )
        -: 5692:        :   ResultValueBase<T>( other.type() ),
    #####: 5693:            m_errorMessage( other.errorMessage() )
        -: 5694:        {
    #####: 5695:            assert( type() != ResultBase::Ok );
    #####: 5696:        }
------------------
_ZN5Catch5clara6detail11BasicResultINS1_10ParseStateEEC2INS1_15ParseResultTypeEEERKNS2_IT_EE:
    #####: 5691:        explicit BasicResult( BasicResult<U> const &other )
        -: 5692:        :   ResultValueBase<T>( other.type() ),
    #####: 5693:            m_errorMessage( other.errorMessage() )
        -: 5694:        {
    #####: 5695:            assert( type() != ResultBase::Ok );
    #####: 5696:        }
------------------
_ZN5Catch5clara6detail11BasicResultINS1_10ParseStateEEC2IvEERKNS2_IT_EE:
    #####: 5691:        explicit BasicResult( BasicResult<U> const &other )
        -: 5692:        :   ResultValueBase<T>( other.type() ),
    #####: 5693:            m_errorMessage( other.errorMessage() )
        -: 5694:        {
    #####: 5695:            assert( type() != ResultBase::Ok );
    #####: 5696:        }
------------------
        -: 5697:
        -: 5698:        template<typename U>
        2: 5699:        static auto ok( U const &value ) -> BasicResult { return { ResultBase::Ok, value }; }
------------------
_ZN5Catch5clara6detail11BasicResultINS1_10ParseStateEE2okIS3_EES4_RKT_:
        1: 5699:        static auto ok( U const &value ) -> BasicResult { return { ResultBase::Ok, value }; }
------------------
_ZN5Catch5clara6detail11BasicResultINS1_15ParseResultTypeEE2okIS3_EES4_RKT_:
        1: 5699:        static auto ok( U const &value ) -> BasicResult { return { ResultBase::Ok, value }; }
------------------
    #####: 5700:        static auto ok() -> BasicResult { return { ResultBase::Ok }; }
    #####: 5701:        static auto logicError( std::string const &message ) -> BasicResult { return { ResultBase::LogicError, message }; }
    #####: 5702:        static auto runtimeError( std::string const &message ) -> BasicResult { return { ResultBase::RuntimeError, message }; }
------------------
_ZN5Catch5clara6detail11BasicResultINS1_10ParseStateEE12runtimeErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 5702:        static auto runtimeError( std::string const &message ) -> BasicResult { return { ResultBase::RuntimeError, message }; }
------------------
_ZN5Catch5clara6detail11BasicResultINS1_15ParseResultTypeEE12runtimeErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 5702:        static auto runtimeError( std::string const &message ) -> BasicResult { return { ResultBase::RuntimeError, message }; }
------------------
        -: 5703:
       1*: 5704:        explicit operator bool() const { return m_type == ResultBase::Ok; }
------------------
_ZNK5Catch5clara6detail11BasicResultINS1_10ParseStateEEcvbEv:
        1: 5704:        explicit operator bool() const { return m_type == ResultBase::Ok; }
------------------
_ZNK5Catch5clara6detail11BasicResultINS1_15ParseResultTypeEEcvbEv:
    #####: 5704:        explicit operator bool() const { return m_type == ResultBase::Ok; }
------------------
_ZNK5Catch5clara6detail11BasicResultIvEcvbEv:
    #####: 5704:        explicit operator bool() const { return m_type == ResultBase::Ok; }
------------------
    #####: 5705:        auto type() const -> ResultBase::Type { return m_type; }
------------------
_ZNK5Catch5clara6detail11BasicResultINS1_15ParseResultTypeEE4typeEv:
    #####: 5705:        auto type() const -> ResultBase::Type { return m_type; }
------------------
_ZNK5Catch5clara6detail11BasicResultINS1_10ParseStateEE4typeEv:
    #####: 5705:        auto type() const -> ResultBase::Type { return m_type; }
------------------
_ZNK5Catch5clara6detail11BasicResultIvE4typeEv:
    #####: 5705:        auto type() const -> ResultBase::Type { return m_type; }
------------------
    #####: 5706:        auto errorMessage() const -> std::string { return m_errorMessage; }
------------------
_ZNK5Catch5clara6detail11BasicResultINS1_15ParseResultTypeEE12errorMessageB5cxx11Ev:
    #####: 5706:        auto errorMessage() const -> std::string { return m_errorMessage; }
------------------
_ZNK5Catch5clara6detail11BasicResultIvE12errorMessageB5cxx11Ev:
    #####: 5706:        auto errorMessage() const -> std::string { return m_errorMessage; }
------------------
_ZNK5Catch5clara6detail11BasicResultINS1_10ParseStateEE12errorMessageB5cxx11Ev:
    #####: 5706:        auto errorMessage() const -> std::string { return m_errorMessage; }
------------------
        -: 5707:
        -: 5708:    protected:
       1*: 5709:        void enforceOk() const override {
        -: 5710:
        -: 5711:            // Errors shouldn't reach this point, but if they do
        -: 5712:            // the actual error message will be in m_errorMessage
       1*: 5713:            assert( m_type != ResultBase::LogicError );
       1*: 5714:            assert( m_type != ResultBase::RuntimeError );
       1*: 5715:            if( m_type != ResultBase::Ok )
    #####: 5716:                std::abort();
       1*: 5717:        }
------------------
_ZNK5Catch5clara6detail11BasicResultINS1_15ParseResultTypeEE9enforceOkEv:
    #####: 5709:        void enforceOk() const override {
        -: 5710:
        -: 5711:            // Errors shouldn't reach this point, but if they do
        -: 5712:            // the actual error message will be in m_errorMessage
    #####: 5713:            assert( m_type != ResultBase::LogicError );
    #####: 5714:            assert( m_type != ResultBase::RuntimeError );
    #####: 5715:            if( m_type != ResultBase::Ok )
    #####: 5716:                std::abort();
    #####: 5717:        }
------------------
_ZNK5Catch5clara6detail11BasicResultIvE9enforceOkEv:
    #####: 5709:        void enforceOk() const override {
        -: 5710:
        -: 5711:            // Errors shouldn't reach this point, but if they do
        -: 5712:            // the actual error message will be in m_errorMessage
    #####: 5713:            assert( m_type != ResultBase::LogicError );
    #####: 5714:            assert( m_type != ResultBase::RuntimeError );
    #####: 5715:            if( m_type != ResultBase::Ok )
    #####: 5716:                std::abort();
    #####: 5717:        }
------------------
_ZNK5Catch5clara6detail11BasicResultINS1_10ParseStateEE9enforceOkEv:
        1: 5709:        void enforceOk() const override {
        -: 5710:
        -: 5711:            // Errors shouldn't reach this point, but if they do
        -: 5712:            // the actual error message will be in m_errorMessage
       1*: 5713:            assert( m_type != ResultBase::LogicError );
       1*: 5714:            assert( m_type != ResultBase::RuntimeError );
        1: 5715:            if( m_type != ResultBase::Ok )
    #####: 5716:                std::abort();
        1: 5717:        }
------------------
        -: 5718:
        -: 5719:        std::string m_errorMessage; // Only populated if resultType is an error
        -: 5720:
    #####: 5721:        BasicResult( ResultBase::Type type, std::string const &message )
        -: 5722:        :   ResultValueBase<T>(type),
    #####: 5723:            m_errorMessage(message)
        -: 5724:        {
    #####: 5725:            assert( m_type != ResultBase::Ok );
    #####: 5726:        }
------------------
_ZN5Catch5clara6detail11BasicResultIvEC2ENS1_10ResultBase4TypeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 5721:        BasicResult( ResultBase::Type type, std::string const &message )
        -: 5722:        :   ResultValueBase<T>(type),
    #####: 5723:            m_errorMessage(message)
        -: 5724:        {
    #####: 5725:            assert( m_type != ResultBase::Ok );
    #####: 5726:        }
------------------
_ZN5Catch5clara6detail11BasicResultINS1_10ParseStateEEC2ENS1_10ResultBase4TypeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 5721:        BasicResult( ResultBase::Type type, std::string const &message )
        -: 5722:        :   ResultValueBase<T>(type),
    #####: 5723:            m_errorMessage(message)
        -: 5724:        {
    #####: 5725:            assert( m_type != ResultBase::Ok );
    #####: 5726:        }
------------------
_ZN5Catch5clara6detail11BasicResultINS1_15ParseResultTypeEEC2ENS1_10ResultBase4TypeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 5721:        BasicResult( ResultBase::Type type, std::string const &message )
        -: 5722:        :   ResultValueBase<T>(type),
    #####: 5723:            m_errorMessage(message)
        -: 5724:        {
    #####: 5725:            assert( m_type != ResultBase::Ok );
    #####: 5726:        }
------------------
        -: 5727:
        -: 5728:        using ResultValueBase<T>::ResultValueBase;
        -: 5729:        using ResultBase::m_type;
        -: 5730:    };
        -: 5731:
        -: 5732:    enum class ParseResultType {
        -: 5733:        Matched, NoMatch, ShortCircuitAll, ShortCircuitSame
        -: 5734:    };
        -: 5735:
        -: 5736:    class ParseState {
        -: 5737:    public:
        -: 5738:
        1: 5739:        ParseState( ParseResultType type, TokenStream const &remainingTokens )
        1: 5740:        : m_type(type),
        1: 5741:          m_remainingTokens( remainingTokens )
        1: 5742:        {}
        -: 5743:
    #####: 5744:        auto type() const -> ParseResultType { return m_type; }
        1: 5745:        auto remainingTokens() const -> TokenStream { return m_remainingTokens; }
        -: 5746:
        -: 5747:    private:
        -: 5748:        ParseResultType m_type;
        -: 5749:        TokenStream m_remainingTokens;
        -: 5750:    };
        -: 5751:
        -: 5752:    using Result = BasicResult<void>;
        -: 5753:    using ParserResult = BasicResult<ParseResultType>;
        -: 5754:    using InternalParseResult = BasicResult<ParseState>;
        -: 5755:
        -: 5756:    struct HelpColumns {
        -: 5757:        std::string left;
        -: 5758:        std::string right;
        -: 5759:    };
        -: 5760:
        -: 5761:    template<typename T>
    #####: 5762:    inline auto convertInto( std::string const &source, T& target ) -> ParserResult {
    #####: 5763:        std::stringstream ss;
    #####: 5764:        ss << source;
    #####: 5765:        ss >> target;
    #####: 5766:        if( ss.fail() )
    #####: 5767:            return ParserResult::runtimeError( "Unable to convert '" + source + "' to destination type" );
        -: 5768:        else
    #####: 5769:            return ParserResult::ok( ParseResultType::Matched );
    #####: 5770:    }
------------------
_ZN5Catch5clara6detail11convertIntoIiEENS1_11BasicResultINS1_15ParseResultTypeEEERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERT_:
    #####: 5762:    inline auto convertInto( std::string const &source, T& target ) -> ParserResult {
    #####: 5763:        std::stringstream ss;
    #####: 5764:        ss << source;
    #####: 5765:        ss >> target;
    #####: 5766:        if( ss.fail() )
    #####: 5767:            return ParserResult::runtimeError( "Unable to convert '" + source + "' to destination type" );
        -: 5768:        else
    #####: 5769:            return ParserResult::ok( ParseResultType::Matched );
    #####: 5770:    }
------------------
_ZN5Catch5clara6detail11convertIntoIjEENS1_11BasicResultINS1_15ParseResultTypeEEERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERT_:
    #####: 5762:    inline auto convertInto( std::string const &source, T& target ) -> ParserResult {
    #####: 5763:        std::stringstream ss;
    #####: 5764:        ss << source;
    #####: 5765:        ss >> target;
    #####: 5766:        if( ss.fail() )
    #####: 5767:            return ParserResult::runtimeError( "Unable to convert '" + source + "' to destination type" );
        -: 5768:        else
    #####: 5769:            return ParserResult::ok( ParseResultType::Matched );
    #####: 5770:    }
------------------
        1: 5771:    inline auto convertInto( std::string const &source, std::string& target ) -> ParserResult {
        1: 5772:        target = source;
        2: 5773:        return ParserResult::ok( ParseResultType::Matched );
        -: 5774:    }
    #####: 5775:    inline auto convertInto( std::string const &source, bool &target ) -> ParserResult {
    #####: 5776:        std::string srcLC = source;
    #####: 5777:        std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( char c ) { return static_cast<char>( ::tolower(c) ); } );
    #####: 5778:        if (srcLC == "y" || srcLC == "1" || srcLC == "true" || srcLC == "yes" || srcLC == "on")
    #####: 5779:            target = true;
    #####: 5780:        else if (srcLC == "n" || srcLC == "0" || srcLC == "false" || srcLC == "no" || srcLC == "off")
    #####: 5781:            target = false;
        -: 5782:        else
    #####: 5783:            return ParserResult::runtimeError( "Expected a boolean value but did not recognise: '" + source + "'" );
    #####: 5784:        return ParserResult::ok( ParseResultType::Matched );
    #####: 5785:    }
        -: 5786:#ifdef CLARA_CONFIG_OPTIONAL_TYPE
        -: 5787:    template<typename T>
        -: 5788:    inline auto convertInto( std::string const &source, CLARA_CONFIG_OPTIONAL_TYPE<T>& target ) -> ParserResult {
        -: 5789:        T temp;
        -: 5790:        auto result = convertInto( source, temp );
        -: 5791:        if( result )
        -: 5792:            target = std::move(temp);
        -: 5793:        return result;
        -: 5794:    }
        -: 5795:#endif // CLARA_CONFIG_OPTIONAL_TYPE
        -: 5796:
        -: 5797:    struct NonCopyable {
        -: 5798:        NonCopyable() = default;
        -: 5799:        NonCopyable( NonCopyable const & ) = delete;
        -: 5800:        NonCopyable( NonCopyable && ) = delete;
        -: 5801:        NonCopyable &operator=( NonCopyable const & ) = delete;
        -: 5802:        NonCopyable &operator=( NonCopyable && ) = delete;
        -: 5803:    };
        -: 5804:
        -: 5805:    struct BoundRef : NonCopyable {
      28*: 5806:        virtual ~BoundRef() = default;
------------------
_ZN5Catch5clara6detail8BoundRefD0Ev:
    #####: 5806:        virtual ~BoundRef() = default;
------------------
_ZN5Catch5clara6detail8BoundRefD2Ev:
       28: 5806:        virtual ~BoundRef() = default;
------------------
    #####: 5807:        virtual auto isContainer() const -> bool { return false; }
    #####: 5808:        virtual auto isFlag() const -> bool { return false; }
        -: 5809:    };
        -: 5810:    struct BoundValueRefBase : BoundRef {
        -: 5811:        virtual auto setValue( std::string const &arg ) -> ParserResult = 0;
        -: 5812:    };
        -: 5813:    struct BoundFlagRefBase : BoundRef {
        -: 5814:        virtual auto setFlag( bool flag ) -> ParserResult = 0;
    #####: 5815:        virtual auto isFlag() const -> bool { return true; }
        -: 5816:    };
        -: 5817:
        -: 5818:    template<typename T>
        -: 5819:    struct BoundValueRef : BoundValueRefBase {
        -: 5820:        T &m_ref;
        -: 5821:
        4: 5822:        explicit BoundValueRef( T &ref ) : m_ref( ref ) {}
------------------
_ZN5Catch5clara6detail13BoundValueRefIiEC2ERi:
        1: 5822:        explicit BoundValueRef( T &ref ) : m_ref( ref ) {}
------------------
_ZN5Catch5clara6detail13BoundValueRefINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEC2ERS8_:
        3: 5822:        explicit BoundValueRef( T &ref ) : m_ref( ref ) {}
------------------
        -: 5823:
       1*: 5824:        auto setValue( std::string const &arg ) -> ParserResult override {
       1*: 5825:            return convertInto( arg, m_ref );
        -: 5826:        }
------------------
_ZN5Catch5clara6detail13BoundValueRefINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE8setValueERKS8_:
        1: 5824:        auto setValue( std::string const &arg ) -> ParserResult override {
        1: 5825:            return convertInto( arg, m_ref );
        -: 5826:        }
------------------
_ZN5Catch5clara6detail13BoundValueRefIiE8setValueERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 5824:        auto setValue( std::string const &arg ) -> ParserResult override {
    #####: 5825:            return convertInto( arg, m_ref );
        -: 5826:        }
------------------
        -: 5827:    };
        -: 5828:
        -: 5829:    template<typename T>
        -: 5830:    struct BoundValueRef<std::vector<T>> : BoundValueRefBase {
        -: 5831:        std::vector<T> &m_ref;
        -: 5832:
        3: 5833:        explicit BoundValueRef( std::vector<T> &ref ) : m_ref( ref ) {}
        -: 5834:
    #####: 5835:        auto isContainer() const -> bool override { return true; }
        -: 5836:
    #####: 5837:        auto setValue( std::string const &arg ) -> ParserResult override {
    #####: 5838:            T temp;
    #####: 5839:            auto result = convertInto( arg, temp );
    #####: 5840:            if( result )
    #####: 5841:                m_ref.push_back( temp );
    #####: 5842:            return result;
    #####: 5843:        }
        -: 5844:    };
        -: 5845:
        -: 5846:    struct BoundFlagRef : BoundFlagRefBase {
        -: 5847:        bool &m_ref;
        -: 5848:
       10: 5849:        explicit BoundFlagRef( bool &ref ) : m_ref( ref ) {}
        -: 5850:
    #####: 5851:        auto setFlag( bool flag ) -> ParserResult override {
    #####: 5852:            m_ref = flag;
    #####: 5853:            return ParserResult::ok( ParseResultType::Matched );
        -: 5854:        }
        -: 5855:    };
        -: 5856:
        -: 5857:    template<typename ReturnType>
        -: 5858:    struct LambdaInvoker {
        -: 5859:        static_assert( std::is_same<ReturnType, ParserResult>::value, "Lambda must return void or clara::ParserResult" );
        -: 5860:
        -: 5861:        template<typename L, typename ArgType>
    #####: 5862:        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
    #####: 5863:            return lambda( arg );
        -: 5864:        }
------------------
_ZN5Catch5clara6detail13LambdaInvokerINS1_11BasicResultINS1_15ParseResultTypeEEEE6invokeIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE_SF_EES5_RKT_RKT0_:
    #####: 5862:        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
    #####: 5863:            return lambda( arg );
        -: 5864:        }
------------------
_ZN5Catch5clara6detail13LambdaInvokerINS1_11BasicResultINS1_15ParseResultTypeEEEE6invokeIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE0_SF_EES5_RKT_RKT0_:
    #####: 5862:        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
    #####: 5863:            return lambda( arg );
        -: 5864:        }
------------------
_ZN5Catch5clara6detail13LambdaInvokerINS1_11BasicResultINS1_15ParseResultTypeEEEE6invokeIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE5_SF_EES5_RKT_RKT0_:
    #####: 5862:        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
    #####: 5863:            return lambda( arg );
        -: 5864:        }
------------------
_ZN5Catch5clara6detail13LambdaInvokerINS1_11BasicResultINS1_15ParseResultTypeEEEE6invokeIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE1_SF_EES5_RKT_RKT0_:
    #####: 5862:        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
    #####: 5863:            return lambda( arg );
        -: 5864:        }
------------------
_ZN5Catch5clara6detail13LambdaInvokerINS1_11BasicResultINS1_15ParseResultTypeEEEE6invokeIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE2_SF_EES5_RKT_RKT0_:
    #####: 5862:        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
    #####: 5863:            return lambda( arg );
        -: 5864:        }
------------------
_ZN5Catch5clara6detail13LambdaInvokerINS1_11BasicResultINS1_15ParseResultTypeEEEE6invokeIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE3_SF_EES5_RKT_RKT0_:
    #####: 5862:        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
    #####: 5863:            return lambda( arg );
        -: 5864:        }
------------------
_ZN5Catch5clara6detail13LambdaInvokerINS1_11BasicResultINS1_15ParseResultTypeEEEE6invokeIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE4_SF_EES5_RKT_RKT0_:
    #####: 5862:        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
    #####: 5863:            return lambda( arg );
        -: 5864:        }
------------------
_ZN5Catch5clara6detail13LambdaInvokerINS1_11BasicResultINS1_15ParseResultTypeEEEE6invokeIZNS1_4HelpC4ERbEUlbE_bEES5_RKT_RKT0_:
    #####: 5862:        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
    #####: 5863:            return lambda( arg );
        -: 5864:        }
------------------
        -: 5865:    };
        -: 5866:
        -: 5867:    template<>
        -: 5868:    struct LambdaInvoker<void> {
        -: 5869:        template<typename L, typename ArgType>
    #####: 5870:        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
    #####: 5871:            lambda( arg );
    #####: 5872:            return ParserResult::ok( ParseResultType::Matched );
        -: 5873:        }
------------------
_ZN5Catch5clara6detail13LambdaInvokerIvE6invokeIZNS_21makeCommandLineParserERNS_10ConfigDataEEUliE7_iEENS1_11BasicResultINS1_15ParseResultTypeEEERKT_RKT0_:
    #####: 5870:        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
    #####: 5871:            lambda( arg );
    #####: 5872:            return ParserResult::ok( ParseResultType::Matched );
        -: 5873:        }
------------------
_ZN5Catch5clara6detail13LambdaInvokerIvE6invokeIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlbE8_bEENS1_11BasicResultINS1_15ParseResultTypeEEERKT_RKT0_:
    #####: 5870:        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
    #####: 5871:            lambda( arg );
    #####: 5872:            return ParserResult::ok( ParseResultType::Matched );
        -: 5873:        }
------------------
_ZN5Catch5clara6detail13LambdaInvokerIvE6invokeIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlbE6_bEENS1_11BasicResultINS1_15ParseResultTypeEEERKT_RKT0_:
    #####: 5870:        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
    #####: 5871:            lambda( arg );
    #####: 5872:            return ParserResult::ok( ParseResultType::Matched );
        -: 5873:        }
------------------
        -: 5874:    };
        -: 5875:
        -: 5876:    template<typename ArgType, typename L>
    #####: 5877:    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {
    #####: 5878:        ArgType temp{};
    #####: 5879:        auto result = convertInto( arg, temp );
    #####: 5880:        return !result
        -: 5881:           ? result
    #####: 5882:           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );
    #####: 5883:    }
------------------
_ZN5Catch5clara6detail12invokeLambdaIiZNS_21makeCommandLineParserERNS_10ConfigDataEEUliE7_EENS1_11BasicResultINS1_15ParseResultTypeEEERKT0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 5877:    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {
    #####: 5878:        ArgType temp{};
    #####: 5879:        auto result = convertInto( arg, temp );
    #####: 5880:        return !result
        -: 5881:           ? result
    #####: 5882:           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );
    #####: 5883:    }
------------------
_ZN5Catch5clara6detail12invokeLambdaINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKS8_E_EENS1_11BasicResultINS1_15ParseResultTypeEEERKT0_SC_:
    #####: 5877:    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {
    #####: 5878:        ArgType temp{};
    #####: 5879:        auto result = convertInto( arg, temp );
    #####: 5880:        return !result
        -: 5881:           ? result
    #####: 5882:           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );
    #####: 5883:    }
------------------
_ZN5Catch5clara6detail12invokeLambdaIbZNS_21makeCommandLineParserERNS_10ConfigDataEEUlbE8_EENS1_11BasicResultINS1_15ParseResultTypeEEERKT0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 5877:    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {
    #####: 5878:        ArgType temp{};
    #####: 5879:        auto result = convertInto( arg, temp );
    #####: 5880:        return !result
        -: 5881:           ? result
    #####: 5882:           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );
    #####: 5883:    }
------------------
_ZN5Catch5clara6detail12invokeLambdaINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKS8_E0_EENS1_11BasicResultINS1_15ParseResultTypeEEERKT0_SC_:
    #####: 5877:    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {
    #####: 5878:        ArgType temp{};
    #####: 5879:        auto result = convertInto( arg, temp );
    #####: 5880:        return !result
        -: 5881:           ? result
    #####: 5882:           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );
    #####: 5883:    }
------------------
_ZN5Catch5clara6detail12invokeLambdaINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKS8_E5_EENS1_11BasicResultINS1_15ParseResultTypeEEERKT0_SC_:
    #####: 5877:    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {
    #####: 5878:        ArgType temp{};
    #####: 5879:        auto result = convertInto( arg, temp );
    #####: 5880:        return !result
        -: 5881:           ? result
    #####: 5882:           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );
    #####: 5883:    }
------------------
_ZN5Catch5clara6detail12invokeLambdaINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKS8_E1_EENS1_11BasicResultINS1_15ParseResultTypeEEERKT0_SC_:
    #####: 5877:    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {
    #####: 5878:        ArgType temp{};
    #####: 5879:        auto result = convertInto( arg, temp );
    #####: 5880:        return !result
        -: 5881:           ? result
    #####: 5882:           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );
    #####: 5883:    }
------------------
_ZN5Catch5clara6detail12invokeLambdaINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKS8_E2_EENS1_11BasicResultINS1_15ParseResultTypeEEERKT0_SC_:
    #####: 5877:    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {
    #####: 5878:        ArgType temp{};
    #####: 5879:        auto result = convertInto( arg, temp );
    #####: 5880:        return !result
        -: 5881:           ? result
    #####: 5882:           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );
    #####: 5883:    }
------------------
_ZN5Catch5clara6detail12invokeLambdaINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKS8_E3_EENS1_11BasicResultINS1_15ParseResultTypeEEERKT0_SC_:
    #####: 5877:    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {
    #####: 5878:        ArgType temp{};
    #####: 5879:        auto result = convertInto( arg, temp );
    #####: 5880:        return !result
        -: 5881:           ? result
    #####: 5882:           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );
    #####: 5883:    }
------------------
_ZN5Catch5clara6detail12invokeLambdaINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKS8_E4_EENS1_11BasicResultINS1_15ParseResultTypeEEERKT0_SC_:
    #####: 5877:    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {
    #####: 5878:        ArgType temp{};
    #####: 5879:        auto result = convertInto( arg, temp );
    #####: 5880:        return !result
        -: 5881:           ? result
    #####: 5882:           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );
    #####: 5883:    }
------------------
        -: 5884:
        -: 5885:    template<typename L>
        -: 5886:    struct BoundLambda : BoundValueRefBase {
        -: 5887:        L m_lambda;
        -: 5888:
        -: 5889:        static_assert( UnaryLambdaTraits<L>::isValid, "Supplied lambda must take exactly one argument" );
        9: 5890:        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE4_EC2ERKSD_:
        1: 5890:        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE3_EC2ERKSD_:
        1: 5890:        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE2_EC2ERKSD_:
        1: 5890:        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE1_EC2ERKSD_:
        1: 5890:        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE5_EC2ERKSD_:
        1: 5890:        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE0_EC2ERKSD_:
        1: 5890:        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlbE8_EC2ERKS5_:
        1: 5890:        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE_EC2ERKSD_:
        1: 5890:        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUliE7_EC2ERKS5_:
        1: 5890:        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}
------------------
        -: 5891:
    #####: 5892:        auto setValue( std::string const &arg ) -> ParserResult override {
    #####: 5893:            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );
        -: 5894:        }
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUliE7_E8setValueERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 5892:        auto setValue( std::string const &arg ) -> ParserResult override {
    #####: 5893:            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );
        -: 5894:        }
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE_E8setValueESC_:
    #####: 5892:        auto setValue( std::string const &arg ) -> ParserResult override {
    #####: 5893:            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );
        -: 5894:        }
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlbE8_E8setValueERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 5892:        auto setValue( std::string const &arg ) -> ParserResult override {
    #####: 5893:            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );
        -: 5894:        }
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE0_E8setValueESC_:
    #####: 5892:        auto setValue( std::string const &arg ) -> ParserResult override {
    #####: 5893:            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );
        -: 5894:        }
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE5_E8setValueESC_:
    #####: 5892:        auto setValue( std::string const &arg ) -> ParserResult override {
    #####: 5893:            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );
        -: 5894:        }
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE1_E8setValueESC_:
    #####: 5892:        auto setValue( std::string const &arg ) -> ParserResult override {
    #####: 5893:            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );
        -: 5894:        }
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE2_E8setValueESC_:
    #####: 5892:        auto setValue( std::string const &arg ) -> ParserResult override {
    #####: 5893:            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );
        -: 5894:        }
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE3_E8setValueESC_:
    #####: 5892:        auto setValue( std::string const &arg ) -> ParserResult override {
    #####: 5893:            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );
        -: 5894:        }
------------------
_ZN5Catch5clara6detail11BoundLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE4_E8setValueESC_:
    #####: 5892:        auto setValue( std::string const &arg ) -> ParserResult override {
    #####: 5893:            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );
        -: 5894:        }
------------------
        -: 5895:    };
        -: 5896:
        -: 5897:    template<typename L>
        -: 5898:    struct BoundFlagLambda : BoundFlagRefBase {
        -: 5899:        L m_lambda;
        -: 5900:
        -: 5901:        static_assert( UnaryLambdaTraits<L>::isValid, "Supplied lambda must take exactly one argument" );
        -: 5902:        static_assert( std::is_same<typename UnaryLambdaTraits<L>::ArgType, bool>::value, "flags must be boolean" );
        -: 5903:
        2: 5904:        explicit BoundFlagLambda( L const &lambda ) : m_lambda( lambda ) {}
------------------
_ZN5Catch5clara6detail15BoundFlagLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlbE6_EC2ERKS5_:
        1: 5904:        explicit BoundFlagLambda( L const &lambda ) : m_lambda( lambda ) {}
------------------
_ZN5Catch5clara6detail15BoundFlagLambdaIZNS1_4HelpC4ERbEUlbE_EC2ERKS5_:
        1: 5904:        explicit BoundFlagLambda( L const &lambda ) : m_lambda( lambda ) {}
------------------
        -: 5905:
    #####: 5906:        auto setFlag( bool flag ) -> ParserResult override {
    #####: 5907:            return LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m_lambda, flag );
        -: 5908:        }
------------------
_ZN5Catch5clara6detail15BoundFlagLambdaIZNS1_4HelpC4ERbEUlbE_E7setFlagEb:
    #####: 5906:        auto setFlag( bool flag ) -> ParserResult override {
    #####: 5907:            return LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m_lambda, flag );
        -: 5908:        }
------------------
_ZN5Catch5clara6detail15BoundFlagLambdaIZNS_21makeCommandLineParserERNS_10ConfigDataEEUlbE6_E7setFlagEb:
    #####: 5906:        auto setFlag( bool flag ) -> ParserResult override {
    #####: 5907:            return LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m_lambda, flag );
        -: 5908:        }
------------------
        -: 5909:    };
        -: 5910:
        -: 5911:    enum class Optionality { Optional, Required };
        -: 5912:
        -: 5913:    struct Parser;
        -: 5914:
        -: 5915:    class ParserBase {
        -: 5916:    public:
    1225*: 5917:        virtual ~ParserBase() = default;
------------------
_ZN5Catch5clara6detail10ParserBaseD0Ev:
    #####: 5917:        virtual ~ParserBase() = default;
------------------
_ZN5Catch5clara6detail10ParserBaseD2Ev:
     1225: 5917:        virtual ~ParserBase() = default;
------------------
    #####: 5918:        virtual auto validate() const -> Result { return Result::ok(); }
        -: 5919:        virtual auto parse( std::string const& exeName, TokenStream const &tokens) const -> InternalParseResult  = 0;
    #####: 5920:        virtual auto cardinality() const -> size_t { return 1; }
        -: 5921:
        1: 5922:        auto parse( Args const &args ) const -> InternalParseResult {
        2: 5923:            return parse( args.exeName(), TokenStream( args ) );
        -: 5924:        }
        -: 5925:    };
        -: 5926:
        -: 5927:    template<typename DerivedT>
        -: 5928:    class ComposableParserImpl : public ParserBase {
        -: 5929:    public:
        -: 5930:        template<typename T>
        -: 5931:        auto operator|( T const &other ) const -> Parser;
        -: 5932:
        -: 5933:		template<typename T>
        -: 5934:        auto operator+( T const &other ) const -> Parser;
        -: 5935:    };
        -: 5936:
        -: 5937:    // Common code and state for Args and Opts
        -: 5938:    template<typename DerivedT>
        -: 5939:    class ParserRefImpl : public ComposableParserImpl<DerivedT> {
        -: 5940:    protected:
        -: 5941:        Optionality m_optionality = Optionality::Optional;
        -: 5942:        std::shared_ptr<BoundRef> m_ref;
        -: 5943:        std::string m_hint;
        -: 5944:        std::string m_description;
        -: 5945:
       12: 5946:        explicit ParserRefImpl( std::shared_ptr<BoundRef> const &ref ) : m_ref( ref ) {}
        -: 5947:
        -: 5948:    public:
        -: 5949:        template<typename T>
        6: 5950:        ParserRefImpl( T &ref, std::string const &hint )
        6: 5951:        :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),
       12: 5952:            m_hint( hint )
        6: 5953:        {}
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3OptEEC2IiEERT_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 5950:        ParserRefImpl( T &ref, std::string const &hint )
        1: 5951:        :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),
        2: 5952:            m_hint( hint )
        1: 5953:        {}
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3OptEEC2ISt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISC_EEEERT_RKSC_:
        2: 5950:        ParserRefImpl( T &ref, std::string const &hint )
        2: 5951:        :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),
        4: 5952:            m_hint( hint )
        2: 5953:        {}
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3OptEEC2INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEERT_RKSB_:
        2: 5950:        ParserRefImpl( T &ref, std::string const &hint )
        2: 5951:        :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),
        4: 5952:            m_hint( hint )
        2: 5953:        {}
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3ArgEEC2ISt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISC_EEEERT_RKSC_:
        1: 5950:        ParserRefImpl( T &ref, std::string const &hint )
        1: 5951:        :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),
        2: 5952:            m_hint( hint )
        1: 5953:        {}
------------------
        -: 5954:
        -: 5955:        template<typename LambdaT>
        9: 5956:        ParserRefImpl( LambdaT const &ref, std::string const &hint )
        9: 5957:        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
       18: 5958:            m_hint(hint)
        9: 5959:        {}
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3OptEEC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE4_EERKT_SF_:
        1: 5956:        ParserRefImpl( LambdaT const &ref, std::string const &hint )
        1: 5957:        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
        2: 5958:            m_hint(hint)
        1: 5959:        {}
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3OptEEC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE3_EERKT_SF_:
        1: 5956:        ParserRefImpl( LambdaT const &ref, std::string const &hint )
        1: 5957:        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
        2: 5958:            m_hint(hint)
        1: 5959:        {}
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3OptEEC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE2_EERKT_SF_:
        1: 5956:        ParserRefImpl( LambdaT const &ref, std::string const &hint )
        1: 5957:        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
        2: 5958:            m_hint(hint)
        1: 5959:        {}
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3OptEEC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE1_EERKT_SF_:
        1: 5956:        ParserRefImpl( LambdaT const &ref, std::string const &hint )
        1: 5957:        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
        2: 5958:            m_hint(hint)
        1: 5959:        {}
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3OptEEC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE5_EERKT_SF_:
        1: 5956:        ParserRefImpl( LambdaT const &ref, std::string const &hint )
        1: 5957:        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
        2: 5958:            m_hint(hint)
        1: 5959:        {}
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3OptEEC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE0_EERKT_SF_:
        1: 5956:        ParserRefImpl( LambdaT const &ref, std::string const &hint )
        1: 5957:        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
        2: 5958:            m_hint(hint)
        1: 5959:        {}
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3OptEEC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlbE8_EERKT_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 5956:        ParserRefImpl( LambdaT const &ref, std::string const &hint )
        1: 5957:        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
        2: 5958:            m_hint(hint)
        1: 5959:        {}
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3OptEEC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE_EERKT_SF_:
        1: 5956:        ParserRefImpl( LambdaT const &ref, std::string const &hint )
        1: 5957:        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
        2: 5958:            m_hint(hint)
        1: 5959:        {}
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3OptEEC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUliE7_EERKT_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 5956:        ParserRefImpl( LambdaT const &ref, std::string const &hint )
        1: 5957:        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
        2: 5958:            m_hint(hint)
        1: 5959:        {}
------------------
        -: 5960:
       27: 5961:        auto operator()( std::string const &description ) -> DerivedT & {
       27: 5962:            m_description = description;
       27: 5963:            return static_cast<DerivedT &>( *this );
        -: 5964:        }
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3ArgEEclERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 5961:        auto operator()( std::string const &description ) -> DerivedT & {
        1: 5962:            m_description = description;
        1: 5963:            return static_cast<DerivedT &>( *this );
        -: 5964:        }
------------------
_ZN5Catch5clara6detail13ParserRefImplINS1_3OptEEclERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
       26: 5961:        auto operator()( std::string const &description ) -> DerivedT & {
       26: 5962:            m_description = description;
       26: 5963:            return static_cast<DerivedT &>( *this );
        -: 5964:        }
------------------
        -: 5965:
        1: 5966:        auto optional() -> DerivedT & {
        1: 5967:            m_optionality = Optionality::Optional;
        1: 5968:            return static_cast<DerivedT &>( *this );
        -: 5969:        };
        -: 5970:
        -: 5971:        auto required() -> DerivedT & {
        -: 5972:            m_optionality = Optionality::Required;
        -: 5973:            return static_cast<DerivedT &>( *this );
        -: 5974:        };
        -: 5975:
    #####: 5976:        auto isOptional() const -> bool {
    #####: 5977:            return m_optionality == Optionality::Optional;
        -: 5978:        }
        -: 5979:
    #####: 5980:        auto cardinality() const -> size_t override {
    #####: 5981:            if( m_ref->isContainer() )
    #####: 5982:                return 0;
        -: 5983:            else
    #####: 5984:                return 1;
        -: 5985:        }
------------------
_ZNK5Catch5clara6detail13ParserRefImplINS1_3OptEE11cardinalityEv:
    #####: 5980:        auto cardinality() const -> size_t override {
    #####: 5981:            if( m_ref->isContainer() )
    #####: 5982:                return 0;
        -: 5983:            else
    #####: 5984:                return 1;
        -: 5985:        }
------------------
_ZNK5Catch5clara6detail13ParserRefImplINS1_3ArgEE11cardinalityEv:
    #####: 5980:        auto cardinality() const -> size_t override {
    #####: 5981:            if( m_ref->isContainer() )
    #####: 5982:                return 0;
        -: 5983:            else
    #####: 5984:                return 1;
        -: 5985:        }
------------------
        -: 5986:
    #####: 5987:        auto hint() const -> std::string { return m_hint; }
        -: 5988:    };
        -: 5989:
        -: 5990:    class ExeName : public ComposableParserImpl<ExeName> {
        -: 5991:        std::shared_ptr<std::string> m_name;
        -: 5992:        std::shared_ptr<BoundValueRefBase> m_ref;
        -: 5993:
        -: 5994:        template<typename LambdaT>
        -: 5995:        static auto makeRef(LambdaT const &lambda) -> std::shared_ptr<BoundValueRefBase> {
        -: 5996:            return std::make_shared<BoundLambda<LambdaT>>( lambda) ;
        -: 5997:        }
        -: 5998:
        -: 5999:    public:
        3: 6000:        ExeName() : m_name( std::make_shared<std::string>( "<executable>" ) ) {}
        -: 6001:
        1: 6002:        explicit ExeName( std::string &ref ) : ExeName() {
        1: 6003:            m_ref = std::make_shared<BoundValueRef<std::string>>( ref );
        1: 6004:        }
        -: 6005:
        -: 6006:        template<typename LambdaT>
        -: 6007:        explicit ExeName( LambdaT const& lambda ) : ExeName() {
        -: 6008:            m_ref = std::make_shared<BoundLambda<LambdaT>>( lambda );
        -: 6009:        }
        -: 6010:
        -: 6011:        // The exe name is not parsed out of the normal tokens, but is handled specially
    #####: 6012:        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {
    #####: 6013:            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
        -: 6014:        }
        -: 6015:
    #####: 6016:        auto name() const -> std::string { return *m_name; }
        1: 6017:        auto set( std::string const& newName ) -> ParserResult {
        -: 6018:
        1: 6019:            auto lastSlash = newName.find_last_of( "\\/" );
        -: 6020:            auto filename = ( lastSlash == std::string::npos )
        -: 6021:                    ? newName
       1*: 6022:                    : newName.substr( lastSlash+1 );
        -: 6023:
        1: 6024:            *m_name = filename;
        1: 6025:            if( m_ref )
        1: 6026:                return m_ref->setValue( filename );
        -: 6027:            else
    #####: 6028:                return ParserResult::ok( ParseResultType::Matched );
        1: 6029:        }
        -: 6030:    };
        -: 6031:
        -: 6032:    class Arg : public ParserRefImpl<Arg> {
        -: 6033:    public:
        -: 6034:        using ParserRefImpl::ParserRefImpl;
        -: 6035:
    #####: 6036:        auto parse( std::string const &, TokenStream const &tokens ) const -> InternalParseResult override {
    #####: 6037:            auto validationResult = validate();
    #####: 6038:            if( !validationResult )
    #####: 6039:                return InternalParseResult( validationResult );
        -: 6040:
    #####: 6041:            auto remainingTokens = tokens;
    #####: 6042:            auto const &token = *remainingTokens;
    #####: 6043:            if( token.type != TokenType::Argument )
    #####: 6044:                return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
        -: 6045:
    #####: 6046:            assert( !m_ref->isFlag() );
    #####: 6047:            auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );
        -: 6048:
    #####: 6049:            auto result = valueRef->setValue( remainingTokens->token );
    #####: 6050:            if( !result )
    #####: 6051:                return InternalParseResult( result );
        -: 6052:            else
    #####: 6053:                return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
    #####: 6054:        }
        -: 6055:    };
        -: 6056:
    #####: 6057:    inline auto normaliseOpt( std::string const &optName ) -> std::string {
        -: 6058:#ifdef CATCH_PLATFORM_WINDOWS
        -: 6059:        if( optName[0] == '/' )
        -: 6060:            return "-" + optName.substr( 1 );
        -: 6061:        else
        -: 6062:#endif
    #####: 6063:            return optName;
        -: 6064:    }
        -: 6065:
        -: 6066:    class Opt : public ParserRefImpl<Opt> {
        -: 6067:    protected:
        -: 6068:        std::vector<std::string> m_optNames;
        -: 6069:
        -: 6070:    public:
        -: 6071:        template<typename LambdaT>
        2: 6072:        explicit Opt( LambdaT const &ref ) : ParserRefImpl( std::make_shared<BoundFlagLambda<LambdaT>>( ref ) ) {}
------------------
_ZN5Catch5clara6detail3OptC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlbE6_EERKT_:
        1: 6072:        explicit Opt( LambdaT const &ref ) : ParserRefImpl( std::make_shared<BoundFlagLambda<LambdaT>>( ref ) ) {}
------------------
_ZN5Catch5clara6detail3OptC2IZNS1_4HelpC4ERbEUlbE_EERKT_:
        1: 6072:        explicit Opt( LambdaT const &ref ) : ParserRefImpl( std::make_shared<BoundFlagLambda<LambdaT>>( ref ) ) {}
------------------
        -: 6073:
       10: 6074:        explicit Opt( bool &ref ) : ParserRefImpl( std::make_shared<BoundFlagRef>( ref ) ) {}
        -: 6075:
        -: 6076:        template<typename LambdaT>
        9: 6077:        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
_ZN5Catch5clara6detail3OptC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE4_EERKT_SD_:
        1: 6077:        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
_ZN5Catch5clara6detail3OptC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE3_EERKT_SD_:
        1: 6077:        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
_ZN5Catch5clara6detail3OptC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE2_EERKT_SD_:
        1: 6077:        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
_ZN5Catch5clara6detail3OptC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE1_EERKT_SD_:
        1: 6077:        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
_ZN5Catch5clara6detail3OptC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE5_EERKT_SD_:
        1: 6077:        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
_ZN5Catch5clara6detail3OptC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE0_EERKT_SD_:
        1: 6077:        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
_ZN5Catch5clara6detail3OptC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlbE8_EERKT_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 6077:        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
_ZN5Catch5clara6detail3OptC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUlRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE_EERKT_SD_:
        1: 6077:        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
_ZN5Catch5clara6detail3OptC2IZNS_21makeCommandLineParserERNS_10ConfigDataEEUliE7_EERKT_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 6077:        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
        -: 6078:
        -: 6079:        template<typename T>
        5: 6080:        Opt( T &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
_ZN5Catch5clara6detail3OptC2IiEERT_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 6080:        Opt( T &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
_ZN5Catch5clara6detail3OptC2ISt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISA_EEEERT_RKSA_:
        2: 6080:        Opt( T &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
_ZN5Catch5clara6detail3OptC2INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEERT_RKS9_:
        2: 6080:        Opt( T &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
------------------
        -: 6081:
       45: 6082:        auto operator[]( std::string const &optName ) -> Opt & {
       45: 6083:            m_optNames.push_back( optName );
       45: 6084:            return *this;
        -: 6085:        }
        -: 6086:
    #####: 6087:        auto getHelpColumns() const -> std::vector<HelpColumns> {
    #####: 6088:            std::ostringstream oss;
    #####: 6089:            bool first = true;
    #####: 6090:            for( auto const &opt : m_optNames ) {
    #####: 6091:                if (first)
    #####: 6092:                    first = false;
        -: 6093:                else
    #####: 6094:                    oss << ", ";
    #####: 6095:                oss << opt;
        -: 6096:            }
    #####: 6097:            if( !m_hint.empty() )
    #####: 6098:                oss << " <" << m_hint << ">";
    #####: 6099:            return { { oss.str(), m_description } };
    #####: 6100:        }
        -: 6101:
    #####: 6102:        auto isMatch( std::string const &optToken ) const -> bool {
    #####: 6103:            auto normalisedToken = normaliseOpt( optToken );
    #####: 6104:            for( auto const &name : m_optNames ) {
    #####: 6105:                if( normaliseOpt( name ) == normalisedToken )
    #####: 6106:                    return true;
        -: 6107:            }
    #####: 6108:            return false;
    #####: 6109:        }
        -: 6110:
        -: 6111:        using ParserBase::parse;
        -: 6112:
    #####: 6113:        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {
    #####: 6114:            auto validationResult = validate();
    #####: 6115:            if( !validationResult )
    #####: 6116:                return InternalParseResult( validationResult );
        -: 6117:
    #####: 6118:            auto remainingTokens = tokens;
    #####: 6119:            if( remainingTokens && remainingTokens->type == TokenType::Option ) {
    #####: 6120:                auto const &token = *remainingTokens;
    #####: 6121:                if( isMatch(token.token ) ) {
    #####: 6122:                    if( m_ref->isFlag() ) {
    #####: 6123:                        auto flagRef = static_cast<detail::BoundFlagRefBase*>( m_ref.get() );
    #####: 6124:                        auto result = flagRef->setFlag( true );
    #####: 6125:                        if( !result )
    #####: 6126:                            return InternalParseResult( result );
    #####: 6127:                        if( result.value() == ParseResultType::ShortCircuitAll )
    #####: 6128:                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
    #####: 6129:                    } else {
    #####: 6130:                        auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );
    #####: 6131:                        ++remainingTokens;
    #####: 6132:                        if( !remainingTokens )
    #####: 6133:                            return InternalParseResult::runtimeError( "Expected argument following " + token.token );
    #####: 6134:                        auto const &argToken = *remainingTokens;
    #####: 6135:                        if( argToken.type != TokenType::Argument )
    #####: 6136:                            return InternalParseResult::runtimeError( "Expected argument following " + token.token );
    #####: 6137:                        auto result = valueRef->setValue( argToken.token );
    #####: 6138:                        if( !result )
    #####: 6139:                            return InternalParseResult( result );
    #####: 6140:                        if( result.value() == ParseResultType::ShortCircuitAll )
    #####: 6141:                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
    #####: 6142:                    }
    #####: 6143:                    return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
        -: 6144:                }
    #####: 6145:            }
    #####: 6146:            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
    #####: 6147:        }
        -: 6148:
    #####: 6149:        auto validate() const -> Result override {
    #####: 6150:            if( m_optNames.empty() )
    #####: 6151:                return Result::logicError( "No options supplied to Opt" );
    #####: 6152:            for( auto const &name : m_optNames ) {
    #####: 6153:                if( name.empty() )
    #####: 6154:                    return Result::logicError( "Option name cannot be empty" );
        -: 6155:#ifdef CATCH_PLATFORM_WINDOWS
        -: 6156:                if( name[0] != '-' && name[0] != '/' )
        -: 6157:                    return Result::logicError( "Option name must begin with '-' or '/'" );
        -: 6158:#else
    #####: 6159:                if( name[0] != '-' )
    #####: 6160:                    return Result::logicError( "Option name must begin with '-'" );
        -: 6161:#endif
        -: 6162:            }
    #####: 6163:            return ParserRefImpl::validate();
        -: 6164:        }
        -: 6165:    };
        -: 6166:
        -: 6167:    struct Help : Opt {
        1: 6168:        Help( bool &showHelpFlag )
       1*: 6169:        :   Opt([&]( bool flag ) {
    #####: 6170:                showHelpFlag = flag;
    #####: 6171:                return ParserResult::ok( ParseResultType::ShortCircuitAll );
        1: 6172:            })
        -: 6173:        {
        -: 6174:            static_cast<Opt &>( *this )
        2: 6175:                    ("display usage information")
        3: 6176:                    ["-?"]["-h"]["--help"]
        1: 6177:                    .optional();
        1: 6178:        }
        -: 6179:    };
        -: 6180:
        -: 6181:    struct Parser : ParserBase {
        -: 6182:
        -: 6183:        mutable ExeName m_exeName;
        -: 6184:        std::vector<Opt> m_options;
        -: 6185:        std::vector<Arg> m_args;
        -: 6186:
        1: 6187:        auto operator|=( ExeName const &exeName ) -> Parser & {
        1: 6188:            m_exeName = exeName;
        1: 6189:            return *this;
        -: 6190:        }
        -: 6191:
        1: 6192:        auto operator|=( Arg const &arg ) -> Parser & {
        1: 6193:            m_args.push_back(arg);
        1: 6194:            return *this;
        -: 6195:        }
        -: 6196:
       26: 6197:        auto operator|=( Opt const &opt ) -> Parser & {
       26: 6198:            m_options.push_back(opt);
       26: 6199:            return *this;
        -: 6200:        }
        -: 6201:
        -: 6202:        auto operator|=( Parser const &other ) -> Parser & {
        -: 6203:            m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());
        -: 6204:            m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());
        -: 6205:            return *this;
        -: 6206:        }
        -: 6207:
        -: 6208:        template<typename T>
       28: 6209:        auto operator|( T const &other ) const -> Parser {
       56: 6210:            return Parser( *this ) |= other;
        -: 6211:        }
------------------
_ZNK5Catch5clara6detail6ParserorINS1_4HelpEEES2_RKT_:
        1: 6209:        auto operator|( T const &other ) const -> Parser {
        2: 6210:            return Parser( *this ) |= other;
        -: 6211:        }
------------------
_ZNK5Catch5clara6detail6ParserorINS1_7ExeNameEEES2_RKT_:
        1: 6209:        auto operator|( T const &other ) const -> Parser {
        2: 6210:            return Parser( *this ) |= other;
        -: 6211:        }
------------------
_ZNK5Catch5clara6detail6ParserorINS1_3ArgEEES2_RKT_:
        1: 6209:        auto operator|( T const &other ) const -> Parser {
        2: 6210:            return Parser( *this ) |= other;
        -: 6211:        }
------------------
_ZNK5Catch5clara6detail6ParserorINS1_3OptEEES2_RKT_:
       25: 6209:        auto operator|( T const &other ) const -> Parser {
       50: 6210:            return Parser( *this ) |= other;
        -: 6211:        }
------------------
        -: 6212:
        -: 6213:        // Forward deprecated interface with '+' instead of '|'
        -: 6214:        template<typename T>
        -: 6215:        auto operator+=( T const &other ) -> Parser & { return operator|=( other ); }
        -: 6216:        template<typename T>
        -: 6217:        auto operator+( T const &other ) const -> Parser { return operator|( other ); }
        -: 6218:
    #####: 6219:        auto getHelpColumns() const -> std::vector<HelpColumns> {
    #####: 6220:            std::vector<HelpColumns> cols;
    #####: 6221:            for (auto const &o : m_options) {
    #####: 6222:                auto childCols = o.getHelpColumns();
    #####: 6223:                cols.insert( cols.end(), childCols.begin(), childCols.end() );
    #####: 6224:            }
    #####: 6225:            return cols;
    =====: 6226:        }
        -: 6227:
    #####: 6228:        void writeToStream( std::ostream &os ) const {
    #####: 6229:            if (!m_exeName.name().empty()) {
    #####: 6230:                os << "usage:\n" << "  " << m_exeName.name() << " ";
    #####: 6231:                bool required = true, first = true;
    #####: 6232:                for( auto const &arg : m_args ) {
    #####: 6233:                    if (first)
    #####: 6234:                        first = false;
        -: 6235:                    else
    #####: 6236:                        os << " ";
    #####: 6237:                    if( arg.isOptional() && required ) {
    #####: 6238:                        os << "[";
    #####: 6239:                        required = false;
        -: 6240:                    }
    #####: 6241:                    os << "<" << arg.hint() << ">";
    #####: 6242:                    if( arg.cardinality() == 0 )
    #####: 6243:                        os << " ... ";
        -: 6244:                }
    #####: 6245:                if( !required )
    #####: 6246:                    os << "]";
    #####: 6247:                if( !m_options.empty() )
    #####: 6248:                    os << " options";
    #####: 6249:                os << "\n\nwhere options are:" << std::endl;
        -: 6250:            }
        -: 6251:
    #####: 6252:            auto rows = getHelpColumns();
    #####: 6253:            size_t consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;
    #####: 6254:            size_t optWidth = 0;
    #####: 6255:            for( auto const &cols : rows )
    #####: 6256:                optWidth = (std::max)(optWidth, cols.left.size() + 2);
        -: 6257:
    #####: 6258:            optWidth = (std::min)(optWidth, consoleWidth/2);
        -: 6259:
    #####: 6260:            for( auto const &cols : rows ) {
        -: 6261:                auto row =
    #####: 6262:                        TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +
    #####: 6263:                        TextFlow::Spacer(4) +
    #####: 6264:                        TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );
    #####: 6265:                os << row << std::endl;
    #####: 6266:            }
    #####: 6267:        }
        -: 6268:
    #####: 6269:        friend auto operator<<( std::ostream &os, Parser const &parser ) -> std::ostream& {
    #####: 6270:            parser.writeToStream( os );
    #####: 6271:            return os;
        -: 6272:        }
        -: 6273:
    #####: 6274:        auto validate() const -> Result override {
    #####: 6275:            for( auto const &opt : m_options ) {
    #####: 6276:                auto result = opt.validate();
    #####: 6277:                if( !result )
    #####: 6278:                    return result;
    #####: 6279:            }
    #####: 6280:            for( auto const &arg : m_args ) {
    #####: 6281:                auto result = arg.validate();
    #####: 6282:                if( !result )
    #####: 6283:                    return result;
    #####: 6284:            }
    #####: 6285:            return Result::ok();
        -: 6286:        }
        -: 6287:
        -: 6288:        using ParserBase::parse;
        -: 6289:
        1: 6290:        auto parse( std::string const& exeName, TokenStream const &tokens ) const -> InternalParseResult override {
        -: 6291:
        -: 6292:            struct ParserInfo {
        -: 6293:                ParserBase const* parser = nullptr;
        -: 6294:                size_t count = 0;
        -: 6295:            };
        1: 6296:            const size_t totalParsers = m_options.size() + m_args.size();
       1*: 6297:            assert( totalParsers < 512 );
        -: 6298:            // ParserInfo parseInfos[totalParsers]; // <-- this is what we really want to do
        1: 6299:            ParserInfo parseInfos[512];
        -: 6300:
        -: 6301:            {
        1: 6302:                size_t i = 0;
       27: 6303:                for (auto const &opt : m_options) parseInfos[i++].parser = &opt;
        2: 6304:                for (auto const &arg : m_args) parseInfos[i++].parser = &arg;
        -: 6305:            }
        -: 6306:
        1: 6307:            m_exeName.set( exeName );
        -: 6308:
        1: 6309:            auto result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
        1: 6310:            while( result.value().remainingTokens() ) {
    #####: 6311:                bool tokenParsed = false;
        -: 6312:
    #####: 6313:                for( size_t i = 0; i < totalParsers; ++i ) {
    #####: 6314:                    auto&  parseInfo = parseInfos[i];
    #####: 6315:                    if( parseInfo.parser->cardinality() == 0 || parseInfo.count < parseInfo.parser->cardinality() ) {
    #####: 6316:                        result = parseInfo.parser->parse(exeName, result.value().remainingTokens());
    #####: 6317:                        if (!result)
    #####: 6318:                            return result;
    #####: 6319:                        if (result.value().type() != ParseResultType::NoMatch) {
    #####: 6320:                            tokenParsed = true;
    #####: 6321:                            ++parseInfo.count;
    #####: 6322:                            break;
        -: 6323:                        }
        -: 6324:                    }
        -: 6325:                }
        -: 6326:
    #####: 6327:                if( result.value().type() == ParseResultType::ShortCircuitAll )
    #####: 6328:                    return result;
    #####: 6329:                if( !tokenParsed )
    #####: 6330:                    return InternalParseResult::runtimeError( "Unrecognised token: " + result.value().remainingTokens()->token );
        -: 6331:            }
        -: 6332:            // !TBD Check missing required options
        1: 6333:            return result;
        1: 6334:        }
        -: 6335:    };
        -: 6336:
        -: 6337:    template<typename DerivedT>
        -: 6338:    template<typename T>
        1: 6339:    auto ComposableParserImpl<DerivedT>::operator|( T const &other ) const -> Parser {
        1: 6340:        return Parser() | static_cast<DerivedT const &>( *this ) | other;
        -: 6341:    }
        -: 6342:} // namespace detail
        -: 6343:
        -: 6344:// A Combined parser
        -: 6345:using detail::Parser;
        -: 6346:
        -: 6347:// A parser for options
        -: 6348:using detail::Opt;
        -: 6349:
        -: 6350:// A parser for arguments
        -: 6351:using detail::Arg;
        -: 6352:
        -: 6353:// Wrapper for argc, argv from main()
        -: 6354:using detail::Args;
        -: 6355:
        -: 6356:// Specifies the name of the executable
        -: 6357:using detail::ExeName;
        -: 6358:
        -: 6359:// Convenience wrapper for option parser that specifies the help option
        -: 6360:using detail::Help;
        -: 6361:
        -: 6362:// enum of result types from a parse
        -: 6363:using detail::ParseResultType;
        -: 6364:
        -: 6365:// Result type for parser operation
        -: 6366:using detail::ParserResult;
        -: 6367:
        -: 6368:}} // namespace Catch::clara
        -: 6369:
        -: 6370:// end clara.hpp
        -: 6371:#ifdef __clang__
        -: 6372:#pragma clang diagnostic pop
        -: 6373:#endif
        -: 6374:
        -: 6375:// Restore Clara's value for console width, if present
        -: 6376:#ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
        -: 6377:#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
        -: 6378:#undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
        -: 6379:#endif
        -: 6380:
        -: 6381:// end catch_clara.h
        -: 6382:namespace Catch {
        -: 6383:
        -: 6384:    clara::Parser makeCommandLineParser( ConfigData& config );
        -: 6385:
        -: 6386:} // end namespace Catch
        -: 6387:
        -: 6388:// end catch_commandline.h
        -: 6389:#include <fstream>
        -: 6390:#include <ctime>
        -: 6391:
        -: 6392:namespace Catch {
        -: 6393:
        1: 6394:    clara::Parser makeCommandLineParser( ConfigData& config ) {
        -: 6395:
        -: 6396:        using namespace clara;
        -: 6397:
    #####: 6398:        auto const setWarning = [&]( std::string const& warning ) {
    #####: 6399:                auto warningSet = [&]() {
    #####: 6400:                    if( warning == "NoAssertions" )
    #####: 6401:                        return WarnAbout::NoAssertions;
        -: 6402:
    #####: 6403:                    if ( warning == "NoTests" )
    #####: 6404:                        return WarnAbout::NoTests;
        -: 6405:
    #####: 6406:                    return WarnAbout::Nothing;
    #####: 6407:                }();
        -: 6408:
    #####: 6409:                if (warningSet == WarnAbout::Nothing)
    #####: 6410:                    return ParserResult::runtimeError( "Unrecognised warning: '" + warning + "'" );
    #####: 6411:                config.warnings = static_cast<WarnAbout::What>( config.warnings | warningSet );
    #####: 6412:                return ParserResult::ok( ParseResultType::Matched );
        1: 6413:            };
    #####: 6414:        auto const loadTestNamesFromFile = [&]( std::string const& filename ) {
    #####: 6415:                std::ifstream f( filename.c_str() );
    #####: 6416:                if( !f.is_open() )
    #####: 6417:                    return ParserResult::runtimeError( "Unable to load input file: '" + filename + "'" );
        -: 6418:
    #####: 6419:                std::string line;
    #####: 6420:                while( std::getline( f, line ) ) {
    #####: 6421:                    line = trim(line);
    #####: 6422:                    if( !line.empty() && !startsWith( line, '#' ) ) {
    #####: 6423:                        if( !startsWith( line, '"' ) )
    #####: 6424:                            line = '"' + line + '"';
    #####: 6425:                        config.testsOrTags.push_back( line + ',' );
        -: 6426:                    }
        -: 6427:                }
    #####: 6428:                return ParserResult::ok( ParseResultType::Matched );
    #####: 6429:            };
    #####: 6430:        auto const setTestOrder = [&]( std::string const& order ) {
    #####: 6431:                if( startsWith( "declared", order ) )
    #####: 6432:                    config.runOrder = RunTests::InDeclarationOrder;
    #####: 6433:                else if( startsWith( "lexical", order ) )
    #####: 6434:                    config.runOrder = RunTests::InLexicographicalOrder;
    #####: 6435:                else if( startsWith( "random", order ) )
    #####: 6436:                    config.runOrder = RunTests::InRandomOrder;
        -: 6437:                else
    #####: 6438:                    return clara::ParserResult::runtimeError( "Unrecognised ordering: '" + order + "'" );
    #####: 6439:                return ParserResult::ok( ParseResultType::Matched );
        1: 6440:            };
    #####: 6441:        auto const setRngSeed = [&]( std::string const& seed ) {
    #####: 6442:                if( seed != "time" )
    #####: 6443:                    return clara::detail::convertInto( seed, config.rngSeed );
    #####: 6444:                config.rngSeed = static_cast<unsigned int>( std::time(nullptr) );
    #####: 6445:                return ParserResult::ok( ParseResultType::Matched );
        1: 6446:            };
    #####: 6447:        auto const setColourUsage = [&]( std::string const& useColour ) {
    #####: 6448:                    auto mode = toLower( useColour );
        -: 6449:
    #####: 6450:                    if( mode == "yes" )
    #####: 6451:                        config.useColour = UseColour::Yes;
    #####: 6452:                    else if( mode == "no" )
    #####: 6453:                        config.useColour = UseColour::No;
    #####: 6454:                    else if( mode == "auto" )
    #####: 6455:                        config.useColour = UseColour::Auto;
        -: 6456:                    else
    #####: 6457:                        return ParserResult::runtimeError( "colour mode must be one of: auto, yes or no. '" + useColour + "' not recognised" );
    #####: 6458:                return ParserResult::ok( ParseResultType::Matched );
    #####: 6459:            };
    #####: 6460:        auto const setWaitForKeypress = [&]( std::string const& keypress ) {
    #####: 6461:                auto keypressLc = toLower( keypress );
    #####: 6462:                if( keypressLc == "start" )
    #####: 6463:                    config.waitForKeypress = WaitForKeypress::BeforeStart;
    #####: 6464:                else if( keypressLc == "exit" )
    #####: 6465:                    config.waitForKeypress = WaitForKeypress::BeforeExit;
    #####: 6466:                else if( keypressLc == "both" )
    #####: 6467:                    config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;
        -: 6468:                else
    #####: 6469:                    return ParserResult::runtimeError( "keypress argument must be one of: start, exit or both. '" + keypress + "' not recognised" );
    #####: 6470:            return ParserResult::ok( ParseResultType::Matched );
    #####: 6471:            };
    #####: 6472:        auto const setVerbosity = [&]( std::string const& verbosity ) {
    #####: 6473:            auto lcVerbosity = toLower( verbosity );
    #####: 6474:            if( lcVerbosity == "quiet" )
    #####: 6475:                config.verbosity = Verbosity::Quiet;
    #####: 6476:            else if( lcVerbosity == "normal" )
    #####: 6477:                config.verbosity = Verbosity::Normal;
    #####: 6478:            else if( lcVerbosity == "high" )
    #####: 6479:                config.verbosity = Verbosity::High;
        -: 6480:            else
    #####: 6481:                return ParserResult::runtimeError( "Unrecognised verbosity, '" + verbosity + "'" );
    #####: 6482:            return ParserResult::ok( ParseResultType::Matched );
    #####: 6483:        };
        -: 6484:
        -: 6485:        auto cli
        2: 6486:            = ExeName( config.processName )
        3: 6487:            | Help( config.showHelp )
        4: 6488:            | Opt( config.listTests )
        3: 6489:                ["-l"]["--list-tests"]
        2: 6490:                ( "list all/matching test cases" )
        4: 6491:            | Opt( config.listTags )
        3: 6492:                ["-t"]["--list-tags"]
        2: 6493:                ( "list all/matching tags" )
        4: 6494:            | Opt( config.showSuccessfulTests )
        3: 6495:                ["-s"]["--success"]
        2: 6496:                ( "include successful tests in output" )
        4: 6497:            | Opt( config.shouldDebugBreak )
        3: 6498:                ["-b"]["--break"]
        2: 6499:                ( "break into debugger on failure" )
        4: 6500:            | Opt( config.noThrow )
        3: 6501:                ["-e"]["--nothrow"]
        2: 6502:                ( "skip exception tests" )
        4: 6503:            | Opt( config.showInvisibles )
        3: 6504:                ["-i"]["--invisibles"]
        2: 6505:                ( "show invisibles (tabs, newlines)" )
        4: 6506:            | Opt( config.outputFilename, "filename" )
        3: 6507:                ["-o"]["--out"]
        2: 6508:                ( "output filename" )
        4: 6509:            | Opt( config.reporterNames, "name" )
        3: 6510:                ["-r"]["--reporter"]
        2: 6511:                ( "reporter to use (defaults to console)" )
        4: 6512:            | Opt( config.name, "name" )
        3: 6513:                ["-n"]["--name"]
        2: 6514:                ( "suite name" )
       4*: 6515:            | Opt( [&]( bool ){ config.abortAfter = 1; } )
        3: 6516:                ["-a"]["--abort"]
        2: 6517:                ( "abort at first failure" )
       4*: 6518:            | Opt( [&]( int x ){ config.abortAfter = x; }, "no. failures" )
        3: 6519:                ["-x"]["--abortx"]
        2: 6520:                ( "abort after x failures" )
        4: 6521:            | Opt( setWarning, "warning name" )
        3: 6522:                ["-w"]["--warn"]
        2: 6523:                ( "enable warnings" )
       4*: 6524:            | Opt( [&]( bool flag ) { config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; }, "yes|no" )
        3: 6525:                ["-d"]["--durations"]
        2: 6526:                ( "show test durations" )
        4: 6527:            | Opt( loadTestNamesFromFile, "filename" )
        3: 6528:                ["-f"]["--input-file"]
        2: 6529:                ( "load test names to run from a file" )
        4: 6530:            | Opt( config.filenamesAsTags )
        3: 6531:                ["-#"]["--filenames-as-tags"]
        2: 6532:                ( "adds a tag for the filename" )
        4: 6533:            | Opt( config.sectionsToRun, "section name" )
        3: 6534:                ["-c"]["--section"]
        2: 6535:                ( "specify section to run" )
        4: 6536:            | Opt( setVerbosity, "quiet|normal|high" )
        3: 6537:                ["-v"]["--verbosity"]
        2: 6538:                ( "set output verbosity" )
        4: 6539:            | Opt( config.listTestNamesOnly )
        3: 6540:                ["--list-test-names-only"]
        2: 6541:                ( "list all/matching test cases names only" )
        4: 6542:            | Opt( config.listReporters )
        3: 6543:                ["--list-reporters"]
        2: 6544:                ( "list all reporters" )
        4: 6545:            | Opt( setTestOrder, "decl|lex|rand" )
        3: 6546:                ["--order"]
        2: 6547:                ( "test case order (defaults to decl)" )
        4: 6548:            | Opt( setRngSeed, "'time'|number" )
        3: 6549:                ["--rng-seed"]
        2: 6550:                ( "set a specific seed for random numbers" )
        4: 6551:            | Opt( setColourUsage, "yes|no" )
        3: 6552:                ["--use-colour"]
        2: 6553:                ( "should output be colourised" )
        4: 6554:            | Opt( config.libIdentify )
        3: 6555:                ["--libidentify"]
        2: 6556:                ( "report name and version according to libidentify standard" )
        4: 6557:            | Opt( setWaitForKeypress, "start|exit|both" )
        3: 6558:                ["--wait-for-keypress"]
        2: 6559:                ( "waits for a keypress before exiting" )
        4: 6560:            | Opt( config.benchmarkResolutionMultiple, "multiplier" )
        3: 6561:                ["--benchmark-resolution-multiple"]
        2: 6562:                ( "multiple of clock resolution to run benchmarks" )
        -: 6563:
        2: 6564:            | Arg( config.testsOrTags, "test name|pattern|tags" )
        3: 6565:                ( "which test or tests to use" );
        -: 6566:
        2: 6567:        return cli;
        -: 6568:    }
        -: 6569:
        -: 6570:} // end namespace Catch
        -: 6571:// end catch_commandline.cpp
        -: 6572:// start catch_common.cpp
        -: 6573:
        -: 6574:#include <cstring>
        -: 6575:#include <ostream>
        -: 6576:
        -: 6577:namespace Catch {
        -: 6578:
    #####: 6579:    bool SourceLineInfo::empty() const noexcept {
    #####: 6580:        return file[0] == '\0';
        -: 6581:    }
       30: 6582:    bool SourceLineInfo::operator == ( SourceLineInfo const& other ) const noexcept {
      30*: 6583:        return line == other.line && (file == other.file || std::strcmp(file, other.file) == 0);
        -: 6584:    }
    #####: 6585:    bool SourceLineInfo::operator < ( SourceLineInfo const& other ) const noexcept {
    #####: 6586:        return line < other.line || ( line == other.line && (std::strcmp(file, other.file) < 0));
        -: 6587:    }
        -: 6588:
    #####: 6589:    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info ) {
        -: 6590:#ifndef __GNUG__
        -: 6591:        os << info.file << '(' << info.line << ')';
        -: 6592:#else
    #####: 6593:        os << info.file << ':' << info.line;
        -: 6594:#endif
    #####: 6595:        return os;
        -: 6596:    }
        -: 6597:
    #####: 6598:    std::string StreamEndStop::operator+() const {
    #####: 6599:        return std::string();
        -: 6600:    }
        -: 6601:
       41: 6602:    NonCopyable::NonCopyable() = default;
      41*: 6603:    NonCopyable::~NonCopyable() = default;
------------------
_ZN5Catch11NonCopyableD0Ev:
    #####: 6603:    NonCopyable::~NonCopyable() = default;
------------------
_ZN5Catch11NonCopyableD2Ev:
       41: 6603:    NonCopyable::~NonCopyable() = default;
------------------
        -: 6604:
        -: 6605:}
        -: 6606:// end catch_common.cpp
        -: 6607:// start catch_config.cpp
        -: 6608:
        -: 6609:// start catch_enforce.h
        -: 6610:
        -: 6611:#include <stdexcept>
        -: 6612:
        -: 6613:#define CATCH_PREPARE_EXCEPTION( type, msg ) \
        -: 6614:    type( ( Catch::ReusableStringStream() << msg ).str() )
        -: 6615:#define CATCH_INTERNAL_ERROR( msg ) \
        -: 6616:    throw CATCH_PREPARE_EXCEPTION( std::logic_error, CATCH_INTERNAL_LINEINFO << ": Internal Catch error: " << msg);
        -: 6617:#define CATCH_ERROR( msg ) \
        -: 6618:    throw CATCH_PREPARE_EXCEPTION( std::domain_error, msg )
        -: 6619:#define CATCH_ENFORCE( condition, msg ) \
        -: 6620:    do{ if( !(condition) ) CATCH_ERROR( msg ); } while(false)
        -: 6621:
        -: 6622:// end catch_enforce.h
        -: 6623:namespace Catch {
        -: 6624:
        1: 6625:    Config::Config( ConfigData const& data )
        1: 6626:    :   m_data( data ),
        1: 6627:        m_stream( openStream() )
        -: 6628:    {
        1: 6629:        TestSpecParser parser(ITagAliasRegistry::get());
        1: 6630:        if (data.testsOrTags.empty()) {
        1: 6631:            parser.parse("~[.]"); // All not hidden tests
        -: 6632:        }
        -: 6633:        else {
    #####: 6634:            m_hasTestFilters = true;
    #####: 6635:            for( auto const& testOrTags : data.testsOrTags )
    #####: 6636:                parser.parse( testOrTags );
        -: 6637:        }
        1: 6638:        m_testSpec = parser.testSpec();
        1: 6639:    }
        -: 6640:
    #####: 6641:    std::string const& Config::getFilename() const {
    #####: 6642:        return m_data.outputFilename ;
        -: 6643:    }
        -: 6644:
        1: 6645:    bool Config::listTests() const          { return m_data.listTests; }
        1: 6646:    bool Config::listTestNamesOnly() const  { return m_data.listTestNamesOnly; }
        1: 6647:    bool Config::listTags() const           { return m_data.listTags; }
        1: 6648:    bool Config::listReporters() const      { return m_data.listReporters; }
        -: 6649:
    #####: 6650:    std::string Config::getProcessName() const { return m_data.processName; }
        -: 6651:
        1: 6652:    std::vector<std::string> const& Config::getReporterNames() const { return m_data.reporterNames; }
    #####: 6653:    std::vector<std::string> const& Config::getTestsOrTags() const { return m_data.testsOrTags; }
        4: 6654:    std::vector<std::string> const& Config::getSectionsToRun() const { return m_data.sectionsToRun; }
        -: 6655:
        1: 6656:    TestSpec const& Config::testSpec() const { return m_testSpec; }
    #####: 6657:    bool Config::hasTestFilters() const { return m_hasTestFilters; }
        -: 6658:
    #####: 6659:    bool Config::showHelp() const { return m_data.showHelp; }
        -: 6660:
        -: 6661:    // IConfig interface
        4: 6662:    bool Config::allowThrows() const                   { return !m_data.noThrow; }
        1: 6663:    std::ostream& Config::stream() const               { return m_stream->stream(); }
       3*: 6664:    std::string Config::name() const                   { return m_data.name.empty() ? m_data.processName : m_data.name; }
        1: 6665:    bool Config::includeSuccessfulResults() const      { return m_data.showSuccessfulTests; }
    #####: 6666:    bool Config::warnAboutMissingAssertions() const    { return !!(m_data.warnings & WarnAbout::NoAssertions); }
        1: 6667:    bool Config::warnAboutNoTests() const              { return !!(m_data.warnings & WarnAbout::NoTests); }
       19: 6668:    ShowDurations::OrNot Config::showDurations() const { return m_data.showDurations; }
        3: 6669:    RunTests::InWhatOrder Config::runOrder() const     { return m_data.runOrder; }
       11: 6670:    unsigned int Config::rngSeed() const               { return m_data.rngSeed; }
    #####: 6671:    int Config::benchmarkResolutionMultiple() const    { return m_data.benchmarkResolutionMultiple; }
        1: 6672:    UseColour::YesOrNo Config::useColour() const       { return m_data.useColour; }
    #####: 6673:    bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }
       16: 6674:    int Config::abortAfter() const                     { return m_data.abortAfter; }
    #####: 6675:    bool Config::showInvisibles() const                { return m_data.showInvisibles; }
        1: 6676:    Verbosity Config::verbosity() const                { return m_data.verbosity; }
        -: 6677:
        1: 6678:    IStream const* Config::openStream() {
        1: 6679:        return Catch::makeStream(m_data.outputFilename);
        -: 6680:    }
        -: 6681:
        -: 6682:} // end namespace Catch
        -: 6683:// end catch_config.cpp
        -: 6684:// start catch_console_colour.cpp
        -: 6685:
        -: 6686:#if defined(__clang__)
        -: 6687:#    pragma clang diagnostic push
        -: 6688:#    pragma clang diagnostic ignored "-Wexit-time-destructors"
        -: 6689:#endif
        -: 6690:
        -: 6691:// start catch_errno_guard.h
        -: 6692:
        -: 6693:namespace Catch {
        -: 6694:
        -: 6695:    class ErrnoGuard {
        -: 6696:    public:
        -: 6697:        ErrnoGuard();
        -: 6698:        ~ErrnoGuard();
        -: 6699:    private:
        -: 6700:        int m_oldErrno;
        -: 6701:    };
        -: 6702:
        -: 6703:}
        -: 6704:
        -: 6705:// end catch_errno_guard.h
        -: 6706:#include <sstream>
        -: 6707:
        -: 6708:namespace Catch {
        -: 6709:    namespace {
        -: 6710:
        -: 6711:        struct IColourImpl {
        1: 6712:            virtual ~IColourImpl() = default;
        -: 6713:            virtual void use( Colour::Code _colourCode ) = 0;
        -: 6714:        };
        -: 6715:
        -: 6716:        struct NoColourImpl : IColourImpl {
    #####: 6717:            void use( Colour::Code ) {}
        -: 6718:
    #####: 6719:            static IColourImpl* instance() {
    #####: 6720:                static NoColourImpl s_instance;
    #####: 6721:                return &s_instance;
        -: 6722:            }
        -: 6723:        };
        -: 6724:
        -: 6725:    } // anon namespace
        -: 6726:} // namespace Catch
        -: 6727:
        -: 6728:#if !defined( CATCH_CONFIG_COLOUR_NONE ) && !defined( CATCH_CONFIG_COLOUR_WINDOWS ) && !defined( CATCH_CONFIG_COLOUR_ANSI )
        -: 6729:#   ifdef CATCH_PLATFORM_WINDOWS
        -: 6730:#       define CATCH_CONFIG_COLOUR_WINDOWS
        -: 6731:#   else
        -: 6732:#       define CATCH_CONFIG_COLOUR_ANSI
        -: 6733:#   endif
        -: 6734:#endif
        -: 6735:
        -: 6736:#if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) /////////////////////////////////////////
        -: 6737:
        -: 6738:namespace Catch {
        -: 6739:namespace {
        -: 6740:
        -: 6741:    class Win32ColourImpl : public IColourImpl {
        -: 6742:    public:
        -: 6743:        Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )
        -: 6744:        {
        -: 6745:            CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
        -: 6746:            GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );
        -: 6747:            originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );
        -: 6748:            originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );
        -: 6749:        }
        -: 6750:
        -: 6751:        virtual void use( Colour::Code _colourCode ) override {
        -: 6752:            switch( _colourCode ) {
        -: 6753:                case Colour::None:      return setTextAttribute( originalForegroundAttributes );
        -: 6754:                case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
        -: 6755:                case Colour::Red:       return setTextAttribute( FOREGROUND_RED );
        -: 6756:                case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );
        -: 6757:                case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );
        -: 6758:                case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );
        -: 6759:                case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );
        -: 6760:                case Colour::Grey:      return setTextAttribute( 0 );
        -: 6761:
        -: 6762:                case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );
        -: 6763:                case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );
        -: 6764:                case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );
        -: 6765:                case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
        -: 6766:                case Colour::BrightYellow:  return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );
        -: 6767:
        -: 6768:                case Colour::Bright: CATCH_INTERNAL_ERROR( "not a colour" );
        -: 6769:
        -: 6770:                default:
        -: 6771:                    CATCH_ERROR( "Unknown colour requested" );
        -: 6772:            }
        -: 6773:        }
        -: 6774:
        -: 6775:    private:
        -: 6776:        void setTextAttribute( WORD _textAttribute ) {
        -: 6777:            SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );
        -: 6778:        }
        -: 6779:        HANDLE stdoutHandle;
        -: 6780:        WORD originalForegroundAttributes;
        -: 6781:        WORD originalBackgroundAttributes;
        -: 6782:    };
        -: 6783:
        -: 6784:    IColourImpl* platformColourInstance() {
        -: 6785:        static Win32ColourImpl s_instance;
        -: 6786:
        -: 6787:        IConfigPtr config = getCurrentContext().getConfig();
        -: 6788:        UseColour::YesOrNo colourMode = config
        -: 6789:            ? config->useColour()
        -: 6790:            : UseColour::Auto;
        -: 6791:        if( colourMode == UseColour::Auto )
        -: 6792:            colourMode = UseColour::Yes;
        -: 6793:        return colourMode == UseColour::Yes
        -: 6794:            ? &s_instance
        -: 6795:            : NoColourImpl::instance();
        -: 6796:    }
        -: 6797:
        -: 6798:} // end anon namespace
        -: 6799:} // end namespace Catch
        -: 6800:
        -: 6801:#elif defined( CATCH_CONFIG_COLOUR_ANSI ) //////////////////////////////////////
        -: 6802:
        -: 6803:#include <unistd.h>
        -: 6804:
        -: 6805:namespace Catch {
        -: 6806:namespace {
        -: 6807:
        -: 6808:    // use POSIX/ ANSI console terminal codes
        -: 6809:    // Thanks to Adam Strzelecki for original contribution
        -: 6810:    // (http://github.com/nanoant)
        -: 6811:    // https://github.com/philsquared/Catch/pull/131
        -: 6812:    class PosixColourImpl : public IColourImpl {
        -: 6813:    public:
        8: 6814:        virtual void use( Colour::Code _colourCode ) override {
        8: 6815:            switch( _colourCode ) {
        4: 6816:                case Colour::None:
        4: 6817:                case Colour::White:     return setColour( "[0m" );
    #####: 6818:                case Colour::Red:       return setColour( "[0;31m" );
    #####: 6819:                case Colour::Green:     return setColour( "[0;32m" );
    #####: 6820:                case Colour::Blue:      return setColour( "[0;34m" );
    #####: 6821:                case Colour::Cyan:      return setColour( "[0;36m" );
    #####: 6822:                case Colour::Yellow:    return setColour( "[0;33m" );
    #####: 6823:                case Colour::Grey:      return setColour( "[1;30m" );
        -: 6824:
    #####: 6825:                case Colour::LightGrey:     return setColour( "[0;37m" );
        1: 6826:                case Colour::BrightRed:     return setColour( "[1;31m" );
        2: 6827:                case Colour::BrightGreen:   return setColour( "[1;32m" );
    #####: 6828:                case Colour::BrightWhite:   return setColour( "[1;37m" );
        1: 6829:                case Colour::BrightYellow:  return setColour( "[1;33m" );
        -: 6830:
    #####: 6831:                case Colour::Bright: CATCH_INTERNAL_ERROR( "not a colour" );
    #####: 6832:                default: CATCH_INTERNAL_ERROR( "Unknown colour requested" );
        -: 6833:            }
        -: 6834:        }
        1: 6835:        static IColourImpl* instance() {
        1: 6836:            static PosixColourImpl s_instance;
        1: 6837:            return &s_instance;
        -: 6838:        }
        -: 6839:
        -: 6840:    private:
        8: 6841:        void setColour( const char* _escapeCode ) {
        8: 6842:            Catch::cout() << '\033' << _escapeCode;
        8: 6843:        }
        -: 6844:    };
        -: 6845:
        1: 6846:    bool useColourOnPlatform() {
        -: 6847:        return
        -: 6848:#ifdef CATCH_PLATFORM_MAC
        -: 6849:            !isDebuggerActive() &&
        -: 6850:#endif
        -: 6851:#if !(defined(__DJGPP__) && defined(__STRICT_ANSI__))
        1: 6852:            isatty(STDOUT_FILENO)
        -: 6853:#else
        -: 6854:            false
        -: 6855:#endif
        -: 6856:            ;
        -: 6857:    }
        1: 6858:    IColourImpl* platformColourInstance() {
        1: 6859:        ErrnoGuard guard;
        1: 6860:        IConfigPtr config = getCurrentContext().getConfig();
        -: 6861:        UseColour::YesOrNo colourMode = config
       1*: 6862:            ? config->useColour()
        1: 6863:            : UseColour::Auto;
        1: 6864:        if( colourMode == UseColour::Auto )
        2: 6865:            colourMode = useColourOnPlatform()
       1*: 6866:                ? UseColour::Yes
        -: 6867:                : UseColour::No;
        -: 6868:        return colourMode == UseColour::Yes
        1: 6869:            ? PosixColourImpl::instance()
       1*: 6870:            : NoColourImpl::instance();
        1: 6871:    }
        -: 6872:
        -: 6873:} // end anon namespace
        -: 6874:} // end namespace Catch
        -: 6875:
        -: 6876:#else  // not Windows or ANSI ///////////////////////////////////////////////
        -: 6877:
        -: 6878:namespace Catch {
        -: 6879:
        -: 6880:    static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }
        -: 6881:
        -: 6882:} // end namespace Catch
        -: 6883:
        -: 6884:#endif // Windows/ ANSI/ None
        -: 6885:
        -: 6886:namespace Catch {
        -: 6887:
        4: 6888:    Colour::Colour( Code _colourCode ) { use( _colourCode ); }
    #####: 6889:    Colour::Colour( Colour&& rhs ) noexcept {
    #####: 6890:        m_moved = rhs.m_moved;
    #####: 6891:        rhs.m_moved = true;
    #####: 6892:    }
    #####: 6893:    Colour& Colour::operator=( Colour&& rhs ) noexcept {
    #####: 6894:        m_moved = rhs.m_moved;
    #####: 6895:        rhs.m_moved  = true;
    #####: 6896:        return *this;
        -: 6897:    }
        -: 6898:
        4: 6899:    Colour::~Colour(){ if( !m_moved ) use( None ); }
        -: 6900:
        8: 6901:    void Colour::use( Code _colourCode ) {
        8: 6902:        static IColourImpl* impl = platformColourInstance();
        8: 6903:        impl->use( _colourCode );
        8: 6904:    }
        -: 6905:
        4: 6906:    std::ostream& operator << ( std::ostream& os, Colour const& ) {
        4: 6907:        return os;
        -: 6908:    }
        -: 6909:
        -: 6910:} // end namespace Catch
        -: 6911:
        -: 6912:#if defined(__clang__)
        -: 6913:#    pragma clang diagnostic pop
        -: 6914:#endif
        -: 6915:
        -: 6916:// end catch_console_colour.cpp
        -: 6917:// start catch_context.cpp
        -: 6918:
        -: 6919:namespace Catch {
        -: 6920:
        -: 6921:    class Context : public IMutableContext, NonCopyable {
        -: 6922:
        -: 6923:    public: // IContext
       83: 6924:        virtual IResultCapture* getResultCapture() override {
       83: 6925:            return m_resultCapture;
        -: 6926:        }
    #####: 6927:        virtual IRunner* getRunner() override {
    #####: 6928:            return m_runner;
        -: 6929:        }
        -: 6930:
        1: 6931:        virtual IConfigPtr const& getConfig() const override {
        1: 6932:            return m_config;
        -: 6933:        }
        -: 6934:
        -: 6935:        virtual ~Context() override;
        -: 6936:
        -: 6937:    public: // IMutableContext
        1: 6938:        virtual void setResultCapture( IResultCapture* resultCapture ) override {
        1: 6939:            m_resultCapture = resultCapture;
        1: 6940:        }
        1: 6941:        virtual void setRunner( IRunner* runner ) override {
        1: 6942:            m_runner = runner;
        1: 6943:        }
        1: 6944:        virtual void setConfig( IConfigPtr const& config ) override {
        1: 6945:            m_config = config;
        1: 6946:        }
        -: 6947:
        -: 6948:        friend IMutableContext& getCurrentMutableContext();
        -: 6949:
        -: 6950:    private:
        -: 6951:        IConfigPtr m_config;
        -: 6952:        IRunner* m_runner = nullptr;
        -: 6953:        IResultCapture* m_resultCapture = nullptr;
        -: 6954:    };
        -: 6955:
        -: 6956:    IMutableContext *IMutableContext::currentContext = nullptr;
        -: 6957:
        1: 6958:    void IMutableContext::createContext()
        -: 6959:    {
        1: 6960:        currentContext = new Context();
        1: 6961:    }
        -: 6962:
        1: 6963:    void cleanUpContext() {
        1: 6964:        delete IMutableContext::currentContext;
        1: 6965:        IMutableContext::currentContext = nullptr;
        1: 6966:    }
       1*: 6967:    IContext::~IContext() = default;
------------------
_ZN5Catch8IContextD0Ev:
    #####: 6967:    IContext::~IContext() = default;
------------------
_ZN5Catch8IContextD2Ev:
        1: 6967:    IContext::~IContext() = default;
------------------
       1*: 6968:    IMutableContext::~IMutableContext() = default;
------------------
_ZN5Catch15IMutableContextD0Ev:
    #####: 6968:    IMutableContext::~IMutableContext() = default;
------------------
_ZN5Catch15IMutableContextD2Ev:
        1: 6968:    IMutableContext::~IMutableContext() = default;
------------------
        2: 6969:    Context::~Context() = default;
------------------
_ZN5Catch7ContextD0Ev:
        1: 6969:    Context::~Context() = default;
------------------
_ZN5Catch7ContextD2Ev:
        1: 6969:    Context::~Context() = default;
------------------
        -: 6970:}
        -: 6971:// end catch_context.cpp
        -: 6972:// start catch_debug_console.cpp
        -: 6973:
        -: 6974:// start catch_debug_console.h
        -: 6975:
        -: 6976:#include <string>
        -: 6977:
        -: 6978:namespace Catch {
        -: 6979:    void writeToDebugConsole( std::string const& text );
        -: 6980:}
        -: 6981:
        -: 6982:// end catch_debug_console.h
        -: 6983:#ifdef CATCH_PLATFORM_WINDOWS
        -: 6984:
        -: 6985:    namespace Catch {
        -: 6986:        void writeToDebugConsole( std::string const& text ) {
        -: 6987:            ::OutputDebugStringA( text.c_str() );
        -: 6988:        }
        -: 6989:    }
        -: 6990:
        -: 6991:#else
        -: 6992:
        -: 6993:    namespace Catch {
    #####: 6994:        void writeToDebugConsole( std::string const& text ) {
        -: 6995:            // !TBD: Need a version for Mac/ XCode and other IDEs
    #####: 6996:            Catch::cout() << text;
    #####: 6997:        }
        -: 6998:    }
        -: 6999:
        -: 7000:#endif // Platform
        -: 7001:// end catch_debug_console.cpp
        -: 7002:// start catch_debugger.cpp
        -: 7003:
        -: 7004:#ifdef CATCH_PLATFORM_MAC
        -: 7005:
        -: 7006:#  include <assert.h>
        -: 7007:#  include <stdbool.h>
        -: 7008:#  include <sys/types.h>
        -: 7009:#  include <unistd.h>
        -: 7010:#  include <sys/sysctl.h>
        -: 7011:#  include <cstddef>
        -: 7012:#  include <ostream>
        -: 7013:
        -: 7014:namespace Catch {
        -: 7015:
        -: 7016:        // The following function is taken directly from the following technical note:
        -: 7017:        // http://developer.apple.com/library/mac/#qa/qa2004/qa1361.html
        -: 7018:
        -: 7019:        // Returns true if the current process is being debugged (either
        -: 7020:        // running under the debugger or has a debugger attached post facto).
        -: 7021:        bool isDebuggerActive(){
        -: 7022:
        -: 7023:            int                 mib[4];
        -: 7024:            struct kinfo_proc   info;
        -: 7025:            std::size_t         size;
        -: 7026:
        -: 7027:            // Initialize the flags so that, if sysctl fails for some bizarre
        -: 7028:            // reason, we get a predictable result.
        -: 7029:
        -: 7030:            info.kp_proc.p_flag = 0;
        -: 7031:
        -: 7032:            // Initialize mib, which tells sysctl the info we want, in this case
        -: 7033:            // we're looking for information about a specific process ID.
        -: 7034:
        -: 7035:            mib[0] = CTL_KERN;
        -: 7036:            mib[1] = KERN_PROC;
        -: 7037:            mib[2] = KERN_PROC_PID;
        -: 7038:            mib[3] = getpid();
        -: 7039:
        -: 7040:            // Call sysctl.
        -: 7041:
        -: 7042:            size = sizeof(info);
        -: 7043:            if( sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, nullptr, 0) != 0 ) {
        -: 7044:                Catch::cerr() << "\n** Call to sysctl failed - unable to determine if debugger is active **\n" << std::endl;
        -: 7045:                return false;
        -: 7046:            }
        -: 7047:
        -: 7048:            // We're being debugged if the P_TRACED flag is set.
        -: 7049:
        -: 7050:            return ( (info.kp_proc.p_flag & P_TRACED) != 0 );
        -: 7051:        }
        -: 7052:    } // namespace Catch
        -: 7053:
        -: 7054:#elif defined(CATCH_PLATFORM_LINUX)
        -: 7055:    #include <fstream>
        -: 7056:    #include <string>
        -: 7057:
        -: 7058:    namespace Catch{
        -: 7059:        // The standard POSIX way of detecting a debugger is to attempt to
        -: 7060:        // ptrace() the process, but this needs to be done from a child and not
        -: 7061:        // this process itself to still allow attaching to this process later
        -: 7062:        // if wanted, so is rather heavy. Under Linux we have the PID of the
        -: 7063:        // "debugger" (which doesn't need to be gdb, of course, it could also
        -: 7064:        // be strace, for example) in /proc/$PID/status, so just get it from
        -: 7065:        // there instead.
    #####: 7066:        bool isDebuggerActive(){
        -: 7067:            // Libstdc++ has a bug, where std::ifstream sets errno to 0
        -: 7068:            // This way our users can properly assert over errno values
    #####: 7069:            ErrnoGuard guard;
    #####: 7070:            std::ifstream in("/proc/self/status");
    #####: 7071:            for( std::string line; std::getline(in, line); ) {
        -: 7072:                static const int PREFIX_LEN = 11;
    #####: 7073:                if( line.compare(0, PREFIX_LEN, "TracerPid:\t") == 0 ) {
        -: 7074:                    // We're traced if the PID is not 0 and no other PID starts
        -: 7075:                    // with 0 digit, so it's enough to check for just a single
        -: 7076:                    // character.
    #####: 7077:                    return line.length() > PREFIX_LEN && line[PREFIX_LEN] != '0';
        -: 7078:                }
    #####: 7079:            }
        -: 7080:
    #####: 7081:            return false;
    #####: 7082:        }
        -: 7083:    } // namespace Catch
        -: 7084:#elif defined(_MSC_VER)
        -: 7085:    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
        -: 7086:    namespace Catch {
        -: 7087:        bool isDebuggerActive() {
        -: 7088:            return IsDebuggerPresent() != 0;
        -: 7089:        }
        -: 7090:    }
        -: 7091:#elif defined(__MINGW32__)
        -: 7092:    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
        -: 7093:    namespace Catch {
        -: 7094:        bool isDebuggerActive() {
        -: 7095:            return IsDebuggerPresent() != 0;
        -: 7096:        }
        -: 7097:    }
        -: 7098:#else
        -: 7099:    namespace Catch {
        -: 7100:       bool isDebuggerActive() { return false; }
        -: 7101:    }
        -: 7102:#endif // Platform
        -: 7103:// end catch_debugger.cpp
        -: 7104:// start catch_decomposer.cpp
        -: 7105:
        -: 7106:namespace Catch {
        -: 7107:
      41*: 7108:    ITransientExpression::~ITransientExpression() = default;
------------------
_ZN5Catch20ITransientExpressionD0Ev:
    #####: 7108:    ITransientExpression::~ITransientExpression() = default;
------------------
_ZN5Catch20ITransientExpressionD2Ev:
       41: 7108:    ITransientExpression::~ITransientExpression() = default;
------------------
        -: 7109:
    #####: 7110:    void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs ) {
    #####: 7111:        if( lhs.size() + rhs.size() < 40 &&
    #####: 7112:                lhs.find('\n') == std::string::npos &&
    #####: 7113:                rhs.find('\n') == std::string::npos )
    #####: 7114:            os << lhs << " " << op << " " << rhs;
        -: 7115:        else
    #####: 7116:            os << lhs << "\n" << op << "\n" << rhs;
    #####: 7117:    }
        -: 7118:}
        -: 7119:// end catch_decomposer.cpp
        -: 7120:// start catch_errno_guard.cpp
        -: 7121:
        -: 7122:#include <cerrno>
        -: 7123:
        -: 7124:namespace Catch {
        1: 7125:        ErrnoGuard::ErrnoGuard():m_oldErrno(errno){}
        1: 7126:        ErrnoGuard::~ErrnoGuard() { errno = m_oldErrno; }
        -: 7127:}
        -: 7128:// end catch_errno_guard.cpp
        -: 7129:// start catch_exception_translator_registry.cpp
        -: 7130:
        -: 7131:// start catch_exception_translator_registry.h
        -: 7132:
        -: 7133:#include <vector>
        -: 7134:#include <string>
        -: 7135:#include <memory>
        -: 7136:
        -: 7137:namespace Catch {
        -: 7138:
        -: 7139:    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
        -: 7140:    public:
        -: 7141:        ~ExceptionTranslatorRegistry();
        -: 7142:        virtual void registerTranslator( const IExceptionTranslator* translator );
        -: 7143:        virtual std::string translateActiveException() const override;
        -: 7144:        std::string tryTranslators() const;
        -: 7145:
        -: 7146:    private:
        -: 7147:        std::vector<std::unique_ptr<IExceptionTranslator const>> m_translators;
        -: 7148:    };
        -: 7149:}
        -: 7150:
        -: 7151:// end catch_exception_translator_registry.h
        -: 7152:#ifdef __OBJC__
        -: 7153:#import "Foundation/Foundation.h"
        -: 7154:#endif
        -: 7155:
        -: 7156:namespace Catch {
        -: 7157:
       1*: 7158:    ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() {
       1*: 7159:    }
------------------
_ZN5Catch27ExceptionTranslatorRegistryD0Ev:
    #####: 7158:    ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() {
    #####: 7159:    }
------------------
_ZN5Catch27ExceptionTranslatorRegistryD2Ev:
        1: 7158:    ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() {
        1: 7159:    }
------------------
        -: 7160:
    #####: 7161:    void ExceptionTranslatorRegistry::registerTranslator( const IExceptionTranslator* translator ) {
    #####: 7162:        m_translators.push_back( std::unique_ptr<const IExceptionTranslator>( translator ) );
    #####: 7163:    }
        -: 7164:
    #####: 7165:    std::string ExceptionTranslatorRegistry::translateActiveException() const {
        -: 7166:        try {
        -: 7167:#ifdef __OBJC__
        -: 7168:            // In Objective-C try objective-c exceptions first
        -: 7169:            @try {
        -: 7170:                return tryTranslators();
        -: 7171:            }
        -: 7172:            @catch (NSException *exception) {
        -: 7173:                return Catch::Detail::stringify( [exception description] );
        -: 7174:            }
        -: 7175:#else
        -: 7176:            // Compiling a mixed mode project with MSVC means that CLR
        -: 7177:            // exceptions will be caught in (...) as well. However, these
        -: 7178:            // do not fill-in std::current_exception and thus lead to crash
        -: 7179:            // when attempting rethrow.
        -: 7180:            // /EHa switch also causes structured exceptions to be caught
        -: 7181:            // here, but they fill-in current_exception properly, so
        -: 7182:            // at worst the output should be a little weird, instead of
        -: 7183:            // causing a crash.
    #####: 7184:            if (std::current_exception() == nullptr) {
    #####: 7185:                return "Non C++ exception. Possibly a CLR exception.";
        -: 7186:            }
    #####: 7187:            return tryTranslators();
        -: 7188:#endif
        -: 7189:        }
    =====: 7190:        catch( TestFailureException& ) {
    =====: 7191:            std::rethrow_exception(std::current_exception());
    =====: 7192:        }
    =====: 7193:        catch( std::exception& ex ) {
    =====: 7194:            return ex.what();
    =====: 7195:        }
    =====: 7196:        catch( std::string& msg ) {
    =====: 7197:            return msg;
    =====: 7198:        }
    =====: 7199:        catch( const char* msg ) {
    =====: 7200:            return msg;
    =====: 7201:        }
    =====: 7202:        catch(...) {
    =====: 7203:            return "Unknown exception";
    =====: 7204:        }
        -: 7205:    }
        -: 7206:
    #####: 7207:    std::string ExceptionTranslatorRegistry::tryTranslators() const {
    #####: 7208:        if( m_translators.empty() )
    #####: 7209:            std::rethrow_exception(std::current_exception());
        -: 7210:        else
    #####: 7211:            return m_translators[0]->translate( m_translators.begin()+1, m_translators.end() );
        -: 7212:    }
        -: 7213:}
        -: 7214:// end catch_exception_translator_registry.cpp
        -: 7215:// start catch_fatal_condition.cpp
        -: 7216:
        -: 7217:#if defined(__GNUC__)
        -: 7218:#    pragma GCC diagnostic push
        -: 7219:#    pragma GCC diagnostic ignored "-Wmissing-field-initializers"
        -: 7220:#endif
        -: 7221:
        -: 7222:#if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )
        -: 7223:
        -: 7224:namespace {
        -: 7225:    // Report the error condition
    #####: 7226:    void reportFatal( char const * const message ) {
    #####: 7227:        Catch::getCurrentContext().getResultCapture()->handleFatalErrorCondition( message );
    #####: 7228:    }
        -: 7229:}
        -: 7230:
        -: 7231:#endif // signals/SEH handling
        -: 7232:
        -: 7233:#if defined( CATCH_CONFIG_WINDOWS_SEH )
        -: 7234:
        -: 7235:namespace Catch {
        -: 7236:    struct SignalDefs { DWORD id; const char* name; };
        -: 7237:
        -: 7238:    // There is no 1-1 mapping between signals and windows exceptions.
        -: 7239:    // Windows can easily distinguish between SO and SigSegV,
        -: 7240:    // but SigInt, SigTerm, etc are handled differently.
        -: 7241:    static SignalDefs signalDefs[] = {
        -: 7242:        { EXCEPTION_ILLEGAL_INSTRUCTION,  "SIGILL - Illegal instruction signal" },
        -: 7243:        { EXCEPTION_STACK_OVERFLOW, "SIGSEGV - Stack overflow" },
        -: 7244:        { EXCEPTION_ACCESS_VIOLATION, "SIGSEGV - Segmentation violation signal" },
        -: 7245:        { EXCEPTION_INT_DIVIDE_BY_ZERO, "Divide by zero error" },
        -: 7246:    };
        -: 7247:
        -: 7248:    LONG CALLBACK FatalConditionHandler::handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {
        -: 7249:        for (auto const& def : signalDefs) {
        -: 7250:            if (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) {
        -: 7251:                reportFatal(def.name);
        -: 7252:            }
        -: 7253:        }
        -: 7254:        // If its not an exception we care about, pass it along.
        -: 7255:        // This stops us from eating debugger breaks etc.
        -: 7256:        return EXCEPTION_CONTINUE_SEARCH;
        -: 7257:    }
        -: 7258:
        -: 7259:    FatalConditionHandler::FatalConditionHandler() {
        -: 7260:        isSet = true;
        -: 7261:        // 32k seems enough for Catch to handle stack overflow,
        -: 7262:        // but the value was found experimentally, so there is no strong guarantee
        -: 7263:        guaranteeSize = 32 * 1024;
        -: 7264:        exceptionHandlerHandle = nullptr;
        -: 7265:        // Register as first handler in current chain
        -: 7266:        exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);
        -: 7267:        // Pass in guarantee size to be filled
        -: 7268:        SetThreadStackGuarantee(&guaranteeSize);
        -: 7269:    }
        -: 7270:
        -: 7271:    void FatalConditionHandler::reset() {
        -: 7272:        if (isSet) {
        -: 7273:            RemoveVectoredExceptionHandler(exceptionHandlerHandle);
        -: 7274:            SetThreadStackGuarantee(&guaranteeSize);
        -: 7275:            exceptionHandlerHandle = nullptr;
        -: 7276:            isSet = false;
        -: 7277:        }
        -: 7278:    }
        -: 7279:
        -: 7280:    FatalConditionHandler::~FatalConditionHandler() {
        -: 7281:        reset();
        -: 7282:    }
        -: 7283:
        -: 7284:bool FatalConditionHandler::isSet = false;
        -: 7285:ULONG FatalConditionHandler::guaranteeSize = 0;
        -: 7286:PVOID FatalConditionHandler::exceptionHandlerHandle = nullptr;
        -: 7287:
        -: 7288:} // namespace Catch
        -: 7289:
        -: 7290:#elif defined( CATCH_CONFIG_POSIX_SIGNALS )
        -: 7291:
        -: 7292:namespace Catch {
        -: 7293:
        -: 7294:    struct SignalDefs {
        -: 7295:        int id;
        -: 7296:        const char* name;
        -: 7297:    };
        -: 7298:    static SignalDefs signalDefs[] = {
        -: 7299:        { SIGINT,  "SIGINT - Terminal interrupt signal" },
        -: 7300:        { SIGILL,  "SIGILL - Illegal instruction signal" },
        -: 7301:        { SIGFPE,  "SIGFPE - Floating point error signal" },
        -: 7302:        { SIGSEGV, "SIGSEGV - Segmentation violation signal" },
        -: 7303:        { SIGTERM, "SIGTERM - Termination request signal" },
        -: 7304:        { SIGABRT, "SIGABRT - Abort (abnormal termination) signal" }
        -: 7305:    };
        -: 7306:
    #####: 7307:    void FatalConditionHandler::handleSignal( int sig ) {
    #####: 7308:        char const * name = "<unknown signal>";
    #####: 7309:        for (auto const& def : signalDefs) {
    #####: 7310:            if (sig == def.id) {
    #####: 7311:                name = def.name;
    #####: 7312:                break;
        -: 7313:            }
        -: 7314:        }
    #####: 7315:        reset();
    #####: 7316:        reportFatal(name);
    #####: 7317:        raise( sig );
    #####: 7318:    }
        -: 7319:
       10: 7320:    FatalConditionHandler::FatalConditionHandler() {
       10: 7321:        isSet = true;
        -: 7322:        stack_t sigStack;
       10: 7323:        sigStack.ss_sp = altStackMem;
       10: 7324:        sigStack.ss_size = SIGSTKSZ;
       10: 7325:        sigStack.ss_flags = 0;
       10: 7326:        sigaltstack(&sigStack, &oldSigStack);
       10: 7327:        struct sigaction sa = { };
        -: 7328:
       10: 7329:        sa.sa_handler = handleSignal;
       10: 7330:        sa.sa_flags = SA_ONSTACK;
       70: 7331:        for (std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i) {
       60: 7332:            sigaction(signalDefs[i].id, &sa, &oldSigActions[i]);
        -: 7333:        }
       10: 7334:    }
        -: 7335:
       10: 7336:    FatalConditionHandler::~FatalConditionHandler() {
       10: 7337:        reset();
       10: 7338:    }
        -: 7339:
       20: 7340:    void FatalConditionHandler::reset() {
       20: 7341:        if( isSet ) {
        -: 7342:            // Set signals back to previous values -- hopefully nobody overwrote them in the meantime
       70: 7343:            for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i ) {
       60: 7344:                sigaction(signalDefs[i].id, &oldSigActions[i], nullptr);
        -: 7345:            }
        -: 7346:            // Return the old stack
       10: 7347:            sigaltstack(&oldSigStack, nullptr);
       10: 7348:            isSet = false;
        -: 7349:        }
       20: 7350:    }
        -: 7351:
        -: 7352:    bool FatalConditionHandler::isSet = false;
        -: 7353:    struct sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = {};
        -: 7354:    stack_t FatalConditionHandler::oldSigStack = {};
        -: 7355:    char FatalConditionHandler::altStackMem[4096] = {};
        -: 7356:
        -: 7357:} // namespace Catch
        -: 7358:
        -: 7359:#else
        -: 7360:
        -: 7361:namespace Catch {
        -: 7362:    void FatalConditionHandler::reset() {}
        -: 7363:}
        -: 7364:
        -: 7365:#endif // signals/SEH handling
        -: 7366:
        -: 7367:#if defined(__GNUC__)
        -: 7368:#    pragma GCC diagnostic pop
        -: 7369:#endif
        -: 7370:// end catch_fatal_condition.cpp
        -: 7371:// start catch_interfaces_capture.cpp
        -: 7372:
        -: 7373:namespace Catch {
       1*: 7374:    IResultCapture::~IResultCapture() = default;
------------------
_ZN5Catch14IResultCaptureD0Ev:
    #####: 7374:    IResultCapture::~IResultCapture() = default;
------------------
_ZN5Catch14IResultCaptureD2Ev:
        1: 7374:    IResultCapture::~IResultCapture() = default;
------------------
        -: 7375:}
        -: 7376:// end catch_interfaces_capture.cpp
        -: 7377:// start catch_interfaces_config.cpp
        -: 7378:
        -: 7379:namespace Catch {
       1*: 7380:    IConfig::~IConfig() = default;
------------------
_ZN5Catch7IConfigD0Ev:
    #####: 7380:    IConfig::~IConfig() = default;
------------------
_ZN5Catch7IConfigD2Ev:
        1: 7380:    IConfig::~IConfig() = default;
------------------
        -: 7381:}
        -: 7382:// end catch_interfaces_config.cpp
        -: 7383:// start catch_interfaces_exception.cpp
        -: 7384:
        -: 7385:namespace Catch {
    #####: 7386:    IExceptionTranslator::~IExceptionTranslator() = default;
------------------
_ZN5Catch20IExceptionTranslatorD0Ev:
    #####: 7386:    IExceptionTranslator::~IExceptionTranslator() = default;
------------------
_ZN5Catch20IExceptionTranslatorD2Ev:
    #####: 7386:    IExceptionTranslator::~IExceptionTranslator() = default;
------------------
       1*: 7387:    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = default;
------------------
_ZN5Catch28IExceptionTranslatorRegistryD0Ev:
    #####: 7387:    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = default;
------------------
_ZN5Catch28IExceptionTranslatorRegistryD2Ev:
        1: 7387:    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = default;
------------------
        -: 7388:}
        -: 7389:// end catch_interfaces_exception.cpp
        -: 7390:// start catch_interfaces_registry_hub.cpp
        -: 7391:
        -: 7392:namespace Catch {
       1*: 7393:    IRegistryHub::~IRegistryHub() = default;
------------------
_ZN5Catch12IRegistryHubD0Ev:
    #####: 7393:    IRegistryHub::~IRegistryHub() = default;
------------------
_ZN5Catch12IRegistryHubD2Ev:
        1: 7393:    IRegistryHub::~IRegistryHub() = default;
------------------
       1*: 7394:    IMutableRegistryHub::~IMutableRegistryHub() = default;
------------------
_ZN5Catch19IMutableRegistryHubD0Ev:
    #####: 7394:    IMutableRegistryHub::~IMutableRegistryHub() = default;
------------------
_ZN5Catch19IMutableRegistryHubD2Ev:
        1: 7394:    IMutableRegistryHub::~IMutableRegistryHub() = default;
------------------
        -: 7395:}
        -: 7396:// end catch_interfaces_registry_hub.cpp
        -: 7397:// start catch_interfaces_reporter.cpp
        -: 7398:
        -: 7399:// start catch_reporter_multi.h
        -: 7400:
        -: 7401:namespace Catch {
        -: 7402:
        -: 7403:    class MultipleReporters : public IStreamingReporter {
        -: 7404:        using Reporters = std::vector<IStreamingReporterPtr>;
        -: 7405:        Reporters m_reporters;
        -: 7406:
        -: 7407:    public:
        -: 7408:        void add( IStreamingReporterPtr&& reporter );
        -: 7409:
        -: 7410:    public: // IStreamingReporter
        -: 7411:
        -: 7412:        ReporterPreferences getPreferences() const override;
        -: 7413:
        -: 7414:        void noMatchingTestCases( std::string const& spec ) override;
        -: 7415:
        -: 7416:        static std::set<Verbosity> getSupportedVerbosities();
        -: 7417:
        -: 7418:        void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;
        -: 7419:        void benchmarkEnded( BenchmarkStats const& benchmarkStats ) override;
        -: 7420:
        -: 7421:        void testRunStarting( TestRunInfo const& testRunInfo ) override;
        -: 7422:        void testGroupStarting( GroupInfo const& groupInfo ) override;
        -: 7423:        void testCaseStarting( TestCaseInfo const& testInfo ) override;
        -: 7424:        void sectionStarting( SectionInfo const& sectionInfo ) override;
        -: 7425:        void assertionStarting( AssertionInfo const& assertionInfo ) override;
        -: 7426:
        -: 7427:        // The return value indicates if the messages buffer should be cleared:
        -: 7428:        bool assertionEnded( AssertionStats const& assertionStats ) override;
        -: 7429:        void sectionEnded( SectionStats const& sectionStats ) override;
        -: 7430:        void testCaseEnded( TestCaseStats const& testCaseStats ) override;
        -: 7431:        void testGroupEnded( TestGroupStats const& testGroupStats ) override;
        -: 7432:        void testRunEnded( TestRunStats const& testRunStats ) override;
        -: 7433:
        -: 7434:        void skipTest( TestCaseInfo const& testInfo ) override;
        -: 7435:        bool isMulti() const override;
        -: 7436:
        -: 7437:    };
        -: 7438:
        -: 7439:} // end namespace Catch
        -: 7440:
        -: 7441:// end catch_reporter_multi.h
        -: 7442:namespace Catch {
        -: 7443:
        1: 7444:    ReporterConfig::ReporterConfig( IConfigPtr const& _fullConfig )
        1: 7445:    :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) {}
        -: 7446:
    #####: 7447:    ReporterConfig::ReporterConfig( IConfigPtr const& _fullConfig, std::ostream& _stream )
    #####: 7448:    :   m_stream( &_stream ), m_fullConfig( _fullConfig ) {}
        -: 7449:
        2: 7450:    std::ostream& ReporterConfig::stream() const { return *m_stream; }
        1: 7451:    IConfigPtr ReporterConfig::fullConfig() const { return m_fullConfig; }
        -: 7452:
        1: 7453:    TestRunInfo::TestRunInfo( std::string const& _name ) : name( _name ) {}
        -: 7454:
        2: 7455:    GroupInfo::GroupInfo(  std::string const& _name,
        -: 7456:                           std::size_t _groupIndex,
        2: 7457:                           std::size_t _groupsCount )
        2: 7458:    :   name( _name ),
        2: 7459:        groupIndex( _groupIndex ),
        2: 7460:        groupsCounts( _groupsCount )
        2: 7461:    {}
        -: 7462:
    #####: 7463:     AssertionStats::AssertionStats( AssertionResult const& _assertionResult,
        -: 7464:                                     std::vector<MessageInfo> const& _infoMessages,
    #####: 7465:                                     Totals const& _totals )
    #####: 7466:    :   assertionResult( _assertionResult ),
    #####: 7467:        infoMessages( _infoMessages ),
    #####: 7468:        totals( _totals )
        -: 7469:    {
    #####: 7470:        assertionResult.m_resultData.lazyExpression.m_transientExpression = _assertionResult.m_resultData.lazyExpression.m_transientExpression;
        -: 7471:
    #####: 7472:        if( assertionResult.hasMessage() ) {
        -: 7473:            // Copy message into messages list.
        -: 7474:            // !TBD This should have been done earlier, somewhere
    #####: 7475:            MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );
    #####: 7476:            builder << assertionResult.getMessage();
    #####: 7477:            builder.m_info.message = builder.m_stream.str();
        -: 7478:
    #####: 7479:            infoMessages.push_back( builder.m_info );
    #####: 7480:        }
    #####: 7481:    }
        -: 7482:
    #####: 7483:     AssertionStats::~AssertionStats() = default;
------------------
_ZN5Catch14AssertionStatsD0Ev:
    #####: 7483:     AssertionStats::~AssertionStats() = default;
------------------
_ZN5Catch14AssertionStatsD2Ev:
    #####: 7483:     AssertionStats::~AssertionStats() = default;
------------------
        -: 7484:
       19: 7485:    SectionStats::SectionStats(  SectionInfo const& _sectionInfo,
        -: 7486:                                 Counts const& _assertions,
        -: 7487:                                 double _durationInSeconds,
       19: 7488:                                 bool _missingAssertions )
       19: 7489:    :   sectionInfo( _sectionInfo ),
       19: 7490:        assertions( _assertions ),
       19: 7491:        durationInSeconds( _durationInSeconds ),
       19: 7492:        missingAssertions( _missingAssertions )
       19: 7493:    {}
        -: 7494:
      19*: 7495:    SectionStats::~SectionStats() = default;
------------------
_ZN5Catch12SectionStatsD0Ev:
    #####: 7495:    SectionStats::~SectionStats() = default;
------------------
_ZN5Catch12SectionStatsD2Ev:
       19: 7495:    SectionStats::~SectionStats() = default;
------------------
        -: 7496:
        4: 7497:    TestCaseStats::TestCaseStats(  TestCaseInfo const& _testInfo,
        -: 7498:                                   Totals const& _totals,
        -: 7499:                                   std::string const& _stdOut,
        -: 7500:                                   std::string const& _stdErr,
        4: 7501:                                   bool _aborting )
        4: 7502:    : testInfo( _testInfo ),
        4: 7503:        totals( _totals ),
        4: 7504:        stdOut( _stdOut ),
        4: 7505:        stdErr( _stdErr ),
        4: 7506:        aborting( _aborting )
        4: 7507:    {}
        -: 7508:
       4*: 7509:    TestCaseStats::~TestCaseStats() = default;
------------------
_ZN5Catch13TestCaseStatsD0Ev:
    #####: 7509:    TestCaseStats::~TestCaseStats() = default;
------------------
_ZN5Catch13TestCaseStatsD2Ev:
        4: 7509:    TestCaseStats::~TestCaseStats() = default;
------------------
        -: 7510:
        1: 7511:    TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo,
        -: 7512:                                    Totals const& _totals,
        1: 7513:                                    bool _aborting )
        1: 7514:    :   groupInfo( _groupInfo ),
        1: 7515:        totals( _totals ),
        1: 7516:        aborting( _aborting )
        1: 7517:    {}
        -: 7518:
    #####: 7519:    TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo )
    #####: 7520:    :   groupInfo( _groupInfo ),
    #####: 7521:        aborting( false )
    #####: 7522:    {}
        -: 7523:
       1*: 7524:    TestGroupStats::~TestGroupStats() = default;
------------------
_ZN5Catch14TestGroupStatsD0Ev:
    #####: 7524:    TestGroupStats::~TestGroupStats() = default;
------------------
_ZN5Catch14TestGroupStatsD2Ev:
        1: 7524:    TestGroupStats::~TestGroupStats() = default;
------------------
        -: 7525:
        1: 7526:    TestRunStats::TestRunStats(   TestRunInfo const& _runInfo,
        -: 7527:                    Totals const& _totals,
        1: 7528:                    bool _aborting )
        1: 7529:    :   runInfo( _runInfo ),
        1: 7530:        totals( _totals ),
        1: 7531:        aborting( _aborting )
        1: 7532:    {}
        -: 7533:
       1*: 7534:    TestRunStats::~TestRunStats() = default;
------------------
_ZN5Catch12TestRunStatsD0Ev:
    #####: 7534:    TestRunStats::~TestRunStats() = default;
------------------
_ZN5Catch12TestRunStatsD2Ev:
        1: 7534:    TestRunStats::~TestRunStats() = default;
------------------
        -: 7535:
    #####: 7536:    void IStreamingReporter::fatalErrorEncountered( StringRef ) {}
    #####: 7537:    bool IStreamingReporter::isMulti() const { return false; }
        -: 7538:
       4*: 7539:    IReporterFactory::~IReporterFactory() = default;
------------------
_ZN5Catch16IReporterFactoryD0Ev:
    #####: 7539:    IReporterFactory::~IReporterFactory() = default;
------------------
_ZN5Catch16IReporterFactoryD2Ev:
        4: 7539:    IReporterFactory::~IReporterFactory() = default;
------------------
       1*: 7540:    IReporterRegistry::~IReporterRegistry() = default;
------------------
_ZN5Catch17IReporterRegistryD0Ev:
    #####: 7540:    IReporterRegistry::~IReporterRegistry() = default;
------------------
_ZN5Catch17IReporterRegistryD2Ev:
        1: 7540:    IReporterRegistry::~IReporterRegistry() = default;
------------------
        -: 7541:
    #####: 7542:    void addReporter( IStreamingReporterPtr& existingReporter, IStreamingReporterPtr&& additionalReporter ) {
        -: 7543:
    #####: 7544:        if( !existingReporter ) {
    #####: 7545:            existingReporter = std::move( additionalReporter );
    #####: 7546:            return;
        -: 7547:        }
        -: 7548:
    #####: 7549:        MultipleReporters* multi = nullptr;
        -: 7550:
    #####: 7551:        if( existingReporter->isMulti() ) {
    #####: 7552:            multi = static_cast<MultipleReporters*>( existingReporter.get() );
        -: 7553:        }
        -: 7554:        else {
    #####: 7555:            auto newMulti = std::unique_ptr<MultipleReporters>( new MultipleReporters );
    #####: 7556:            newMulti->add( std::move( existingReporter ) );
    #####: 7557:            multi = newMulti.get();
    #####: 7558:            existingReporter = std::move( newMulti );
    #####: 7559:        }
    #####: 7560:        multi->add( std::move( additionalReporter ) );
        -: 7561:    }
        -: 7562:
        -: 7563:} // end namespace Catch
        -: 7564:// end catch_interfaces_reporter.cpp
        -: 7565:// start catch_interfaces_runner.cpp
        -: 7566:
        -: 7567:namespace Catch {
       1*: 7568:    IRunner::~IRunner() = default;
------------------
_ZN5Catch7IRunnerD0Ev:
    #####: 7568:    IRunner::~IRunner() = default;
------------------
_ZN5Catch7IRunnerD2Ev:
        1: 7568:    IRunner::~IRunner() = default;
------------------
        -: 7569:}
        -: 7570:// end catch_interfaces_runner.cpp
        -: 7571:// start catch_interfaces_testcase.cpp
        -: 7572:
        -: 7573:namespace Catch {
       4*: 7574:    ITestInvoker::~ITestInvoker() = default;
------------------
_ZN5Catch12ITestInvokerD0Ev:
    #####: 7574:    ITestInvoker::~ITestInvoker() = default;
------------------
_ZN5Catch12ITestInvokerD2Ev:
        4: 7574:    ITestInvoker::~ITestInvoker() = default;
------------------
       1*: 7575:    ITestCaseRegistry::~ITestCaseRegistry() = default;
------------------
_ZN5Catch17ITestCaseRegistryD0Ev:
    #####: 7575:    ITestCaseRegistry::~ITestCaseRegistry() = default;
------------------
_ZN5Catch17ITestCaseRegistryD2Ev:
        1: 7575:    ITestCaseRegistry::~ITestCaseRegistry() = default;
------------------
        -: 7576:}
        -: 7577:// end catch_interfaces_testcase.cpp
        -: 7578:// start catch_leak_detector.cpp
        -: 7579:
        -: 7580:#ifdef CATCH_CONFIG_WINDOWS_CRTDBG
        -: 7581:#include <crtdbg.h>
        -: 7582:
        -: 7583:namespace Catch {
        -: 7584:
        -: 7585:	LeakDetector::LeakDetector() {
        -: 7586:		int flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
        -: 7587:		flag |= _CRTDBG_LEAK_CHECK_DF;
        -: 7588:		flag |= _CRTDBG_ALLOC_MEM_DF;
        -: 7589:		_CrtSetDbgFlag(flag);
        -: 7590:		_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
        -: 7591:		_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
        -: 7592:		// Change this to leaking allocation's number to break there
        -: 7593:		_CrtSetBreakAlloc(-1);
        -: 7594:	}
        -: 7595:}
        -: 7596:
        -: 7597:#else
        -: 7598:
        1: 7599:    Catch::LeakDetector::LeakDetector() {}
        -: 7600:
        -: 7601:#endif
        -: 7602:// end catch_leak_detector.cpp
        -: 7603:// start catch_list.cpp
        -: 7604:
        -: 7605:// start catch_list.h
        -: 7606:
        -: 7607:#include <set>
        -: 7608:
        -: 7609:namespace Catch {
        -: 7610:
        -: 7611:    std::size_t listTests( Config const& config );
        -: 7612:
        -: 7613:    std::size_t listTestsNamesOnly( Config const& config );
        -: 7614:
        -: 7615:    struct TagInfo {
        -: 7616:        void add( std::string const& spelling );
        -: 7617:        std::string all() const;
        -: 7618:
        -: 7619:        std::set<std::string> spellings;
        -: 7620:        std::size_t count = 0;
        -: 7621:    };
        -: 7622:
        -: 7623:    std::size_t listTags( Config const& config );
        -: 7624:
        -: 7625:    std::size_t listReporters( Config const& /*config*/ );
        -: 7626:
        -: 7627:    Option<std::size_t> list( Config const& config );
        -: 7628:
        -: 7629:} // end namespace Catch
        -: 7630:
        -: 7631:// end catch_list.h
        -: 7632:// start catch_text.h
        -: 7633:
        -: 7634:namespace Catch {
        -: 7635:    using namespace clara::TextFlow;
        -: 7636:}
        -: 7637:
        -: 7638:// end catch_text.h
        -: 7639:#include <limits>
        -: 7640:#include <algorithm>
        -: 7641:#include <iomanip>
        -: 7642:
        -: 7643:namespace Catch {
        -: 7644:
    #####: 7645:    std::size_t listTests( Config const& config ) {
    #####: 7646:        TestSpec testSpec = config.testSpec();
    #####: 7647:        if( config.hasTestFilters() )
    #####: 7648:            Catch::cout() << "Matching test cases:\n";
        -: 7649:        else {
    #####: 7650:            Catch::cout() << "All available test cases:\n";
        -: 7651:        }
        -: 7652:
    #####: 7653:        auto matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
    #####: 7654:        for( auto const& testCaseInfo : matchedTestCases ) {
    #####: 7655:            Colour::Code colour = testCaseInfo.isHidden()
    #####: 7656:                ? Colour::SecondaryText
    #####: 7657:                : Colour::None;
    #####: 7658:            Colour colourGuard( colour );
        -: 7659:
    #####: 7660:            Catch::cout() << Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) << "\n";
    #####: 7661:            if( config.verbosity() >= Verbosity::High ) {
    #####: 7662:                Catch::cout() << Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) << std::endl;
    #####: 7663:                std::string description = testCaseInfo.description;
    #####: 7664:                if( description.empty() )
    #####: 7665:                    description = "(NO DESCRIPTION)";
    #####: 7666:                Catch::cout() << Column( description ).indent(4) << std::endl;
    #####: 7667:            }
    #####: 7668:            if( !testCaseInfo.tags.empty() )
    #####: 7669:                Catch::cout() << Column( testCaseInfo.tagsAsString() ).indent( 6 ) << "\n";
    #####: 7670:        }
        -: 7671:
    #####: 7672:        if( !config.hasTestFilters() )
    #####: 7673:            Catch::cout() << pluralise( matchedTestCases.size(), "test case" ) << '\n' << std::endl;
        -: 7674:        else
    #####: 7675:            Catch::cout() << pluralise( matchedTestCases.size(), "matching test case" ) << '\n' << std::endl;
    #####: 7676:        return matchedTestCases.size();
    #####: 7677:    }
        -: 7678:
    #####: 7679:    std::size_t listTestsNamesOnly( Config const& config ) {
    #####: 7680:        TestSpec testSpec = config.testSpec();
    #####: 7681:        std::size_t matchedTests = 0;
    #####: 7682:        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
    #####: 7683:        for( auto const& testCaseInfo : matchedTestCases ) {
    #####: 7684:            matchedTests++;
    #####: 7685:            if( startsWith( testCaseInfo.name, '#' ) )
    #####: 7686:               Catch::cout() << '"' << testCaseInfo.name << '"';
        -: 7687:            else
    #####: 7688:               Catch::cout() << testCaseInfo.name;
    #####: 7689:            if ( config.verbosity() >= Verbosity::High )
    #####: 7690:                Catch::cout() << "\t@" << testCaseInfo.lineInfo;
    #####: 7691:            Catch::cout() << std::endl;
        -: 7692:        }
    #####: 7693:        return matchedTests;
    #####: 7694:    }
        -: 7695:
    #####: 7696:    void TagInfo::add( std::string const& spelling ) {
    #####: 7697:        ++count;
    #####: 7698:        spellings.insert( spelling );
    #####: 7699:    }
        -: 7700:
    #####: 7701:    std::string TagInfo::all() const {
    #####: 7702:        std::string out;
    #####: 7703:        for( auto const& spelling : spellings )
    #####: 7704:            out += "[" + spelling + "]";
    #####: 7705:        return out;
    =====: 7706:    }
        -: 7707:
    #####: 7708:    std::size_t listTags( Config const& config ) {
    #####: 7709:        TestSpec testSpec = config.testSpec();
    #####: 7710:        if( config.hasTestFilters() )
    #####: 7711:            Catch::cout() << "Tags for matching test cases:\n";
        -: 7712:        else {
    #####: 7713:            Catch::cout() << "All available tags:\n";
        -: 7714:        }
        -: 7715:
    #####: 7716:        std::map<std::string, TagInfo> tagCounts;
        -: 7717:
    #####: 7718:        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
    #####: 7719:        for( auto const& testCase : matchedTestCases ) {
    #####: 7720:            for( auto const& tagName : testCase.getTestCaseInfo().tags ) {
    #####: 7721:                std::string lcaseTagName = toLower( tagName );
    #####: 7722:                auto countIt = tagCounts.find( lcaseTagName );
    #####: 7723:                if( countIt == tagCounts.end() )
    #####: 7724:                    countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;
    #####: 7725:                countIt->second.add( tagName );
    #####: 7726:            }
        -: 7727:        }
        -: 7728:
    #####: 7729:        for( auto const& tagCount : tagCounts ) {
    #####: 7730:            ReusableStringStream rss;
    #####: 7731:            rss << "  " << std::setw(2) << tagCount.second.count << "  ";
    #####: 7732:            auto str = rss.str();
    #####: 7733:            auto wrapper = Column( tagCount.second.all() )
    #####: 7734:                                                    .initialIndent( 0 )
    #####: 7735:                                                    .indent( str.size() )
    #####: 7736:                                                    .width( CATCH_CONFIG_CONSOLE_WIDTH-10 );
    #####: 7737:            Catch::cout() << str << wrapper << '\n';
    #####: 7738:        }
    #####: 7739:        Catch::cout() << pluralise( tagCounts.size(), "tag" ) << '\n' << std::endl;
    #####: 7740:        return tagCounts.size();
    #####: 7741:    }
        -: 7742:
    #####: 7743:    std::size_t listReporters( Config const& /*config*/ ) {
    #####: 7744:        Catch::cout() << "Available reporters:\n";
    #####: 7745:        IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();
    #####: 7746:        std::size_t maxNameLen = 0;
    #####: 7747:        for( auto const& factoryKvp : factories )
    #####: 7748:            maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );
        -: 7749:
    #####: 7750:        for( auto const& factoryKvp : factories ) {
        -: 7751:            Catch::cout()
    #####: 7752:                    << Column( factoryKvp.first + ":" )
    #####: 7753:                            .indent(2)
    #####: 7754:                            .width( 5+maxNameLen )
    #####: 7755:                    +  Column( factoryKvp.second->getDescription() )
    #####: 7756:                            .initialIndent(0)
    #####: 7757:                            .indent(2)
    #####: 7758:                            .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 )
    #####: 7759:                    << "\n";
        -: 7760:        }
    #####: 7761:        Catch::cout() << std::endl;
    #####: 7762:        return factories.size();
        -: 7763:    }
        -: 7764:
        1: 7765:    Option<std::size_t> list( Config const& config ) {
        1: 7766:        Option<std::size_t> listedCount;
        1: 7767:        if( config.listTests() )
    #####: 7768:            listedCount = listedCount.valueOr(0) + listTests( config );
        1: 7769:        if( config.listTestNamesOnly() )
    #####: 7770:            listedCount = listedCount.valueOr(0) + listTestsNamesOnly( config );
        1: 7771:        if( config.listTags() )
    #####: 7772:            listedCount = listedCount.valueOr(0) + listTags( config );
        1: 7773:        if( config.listReporters() )
    #####: 7774:            listedCount = listedCount.valueOr(0) + listReporters( config );
        1: 7775:        return listedCount;
    =====: 7776:    }
        -: 7777:
        -: 7778:} // end namespace Catch
        -: 7779:// end catch_list.cpp
        -: 7780:// start catch_matchers.cpp
        -: 7781:
        -: 7782:namespace Catch {
        -: 7783:namespace Matchers {
        -: 7784:    namespace Impl {
        -: 7785:
    #####: 7786:        std::string MatcherUntypedBase::toString() const {
    #####: 7787:            if( m_cachedToString.empty() )
    #####: 7788:                m_cachedToString = describe();
    #####: 7789:            return m_cachedToString;
        -: 7790:        }
        -: 7791:
    #####: 7792:        MatcherUntypedBase::~MatcherUntypedBase() = default;
------------------
_ZN5Catch8Matchers4Impl18MatcherUntypedBaseD0Ev:
    #####: 7792:        MatcherUntypedBase::~MatcherUntypedBase() = default;
------------------
_ZN5Catch8Matchers4Impl18MatcherUntypedBaseD2Ev:
    #####: 7792:        MatcherUntypedBase::~MatcherUntypedBase() = default;
------------------
        -: 7793:
        -: 7794:    } // namespace Impl
        -: 7795:} // namespace Matchers
        -: 7796:
        -: 7797:using namespace Matchers;
        -: 7798:using Matchers::Impl::MatcherBase;
        -: 7799:
        -: 7800:} // namespace Catch
        -: 7801:// end catch_matchers.cpp
        -: 7802:// start catch_matchers_floating.cpp
        -: 7803:
        -: 7804:#include <cstdlib>
        -: 7805:#include <cstdint>
        -: 7806:#include <cstring>
        -: 7807:#include <stdexcept>
        -: 7808:
        -: 7809:namespace Catch {
        -: 7810:namespace Matchers {
        -: 7811:namespace Floating {
        -: 7812:enum class FloatingPointKind : uint8_t {
        -: 7813:    Float,
        -: 7814:    Double
        -: 7815:};
        -: 7816:}
        -: 7817:}
        -: 7818:}
        -: 7819:
        -: 7820:namespace {
        -: 7821:
        -: 7822:template <typename T>
        -: 7823:struct Converter;
        -: 7824:
        -: 7825:template <>
        -: 7826:struct Converter<float> {
        -: 7827:    static_assert(sizeof(float) == sizeof(int32_t), "Important ULP matcher assumption violated");
    #####: 7828:    Converter(float f) {
    #####: 7829:        std::memcpy(&i, &f, sizeof(f));
    #####: 7830:    }
        -: 7831:    int32_t i;
        -: 7832:};
        -: 7833:
        -: 7834:template <>
        -: 7835:struct Converter<double> {
        -: 7836:    static_assert(sizeof(double) == sizeof(int64_t), "Important ULP matcher assumption violated");
    #####: 7837:    Converter(double d) {
    #####: 7838:        std::memcpy(&i, &d, sizeof(d));
    #####: 7839:    }
        -: 7840:    int64_t i;
        -: 7841:};
        -: 7842:
        -: 7843:template <typename T>
    #####: 7844:auto convert(T t) -> Converter<T> {
    #####: 7845:    return Converter<T>(t);
        -: 7846:}
------------------
_ZN12_GLOBAL__N_17convertIdEENS_9ConverterIT_EES2_:
    #####: 7844:auto convert(T t) -> Converter<T> {
    #####: 7845:    return Converter<T>(t);
        -: 7846:}
------------------
_ZN12_GLOBAL__N_17convertIfEENS_9ConverterIT_EES2_:
    #####: 7844:auto convert(T t) -> Converter<T> {
    #####: 7845:    return Converter<T>(t);
        -: 7846:}
------------------
        -: 7847:
        -: 7848:template <typename FP>
    #####: 7849:bool almostEqualUlps(FP lhs, FP rhs, int maxUlpDiff) {
        -: 7850:    // Comparison with NaN should always be false.
        -: 7851:    // This way we can rule it out before getting into the ugly details
    #####: 7852:    if (std::isnan(lhs) || std::isnan(rhs)) {
    #####: 7853:        return false;
        -: 7854:    }
        -: 7855:
    #####: 7856:    auto lc = convert(lhs);
    #####: 7857:    auto rc = convert(rhs);
        -: 7858:
    #####: 7859:    if ((lc.i < 0) != (rc.i < 0)) {
        -: 7860:        // Potentially we can have +0 and -0
    #####: 7861:        return lhs == rhs;
        -: 7862:    }
        -: 7863:
    #####: 7864:    auto ulpDiff = std::abs(lc.i - rc.i);
    #####: 7865:    return ulpDiff <= maxUlpDiff;
        -: 7866:}
------------------
_ZN12_GLOBAL__N_115almostEqualUlpsIdEEbT_S1_i:
    #####: 7849:bool almostEqualUlps(FP lhs, FP rhs, int maxUlpDiff) {
        -: 7850:    // Comparison with NaN should always be false.
        -: 7851:    // This way we can rule it out before getting into the ugly details
    #####: 7852:    if (std::isnan(lhs) || std::isnan(rhs)) {
    #####: 7853:        return false;
        -: 7854:    }
        -: 7855:
    #####: 7856:    auto lc = convert(lhs);
    #####: 7857:    auto rc = convert(rhs);
        -: 7858:
    #####: 7859:    if ((lc.i < 0) != (rc.i < 0)) {
        -: 7860:        // Potentially we can have +0 and -0
    #####: 7861:        return lhs == rhs;
        -: 7862:    }
        -: 7863:
    #####: 7864:    auto ulpDiff = std::abs(lc.i - rc.i);
    #####: 7865:    return ulpDiff <= maxUlpDiff;
        -: 7866:}
------------------
_ZN12_GLOBAL__N_115almostEqualUlpsIfEEbT_S1_i:
    #####: 7849:bool almostEqualUlps(FP lhs, FP rhs, int maxUlpDiff) {
        -: 7850:    // Comparison with NaN should always be false.
        -: 7851:    // This way we can rule it out before getting into the ugly details
    #####: 7852:    if (std::isnan(lhs) || std::isnan(rhs)) {
    #####: 7853:        return false;
        -: 7854:    }
        -: 7855:
    #####: 7856:    auto lc = convert(lhs);
    #####: 7857:    auto rc = convert(rhs);
        -: 7858:
    #####: 7859:    if ((lc.i < 0) != (rc.i < 0)) {
        -: 7860:        // Potentially we can have +0 and -0
    #####: 7861:        return lhs == rhs;
        -: 7862:    }
        -: 7863:
    #####: 7864:    auto ulpDiff = std::abs(lc.i - rc.i);
    #####: 7865:    return ulpDiff <= maxUlpDiff;
        -: 7866:}
------------------
        -: 7867:
        -: 7868:}
        -: 7869:
        -: 7870:namespace Catch {
        -: 7871:namespace Matchers {
        -: 7872:namespace Floating {
    #####: 7873:    WithinAbsMatcher::WithinAbsMatcher(double target, double margin)
    #####: 7874:        :m_target{ target }, m_margin{ margin } {
    #####: 7875:        if (m_margin < 0) {
    #####: 7876:            throw std::domain_error("Allowed margin difference has to be >= 0");
        -: 7877:        }
    #####: 7878:    }
        -: 7879:
        -: 7880:    // Performs equivalent check of std::fabs(lhs - rhs) <= margin
        -: 7881:    // But without the subtraction to allow for INFINITY in comparison
    #####: 7882:    bool WithinAbsMatcher::match(double const& matchee) const {
    #####: 7883:        return (matchee + m_margin >= m_target) && (m_target + m_margin >= m_margin);
        -: 7884:    }
        -: 7885:
    #####: 7886:    std::string WithinAbsMatcher::describe() const {
    #####: 7887:        return "is within " + ::Catch::Detail::stringify(m_margin) + " of " + ::Catch::Detail::stringify(m_target);
        -: 7888:    }
        -: 7889:
    #####: 7890:    WithinUlpsMatcher::WithinUlpsMatcher(double target, int ulps, FloatingPointKind baseType)
    #####: 7891:        :m_target{ target }, m_ulps{ ulps }, m_type{ baseType } {
    #####: 7892:        if (m_ulps < 0) {
    #####: 7893:            throw std::domain_error("Allowed ulp difference has to be >= 0");
        -: 7894:        }
    #####: 7895:    }
        -: 7896:
    #####: 7897:    bool WithinUlpsMatcher::match(double const& matchee) const {
    #####: 7898:        switch (m_type) {
    #####: 7899:        case FloatingPointKind::Float:
    #####: 7900:            return almostEqualUlps<float>(static_cast<float>(matchee), static_cast<float>(m_target), m_ulps);
    #####: 7901:        case FloatingPointKind::Double:
    #####: 7902:            return almostEqualUlps<double>(matchee, m_target, m_ulps);
    #####: 7903:        default:
    #####: 7904:            throw std::domain_error("Unknown FloatingPointKind value");
        -: 7905:        }
        -: 7906:    }
        -: 7907:
    #####: 7908:    std::string WithinUlpsMatcher::describe() const {
    #####: 7909:        return "is within " + std::to_string(m_ulps) + " ULPs of " + ::Catch::Detail::stringify(m_target) + ((m_type == FloatingPointKind::Float)? "f" : "");
        -: 7910:    }
        -: 7911:
        -: 7912:}// namespace Floating
        -: 7913:
    #####: 7914:Floating::WithinUlpsMatcher WithinULP(double target, int maxUlpDiff) {
    #####: 7915:    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);
        -: 7916:}
        -: 7917:
    #####: 7918:Floating::WithinUlpsMatcher WithinULP(float target, int maxUlpDiff) {
    #####: 7919:    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);
        -: 7920:}
        -: 7921:
    #####: 7922:Floating::WithinAbsMatcher WithinAbs(double target, double margin) {
    #####: 7923:    return Floating::WithinAbsMatcher(target, margin);
        -: 7924:}
        -: 7925:
        -: 7926:} // namespace Matchers
        -: 7927:} // namespace Catch
        -: 7928:
        -: 7929:// end catch_matchers_floating.cpp
        -: 7930:// start catch_matchers_string.cpp
        -: 7931:
        -: 7932:#include <regex>
        -: 7933:
        -: 7934:namespace Catch {
        -: 7935:namespace Matchers {
        -: 7936:
        -: 7937:    namespace StdString {
        -: 7938:
    #####: 7939:        CasedString::CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )
    #####: 7940:        :   m_caseSensitivity( caseSensitivity ),
    #####: 7941:            m_str( adjustString( str ) )
    #####: 7942:        {}
    #####: 7943:        std::string CasedString::adjustString( std::string const& str ) const {
    #####: 7944:            return m_caseSensitivity == CaseSensitive::No
        -: 7945:                   ? toLower( str )
    #####: 7946:                   : str;
        -: 7947:        }
    #####: 7948:        std::string CasedString::caseSensitivitySuffix() const {
    #####: 7949:            return m_caseSensitivity == CaseSensitive::No
        -: 7950:                   ? " (case insensitive)"
    #####: 7951:                   : std::string();
        -: 7952:        }
        -: 7953:
    #####: 7954:        StringMatcherBase::StringMatcherBase( std::string const& operation, CasedString const& comparator )
    #####: 7955:        : m_comparator( comparator ),
    #####: 7956:          m_operation( operation ) {
    #####: 7957:        }
        -: 7958:
    #####: 7959:        std::string StringMatcherBase::describe() const {
    #####: 7960:            std::string description;
    #####: 7961:            description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +
    #####: 7962:                                        m_comparator.caseSensitivitySuffix().size());
    #####: 7963:            description += m_operation;
    #####: 7964:            description += ": \"";
    #####: 7965:            description += m_comparator.m_str;
    #####: 7966:            description += "\"";
    #####: 7967:            description += m_comparator.caseSensitivitySuffix();
    #####: 7968:            return description;
    =====: 7969:        }
        -: 7970:
    #####: 7971:        EqualsMatcher::EqualsMatcher( CasedString const& comparator ) : StringMatcherBase( "equals", comparator ) {}
        -: 7972:
    #####: 7973:        bool EqualsMatcher::match( std::string const& source ) const {
    #####: 7974:            return m_comparator.adjustString( source ) == m_comparator.m_str;
        -: 7975:        }
        -: 7976:
    #####: 7977:        ContainsMatcher::ContainsMatcher( CasedString const& comparator ) : StringMatcherBase( "contains", comparator ) {}
        -: 7978:
    #####: 7979:        bool ContainsMatcher::match( std::string const& source ) const {
    #####: 7980:            return contains( m_comparator.adjustString( source ), m_comparator.m_str );
        -: 7981:        }
        -: 7982:
    #####: 7983:        StartsWithMatcher::StartsWithMatcher( CasedString const& comparator ) : StringMatcherBase( "starts with", comparator ) {}
        -: 7984:
    #####: 7985:        bool StartsWithMatcher::match( std::string const& source ) const {
    #####: 7986:            return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );
        -: 7987:        }
        -: 7988:
    #####: 7989:        EndsWithMatcher::EndsWithMatcher( CasedString const& comparator ) : StringMatcherBase( "ends with", comparator ) {}
        -: 7990:
    #####: 7991:        bool EndsWithMatcher::match( std::string const& source ) const {
    #####: 7992:            return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );
        -: 7993:        }
        -: 7994:
    #####: 7995:        RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) {}
        -: 7996:
    #####: 7997:        bool RegexMatcher::match(std::string const& matchee) const {
    #####: 7998:            auto flags = std::regex::ECMAScript; // ECMAScript is the default syntax option anyway
    #####: 7999:            if (m_caseSensitivity == CaseSensitive::Choice::No) {
    #####: 8000:                flags |= std::regex::icase;
        -: 8001:            }
    #####: 8002:            auto reg = std::regex(m_regex, flags);
    #####: 8003:            return std::regex_match(matchee, reg);
    #####: 8004:        }
        -: 8005:
    #####: 8006:        std::string RegexMatcher::describe() const {
    #####: 8007:            return "matches " + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Choice::Yes)? " case sensitively" : " case insensitively");
        -: 8008:        }
        -: 8009:
        -: 8010:    } // namespace StdString
        -: 8011:
    #####: 8012:    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
    #####: 8013:        return StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );
        -: 8014:    }
    #####: 8015:    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
    #####: 8016:        return StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );
        -: 8017:    }
    #####: 8018:    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
    #####: 8019:        return StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );
        -: 8020:    }
    #####: 8021:    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
    #####: 8022:        return StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );
        -: 8023:    }
        -: 8024:
    #####: 8025:    StdString::RegexMatcher Matches(std::string const& regex, CaseSensitive::Choice caseSensitivity) {
    #####: 8026:        return StdString::RegexMatcher(regex, caseSensitivity);
        -: 8027:    }
        -: 8028:
        -: 8029:} // namespace Matchers
        -: 8030:} // namespace Catch
        -: 8031:// end catch_matchers_string.cpp
        -: 8032:// start catch_message.cpp
        -: 8033:
        -: 8034:// start catch_uncaught_exceptions.h
        -: 8035:
        -: 8036:namespace Catch {
        -: 8037:    bool uncaught_exceptions();
        -: 8038:} // end namespace Catch
        -: 8039:
        -: 8040:// end catch_uncaught_exceptions.h
        -: 8041:namespace Catch {
        -: 8042:
    #####: 8043:    MessageInfo::MessageInfo(   std::string const& _macroName,
        -: 8044:                                SourceLineInfo const& _lineInfo,
    #####: 8045:                                ResultWas::OfType _type )
    #####: 8046:    :   macroName( _macroName ),
    #####: 8047:        lineInfo( _lineInfo ),
    #####: 8048:        type( _type ),
    #####: 8049:        sequence( ++globalCount )
    #####: 8050:    {}
        -: 8051:
    #####: 8052:    bool MessageInfo::operator==( MessageInfo const& other ) const {
    #####: 8053:        return sequence == other.sequence;
        -: 8054:    }
        -: 8055:
    #####: 8056:    bool MessageInfo::operator<( MessageInfo const& other ) const {
    #####: 8057:        return sequence < other.sequence;
        -: 8058:    }
        -: 8059:
        -: 8060:    // This may need protecting if threading support is added
        -: 8061:    unsigned int MessageInfo::globalCount = 0;
        -: 8062:
        -: 8063:    ////////////////////////////////////////////////////////////////////////////
        -: 8064:
    #####: 8065:    Catch::MessageBuilder::MessageBuilder( std::string const& macroName,
        -: 8066:                                           SourceLineInfo const& lineInfo,
    #####: 8067:                                           ResultWas::OfType type )
    #####: 8068:        :m_info(macroName, lineInfo, type) {}
        -: 8069:
        -: 8070:    ////////////////////////////////////////////////////////////////////////////
        -: 8071:
    #####: 8072:    ScopedMessage::ScopedMessage( MessageBuilder const& builder )
    #####: 8073:    : m_info( builder.m_info )
        -: 8074:    {
    #####: 8075:        m_info.message = builder.m_stream.str();
    #####: 8076:        getResultCapture().pushScopedMessage( m_info );
    #####: 8077:    }
        -: 8078:
    #####: 8079:    ScopedMessage::~ScopedMessage() {
    #####: 8080:        if ( !uncaught_exceptions() ){
    #####: 8081:            getResultCapture().popScopedMessage(m_info);
        -: 8082:        }
    #####: 8083:    }
        -: 8084:} // end namespace Catch
        -: 8085:// end catch_message.cpp
        -: 8086:// start catch_random_number_generator.cpp
        -: 8087:
        -: 8088:// start catch_random_number_generator.h
        -: 8089:
        -: 8090:#include <algorithm>
        -: 8091:
        -: 8092:namespace Catch {
        -: 8093:
        -: 8094:    struct IConfig;
        -: 8095:
        -: 8096:    void seedRng( IConfig const& config );
        -: 8097:
        -: 8098:    unsigned int rngSeed();
        -: 8099:
        -: 8100:    struct RandomNumberGenerator {
        -: 8101:        using result_type = unsigned int;
        -: 8102:
        -: 8103:        static constexpr result_type (min)() { return 0; }
    #####: 8104:        static constexpr result_type (max)() { return 1000000; }
        -: 8105:
        -: 8106:        result_type operator()( result_type n ) const;
        -: 8107:        result_type operator()() const;
        -: 8108:
        -: 8109:        template<typename V>
    #####: 8110:        static void shuffle( V& vector ) {
        -: 8111:            RandomNumberGenerator rng;
    #####: 8112:            std::shuffle( vector.begin(), vector.end(), rng );
    #####: 8113:        }
        -: 8114:    };
        -: 8115:
        -: 8116:}
        -: 8117:
        -: 8118:// end catch_random_number_generator.h
        -: 8119:#include <cstdlib>
        -: 8120:
        -: 8121:namespace Catch {
        -: 8122:
       11: 8123:    void seedRng( IConfig const& config ) {
       11: 8124:        if( config.rngSeed() != 0 )
    #####: 8125:            std::srand( config.rngSeed() );
       11: 8126:    }
    #####: 8127:    unsigned int rngSeed() {
    #####: 8128:        return getCurrentContext().getConfig()->rngSeed();
        -: 8129:    }
        -: 8130:
    #####: 8131:    RandomNumberGenerator::result_type RandomNumberGenerator::operator()( result_type n ) const {
    #####: 8132:        return std::rand() % n;
        -: 8133:    }
    #####: 8134:    RandomNumberGenerator::result_type RandomNumberGenerator::operator()() const {
    #####: 8135:        return std::rand() % (max)();
        -: 8136:    }
        -: 8137:
        -: 8138:}
        -: 8139:// end catch_random_number_generator.cpp
        -: 8140:// start catch_registry_hub.cpp
        -: 8141:
        -: 8142:// start catch_test_case_registry_impl.h
        -: 8143:
        -: 8144:#include <vector>
        -: 8145:#include <set>
        -: 8146:#include <algorithm>
        -: 8147:#include <ios>
        -: 8148:
        -: 8149:namespace Catch {
        -: 8150:
        -: 8151:    class TestCase;
        -: 8152:    struct IConfig;
        -: 8153:
        -: 8154:    std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases );
        -: 8155:    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );
        -: 8156:
        -: 8157:    void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions );
        -: 8158:
        -: 8159:    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );
        -: 8160:    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );
        -: 8161:
        -: 8162:    class TestRegistry : public ITestCaseRegistry {
        -: 8163:    public:
       1*: 8164:        virtual ~TestRegistry() = default;
------------------
_ZN5Catch12TestRegistryD0Ev:
    #####: 8164:        virtual ~TestRegistry() = default;
------------------
_ZN5Catch12TestRegistryD2Ev:
        1: 8164:        virtual ~TestRegistry() = default;
------------------
        -: 8165:
        -: 8166:        virtual void registerTest( TestCase const& testCase );
        -: 8167:
        -: 8168:        std::vector<TestCase> const& getAllTests() const override;
        -: 8169:        std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const override;
        -: 8170:
        -: 8171:    private:
        -: 8172:        std::vector<TestCase> m_functions;
        -: 8173:        mutable RunTests::InWhatOrder m_currentSortOrder = RunTests::InDeclarationOrder;
        -: 8174:        mutable std::vector<TestCase> m_sortedFunctions;
        -: 8175:        std::size_t m_unnamedCount = 0;
        -: 8176:        std::ios_base::Init m_ostreamInit; // Forces cout/ cerr to be initialised
        -: 8177:    };
        -: 8178:
        -: 8179:    ///////////////////////////////////////////////////////////////////////////
        -: 8180:
        -: 8181:    class TestInvokerAsFunction : public ITestInvoker {
        -: 8182:        void(*m_testAsFunction)();
        -: 8183:    public:
        -: 8184:        TestInvokerAsFunction( void(*testAsFunction)() ) noexcept;
        -: 8185:
        -: 8186:        void invoke() const override;
        -: 8187:    };
        -: 8188:
        -: 8189:    std::string extractClassName( StringRef const& classOrQualifiedMethodName );
        -: 8190:
        -: 8191:    ///////////////////////////////////////////////////////////////////////////
        -: 8192:
        -: 8193:} // end namespace Catch
        -: 8194:
        -: 8195:// end catch_test_case_registry_impl.h
        -: 8196:// start catch_reporter_registry.h
        -: 8197:
        -: 8198:#include <map>
        -: 8199:
        -: 8200:namespace Catch {
        -: 8201:
        -: 8202:    class ReporterRegistry : public IReporterRegistry {
        -: 8203:
        -: 8204:    public:
        -: 8205:
        -: 8206:        ~ReporterRegistry() override;
        -: 8207:
        -: 8208:        IStreamingReporterPtr create( std::string const& name, IConfigPtr const& config ) const override;
        -: 8209:
        -: 8210:        void registerReporter( std::string const& name, IReporterFactoryPtr const& factory );
        -: 8211:        void registerListener( IReporterFactoryPtr const& factory );
        -: 8212:
        -: 8213:        FactoryMap const& getFactories() const override;
        -: 8214:        Listeners const& getListeners() const override;
        -: 8215:
        -: 8216:    private:
        -: 8217:        FactoryMap m_factories;
        -: 8218:        Listeners m_listeners;
        -: 8219:    };
        -: 8220:}
        -: 8221:
        -: 8222:// end catch_reporter_registry.h
        -: 8223:// start catch_tag_alias_registry.h
        -: 8224:
        -: 8225:// start catch_tag_alias.h
        -: 8226:
        -: 8227:#include <string>
        -: 8228:
        -: 8229:namespace Catch {
        -: 8230:
        -: 8231:    struct TagAlias {
        -: 8232:        TagAlias(std::string const& _tag, SourceLineInfo _lineInfo);
        -: 8233:
        -: 8234:        std::string tag;
        -: 8235:        SourceLineInfo lineInfo;
        -: 8236:    };
        -: 8237:
        -: 8238:} // end namespace Catch
        -: 8239:
        -: 8240:// end catch_tag_alias.h
        -: 8241:#include <map>
        -: 8242:
        -: 8243:namespace Catch {
        -: 8244:
        -: 8245:    class TagAliasRegistry : public ITagAliasRegistry {
        -: 8246:    public:
        -: 8247:        ~TagAliasRegistry() override;
        -: 8248:        TagAlias const* find( std::string const& alias ) const override;
        -: 8249:        std::string expandAliases( std::string const& unexpandedTestSpec ) const override;
        -: 8250:        void add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo );
        -: 8251:
        -: 8252:    private:
        -: 8253:        std::map<std::string, TagAlias> m_registry;
        -: 8254:    };
        -: 8255:
        -: 8256:} // end namespace Catch
        -: 8257:
        -: 8258:// end catch_tag_alias_registry.h
        -: 8259:// start catch_startup_exception_registry.h
        -: 8260:
        -: 8261:#include <vector>
        -: 8262:#include <exception>
        -: 8263:
        -: 8264:namespace Catch {
        -: 8265:
        -: 8266:    class StartupExceptionRegistry {
        -: 8267:    public:
        -: 8268:        void add(std::exception_ptr const& exception) noexcept;
        -: 8269:        std::vector<std::exception_ptr> const& getExceptions() const noexcept;
        -: 8270:    private:
        -: 8271:        std::vector<std::exception_ptr> m_exceptions;
        -: 8272:    };
        -: 8273:
        -: 8274:} // end namespace Catch
        -: 8275:
        -: 8276:// end catch_startup_exception_registry.h
        -: 8277:namespace Catch {
        -: 8278:
        -: 8279:    namespace {
        -: 8280:
        -: 8281:        class RegistryHub : public IRegistryHub, public IMutableRegistryHub,
        -: 8282:                            private NonCopyable {
        -: 8283:
        -: 8284:        public: // IRegistryHub
        1: 8285:            RegistryHub() = default;
        2: 8286:            IReporterRegistry const& getReporterRegistry() const override {
        2: 8287:                return m_reporterRegistry;
        -: 8288:            }
        1: 8289:            ITestCaseRegistry const& getTestCaseRegistry() const override {
        1: 8290:                return m_testCaseRegistry;
        -: 8291:            }
    #####: 8292:            IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() override {
    #####: 8293:                return m_exceptionTranslatorRegistry;
        -: 8294:            }
        1: 8295:            ITagAliasRegistry const& getTagAliasRegistry() const override {
        1: 8296:                return m_tagAliasRegistry;
        -: 8297:            }
        1: 8298:            StartupExceptionRegistry const& getStartupExceptionRegistry() const override {
        1: 8299:                return m_exceptionRegistry;
        -: 8300:            }
        -: 8301:
        -: 8302:        public: // IMutableRegistryHub
        4: 8303:            void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) override {
        4: 8304:                m_reporterRegistry.registerReporter( name, factory );
        4: 8305:            }
    #####: 8306:            void registerListener( IReporterFactoryPtr const& factory ) override {
    #####: 8307:                m_reporterRegistry.registerListener( factory );
    #####: 8308:            }
        4: 8309:            void registerTest( TestCase const& testInfo ) override {
        4: 8310:                m_testCaseRegistry.registerTest( testInfo );
        4: 8311:            }
    #####: 8312:            void registerTranslator( const IExceptionTranslator* translator ) override {
    #####: 8313:                m_exceptionTranslatorRegistry.registerTranslator( translator );
    #####: 8314:            }
    #####: 8315:            void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) override {
    #####: 8316:                m_tagAliasRegistry.add( alias, tag, lineInfo );
    #####: 8317:            }
    #####: 8318:            void registerStartupException() noexcept override {
    #####: 8319:                m_exceptionRegistry.add(std::current_exception());
    #####: 8320:            }
        -: 8321:
        -: 8322:        private:
        -: 8323:            TestRegistry m_testCaseRegistry;
        -: 8324:            ReporterRegistry m_reporterRegistry;
        -: 8325:            ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
        -: 8326:            TagAliasRegistry m_tagAliasRegistry;
        -: 8327:            StartupExceptionRegistry m_exceptionRegistry;
        -: 8328:        };
        -: 8329:
        -: 8330:        // Single, global, instance
       15: 8331:        RegistryHub*& getTheRegistryHub() {
        -: 8332:            static RegistryHub* theRegistryHub = nullptr;
       15: 8333:            if( !theRegistryHub )
        1: 8334:                theRegistryHub = new RegistryHub();
       15: 8335:            return theRegistryHub;
        -: 8336:        }
        -: 8337:    }
        -: 8338:
        5: 8339:    IRegistryHub& getRegistryHub() {
        5: 8340:        return *getTheRegistryHub();
        -: 8341:    }
        8: 8342:    IMutableRegistryHub& getMutableRegistryHub() {
        8: 8343:        return *getTheRegistryHub();
        -: 8344:    }
        1: 8345:    void cleanUp() {
        1: 8346:        delete getTheRegistryHub();
        1: 8347:        getTheRegistryHub() = nullptr;
        1: 8348:        cleanUpContext();
        1: 8349:        ReusableStringStream::cleanup();
        1: 8350:    }
    #####: 8351:    std::string translateActiveException() {
    #####: 8352:        return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
        -: 8353:    }
        -: 8354:
        -: 8355:} // end namespace Catch
        -: 8356:// end catch_registry_hub.cpp
        -: 8357:// start catch_reporter_registry.cpp
        -: 8358:
        -: 8359:namespace Catch {
        -: 8360:
       1*: 8361:    ReporterRegistry::~ReporterRegistry() = default;
------------------
_ZN5Catch16ReporterRegistryD0Ev:
    #####: 8361:    ReporterRegistry::~ReporterRegistry() = default;
------------------
_ZN5Catch16ReporterRegistryD2Ev:
        1: 8361:    ReporterRegistry::~ReporterRegistry() = default;
------------------
        -: 8362:
        1: 8363:    IStreamingReporterPtr ReporterRegistry::create( std::string const& name, IConfigPtr const& config ) const {
        1: 8364:        auto it =  m_factories.find( name );
        1: 8365:        if( it == m_factories.end() )
    #####: 8366:            return nullptr;
        2: 8367:        return it->second->create( ReporterConfig( config ) );
        -: 8368:    }
        -: 8369:
        4: 8370:    void ReporterRegistry::registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) {
        4: 8371:        m_factories.emplace(name, factory);
        4: 8372:    }
    #####: 8373:    void ReporterRegistry::registerListener( IReporterFactoryPtr const& factory ) {
    #####: 8374:        m_listeners.push_back( factory );
    #####: 8375:    }
        -: 8376:
    #####: 8377:    IReporterRegistry::FactoryMap const& ReporterRegistry::getFactories() const {
    #####: 8378:        return m_factories;
        -: 8379:    }
        1: 8380:    IReporterRegistry::Listeners const& ReporterRegistry::getListeners() const {
        1: 8381:        return m_listeners;
        -: 8382:    }
        -: 8383:
        -: 8384:}
        -: 8385:// end catch_reporter_registry.cpp
        -: 8386:// start catch_result_type.cpp
        -: 8387:
        -: 8388:namespace Catch {
        -: 8389:
    #####: 8390:    bool isOk( ResultWas::OfType resultType ) {
    #####: 8391:        return ( resultType & ResultWas::FailureBit ) == 0;
        -: 8392:    }
    #####: 8393:    bool isJustInfo( int flags ) {
    #####: 8394:        return flags == ResultWas::Info;
        -: 8395:    }
        -: 8396:
    #####: 8397:    ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {
    #####: 8398:        return static_cast<ResultDisposition::Flags>( static_cast<int>( lhs ) | static_cast<int>( rhs ) );
        -: 8399:    }
        -: 8400:
    #####: 8401:    bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }
    #####: 8402:    bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }
        -: 8403:
        -: 8404:} // end namespace Catch
        -: 8405:// end catch_result_type.cpp
        -: 8406:// start catch_run_context.cpp
        -: 8407:
        -: 8408:#include <cassert>
        -: 8409:#include <algorithm>
        -: 8410:#include <sstream>
        -: 8411:
        -: 8412:namespace Catch {
        -: 8413:
        -: 8414:    class RedirectedStream {
        -: 8415:        std::ostream& m_originalStream;
        -: 8416:        std::ostream& m_redirectionStream;
        -: 8417:        std::streambuf* m_prevBuf;
        -: 8418:
        -: 8419:    public:
    #####: 8420:        RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream )
    #####: 8421:        :   m_originalStream( originalStream ),
    #####: 8422:            m_redirectionStream( redirectionStream ),
    #####: 8423:            m_prevBuf( m_originalStream.rdbuf() )
        -: 8424:        {
    #####: 8425:            m_originalStream.rdbuf( m_redirectionStream.rdbuf() );
    #####: 8426:        }
    #####: 8427:        ~RedirectedStream() {
    #####: 8428:            m_originalStream.rdbuf( m_prevBuf );
    #####: 8429:        }
        -: 8430:    };
        -: 8431:
        -: 8432:    class RedirectedStdOut {
        -: 8433:        ReusableStringStream m_rss;
        -: 8434:        RedirectedStream m_cout;
        -: 8435:    public:
    #####: 8436:        RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) {}
    #####: 8437:        auto str() const -> std::string { return m_rss.str(); }
        -: 8438:    };
        -: 8439:
        -: 8440:    // StdErr has two constituent streams in C++, std::cerr and std::clog
        -: 8441:    // This means that we need to redirect 2 streams into 1 to keep proper
        -: 8442:    // order of writes
        -: 8443:    class RedirectedStdErr {
        -: 8444:        ReusableStringStream m_rss;
        -: 8445:        RedirectedStream m_cerr;
        -: 8446:        RedirectedStream m_clog;
        -: 8447:    public:
    #####: 8448:        RedirectedStdErr()
    #####: 8449:        :   m_cerr( Catch::cerr(), m_rss.get() ),
    #####: 8450:            m_clog( Catch::clog(), m_rss.get() )
    #####: 8451:        {}
    #####: 8452:        auto str() const -> std::string { return m_rss.str(); }
        -: 8453:    };
        -: 8454:
        1: 8455:    RunContext::RunContext(IConfigPtr const& _config, IStreamingReporterPtr&& reporter)
        1: 8456:    :   m_runInfo(_config->name()),
        1: 8457:        m_context(getCurrentMutableContext()),
        1: 8458:        m_config(_config),
        1: 8459:        m_reporter(std::move(reporter)),
        1: 8460:        m_lastAssertionInfo{ StringRef(), SourceLineInfo("",0), StringRef(), ResultDisposition::Normal },
        5: 8461:        m_includeSuccessfulResults( m_config->includeSuccessfulResults() )
        -: 8462:    {
        1: 8463:        m_context.setRunner(this);
        1: 8464:        m_context.setConfig(m_config);
        1: 8465:        m_context.setResultCapture(this);
        1: 8466:        m_reporter->testRunStarting(m_runInfo);
        1: 8467:    }
        -: 8468:
       1*: 8469:    RunContext::~RunContext() {
        1: 8470:        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));
       1*: 8471:    }
------------------
_ZN5Catch10RunContextD0Ev:
    #####: 8469:    RunContext::~RunContext() {
        -: 8470:        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));
    #####: 8471:    }
------------------
_ZN5Catch10RunContextD2Ev:
        1: 8469:    RunContext::~RunContext() {
        1: 8470:        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));
        1: 8471:    }
------------------
        -: 8472:
        1: 8473:    void RunContext::testGroupStarting(std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount) {
        1: 8474:        m_reporter->testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));
        1: 8475:    }
        -: 8476:
        1: 8477:    void RunContext::testGroupEnded(std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount) {
        1: 8478:        m_reporter->testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));
        1: 8479:    }
        -: 8480:
        4: 8481:    Totals RunContext::runTest(TestCase const& testCase) {
        4: 8482:        Totals prevTotals = m_totals;
        -: 8483:
        4: 8484:        std::string redirectedCout;
        4: 8485:        std::string redirectedCerr;
        -: 8486:
        4: 8487:        auto const& testInfo = testCase.getTestCaseInfo();
        -: 8488:
        4: 8489:        m_reporter->testCaseStarting(testInfo);
        -: 8490:
        4: 8491:        m_activeTestCase = &testCase;
        -: 8492:
        4: 8493:        ITracker& rootTracker = m_trackerContext.startRun();
       4*: 8494:        assert(rootTracker.isSectionTracker());
        4: 8495:        static_cast<SectionTracker&>(rootTracker).addInitialFilters(m_config->getSectionsToRun());
        -: 8496:        do {
       10: 8497:            m_trackerContext.startCycle();
       10: 8498:            m_testCaseTracker = &SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));
       10: 8499:            runCurrentTest(redirectedCout, redirectedCerr);
       10: 8500:        } while (!m_testCaseTracker->isSuccessfullyCompleted() && !aborting());
        -: 8501:
        4: 8502:        Totals deltaTotals = m_totals.delta(prevTotals);
       4*: 8503:        if (testInfo.expectedToFail() && deltaTotals.testCases.passed > 0) {
    #####: 8504:            deltaTotals.assertions.failed++;
    #####: 8505:            deltaTotals.testCases.passed--;
    #####: 8506:            deltaTotals.testCases.failed++;
        -: 8507:        }
        4: 8508:        m_totals.testCases += deltaTotals.testCases;
        8: 8509:        m_reporter->testCaseEnded(TestCaseStats(testInfo,
        -: 8510:                                  deltaTotals,
        -: 8511:                                  redirectedCout,
        -: 8512:                                  redirectedCerr,
        4: 8513:                                  aborting()));
        -: 8514:
        4: 8515:        m_activeTestCase = nullptr;
        4: 8516:        m_testCaseTracker = nullptr;
        -: 8517:
        8: 8518:        return deltaTotals;
        4: 8519:    }
        -: 8520:
    #####: 8521:    IConfigPtr RunContext::config() const {
    #####: 8522:        return m_config;
        -: 8523:    }
        -: 8524:
    #####: 8525:    IStreamingReporter& RunContext::reporter() const {
    #####: 8526:        return *m_reporter;
        -: 8527:    }
        -: 8528:
    #####: 8529:    void RunContext::assertionEnded(AssertionResult const & result) {
    #####: 8530:        if (result.getResultType() == ResultWas::Ok) {
    #####: 8531:            m_totals.assertions.passed++;
    #####: 8532:            m_lastAssertionPassed = true;
    #####: 8533:        } else if (!result.isOk()) {
    #####: 8534:            m_lastAssertionPassed = false;
    #####: 8535:            if( m_activeTestCase->getTestCaseInfo().okToFail() )
    #####: 8536:                m_totals.assertions.failedButOk++;
        -: 8537:            else
    #####: 8538:                m_totals.assertions.failed++;
        -: 8539:        }
        -: 8540:        else {
    #####: 8541:            m_lastAssertionPassed = true;
        -: 8542:        }
        -: 8543:
        -: 8544:        // We have no use for the return value (whether messages should be cleared), because messages were made scoped
        -: 8545:        // and should be let to clear themselves out.
    #####: 8546:        static_cast<void>(m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals)));
        -: 8547:
        -: 8548:        // Reset working state
    #####: 8549:        resetAssertionInfo();
    #####: 8550:        m_lastResult = result;
    #####: 8551:    }
       41: 8552:    void RunContext::resetAssertionInfo() {
       41: 8553:        m_lastAssertionInfo.macroName = StringRef();
       41: 8554:        m_lastAssertionInfo.capturedExpression = "{Unknown expression after the reported line}"_sr;
       41: 8555:    }
        -: 8556:
       33: 8557:    bool RunContext::sectionStarted(SectionInfo const & sectionInfo, Counts & assertions) {
       33: 8558:        ITracker& sectionTracker = SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));
       33: 8559:        if (!sectionTracker.isOpen())
       24: 8560:            return false;
        9: 8561:        m_activeSections.push_back(&sectionTracker);
        -: 8562:
        9: 8563:        m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;
        -: 8564:
        9: 8565:        m_reporter->sectionStarting(sectionInfo);
        -: 8566:
        9: 8567:        assertions = m_totals.assertions;
        -: 8568:
        9: 8569:        return true;
        -: 8570:    }
        -: 8571:
       19: 8572:    bool RunContext::testForMissingAssertions(Counts& assertions) {
       19: 8573:        if (assertions.total() != 0)
       19: 8574:            return false;
    #####: 8575:        if (!m_config->warnAboutMissingAssertions())
    #####: 8576:            return false;
    #####: 8577:        if (m_trackerContext.currentTracker().hasChildren())
    #####: 8578:            return false;
    #####: 8579:        m_totals.assertions.failed++;
    #####: 8580:        assertions.failed++;
    #####: 8581:        return true;
        -: 8582:    }
        -: 8583:
        9: 8584:    void RunContext::sectionEnded(SectionEndInfo const & endInfo) {
        9: 8585:        Counts assertions = m_totals.assertions - endInfo.prevAssertions;
        9: 8586:        bool missingAssertions = testForMissingAssertions(assertions);
        -: 8587:
        9: 8588:        if (!m_activeSections.empty()) {
        9: 8589:            m_activeSections.back()->close();
        9: 8590:            m_activeSections.pop_back();
        -: 8591:        }
        -: 8592:
        9: 8593:        m_reporter->sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));
        9: 8594:        m_messages.clear();
        9: 8595:    }
        -: 8596:
    #####: 8597:    void RunContext::sectionEndedEarly(SectionEndInfo const & endInfo) {
    #####: 8598:        if (m_unfinishedSections.empty())
    #####: 8599:            m_activeSections.back()->fail();
        -: 8600:        else
    #####: 8601:            m_activeSections.back()->close();
    #####: 8602:        m_activeSections.pop_back();
        -: 8603:
    #####: 8604:        m_unfinishedSections.push_back(endInfo);
    #####: 8605:    }
    #####: 8606:    void RunContext::benchmarkStarting( BenchmarkInfo const& info ) {
    #####: 8607:        m_reporter->benchmarkStarting( info );
    #####: 8608:    }
    #####: 8609:    void RunContext::benchmarkEnded( BenchmarkStats const& stats ) {
    #####: 8610:        m_reporter->benchmarkEnded( stats );
    #####: 8611:    }
        -: 8612:
    #####: 8613:    void RunContext::pushScopedMessage(MessageInfo const & message) {
    #####: 8614:        m_messages.push_back(message);
    #####: 8615:    }
        -: 8616:
    #####: 8617:    void RunContext::popScopedMessage(MessageInfo const & message) {
    #####: 8618:        m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());
    #####: 8619:    }
        -: 8620:
    #####: 8621:    std::string RunContext::getCurrentTestName() const {
    #####: 8622:        return m_activeTestCase
    #####: 8623:            ? m_activeTestCase->getTestCaseInfo().name
    #####: 8624:            : std::string();
        -: 8625:    }
        -: 8626:
    #####: 8627:    const AssertionResult * RunContext::getLastResult() const {
    #####: 8628:        return &(*m_lastResult);
        -: 8629:    }
        -: 8630:
    #####: 8631:    void RunContext::exceptionEarlyReported() {
    #####: 8632:        m_shouldReportUnexpected = false;
    #####: 8633:    }
        -: 8634:
    #####: 8635:    void RunContext::handleFatalErrorCondition( StringRef message ) {
        -: 8636:        // First notify reporter that bad things happened
    #####: 8637:        m_reporter->fatalErrorEncountered(message);
        -: 8638:
        -: 8639:        // Don't rebuild the result -- the stringification itself can cause more fatal errors
        -: 8640:        // Instead, fake a result data.
    #####: 8641:        AssertionResultData tempResult( ResultWas::FatalErrorCondition, { false } );
    #####: 8642:        tempResult.message = message;
    #####: 8643:        AssertionResult result(m_lastAssertionInfo, tempResult);
        -: 8644:
    #####: 8645:        assertionEnded(result);
        -: 8646:
    #####: 8647:        handleUnfinishedSections();
        -: 8648:
        -: 8649:        // Recreate section for test case (as we will lose the one that was in scope)
    #####: 8650:        auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
    #####: 8651:        SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description);
        -: 8652:
    #####: 8653:        Counts assertions;
    #####: 8654:        assertions.failed = 1;
    #####: 8655:        SectionStats testCaseSectionStats(testCaseSection, assertions, 0, false);
    #####: 8656:        m_reporter->sectionEnded(testCaseSectionStats);
        -: 8657:
    #####: 8658:        auto const& testInfo = m_activeTestCase->getTestCaseInfo();
        -: 8659:
    #####: 8660:        Totals deltaTotals;
    #####: 8661:        deltaTotals.testCases.failed = 1;
    #####: 8662:        deltaTotals.assertions.failed = 1;
    #####: 8663:        m_reporter->testCaseEnded(TestCaseStats(testInfo,
        -: 8664:                                  deltaTotals,
    #####: 8665:                                  std::string(),
    #####: 8666:                                  std::string(),
        -: 8667:                                  false));
    #####: 8668:        m_totals.testCases.failed++;
    #####: 8669:        testGroupEnded(std::string(), m_totals, 1, 1);
    #####: 8670:        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, false));
    #####: 8671:    }
        -: 8672:
    #####: 8673:    bool RunContext::lastAssertionPassed() {
    #####: 8674:         return m_lastAssertionPassed;
        -: 8675:    }
        -: 8676:
       41: 8677:    void RunContext::assertionPassed() {
       41: 8678:        m_lastAssertionPassed = true;
       41: 8679:        ++m_totals.assertions.passed;
       41: 8680:        resetAssertionInfo();
       41: 8681:    }
        -: 8682:
       16: 8683:    bool RunContext::aborting() const {
       16: 8684:        return m_totals.assertions.failed == static_cast<std::size_t>(m_config->abortAfter());
        -: 8685:    }
        -: 8686:
       10: 8687:    void RunContext::runCurrentTest(std::string & redirectedCout, std::string & redirectedCerr) {
       10: 8688:        auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
       10: 8689:        SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description);
       10: 8690:        m_reporter->sectionStarting(testCaseSection);
       10: 8691:        Counts prevAssertions = m_totals.assertions;
       10: 8692:        double duration = 0;
       10: 8693:        m_shouldReportUnexpected = true;
       10: 8694:        m_lastAssertionInfo = { "TEST_CASE"_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal };
        -: 8695:
       10: 8696:        seedRng(*m_config);
        -: 8697:
       10: 8698:        Timer timer;
        -: 8699:        try {
       10: 8700:            if (m_reporter->getPreferences().shouldRedirectStdOut) {
    #####: 8701:                RedirectedStdOut redirectedStdOut;
    #####: 8702:                RedirectedStdErr redirectedStdErr;
    #####: 8703:                timer.start();
    #####: 8704:                invokeActiveTestCase();
    #####: 8705:                redirectedCout += redirectedStdOut.str();
    #####: 8706:                redirectedCerr += redirectedStdErr.str();
        -: 8707:
    #####: 8708:            } else {
       10: 8709:                timer.start();
       10: 8710:                invokeActiveTestCase();
        -: 8711:            }
       10: 8712:            duration = timer.getElapsedSeconds();
    =====: 8713:        } catch (TestFailureException&) {
        -: 8714:            // This just means the test was aborted due to failure
    =====: 8715:        } catch (...) {
        -: 8716:            // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions
        -: 8717:            // are reported without translation at the point of origin.
    =====: 8718:            if( m_shouldReportUnexpected ) {
    =====: 8719:                AssertionReaction dummyReaction;
    =====: 8720:                handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );
        -: 8721:            }
    =====: 8722:        }
       10: 8723:        Counts assertions = m_totals.assertions - prevAssertions;
       10: 8724:        bool missingAssertions = testForMissingAssertions(assertions);
        -: 8725:
       10: 8726:        m_testCaseTracker->close();
       10: 8727:        handleUnfinishedSections();
       10: 8728:        m_messages.clear();
        -: 8729:
       10: 8730:        SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);
       10: 8731:        m_reporter->sectionEnded(testCaseSectionStats);
       10: 8732:    }
        -: 8733:
       10: 8734:    void RunContext::invokeActiveTestCase() {
       10: 8735:        FatalConditionHandler fatalConditionHandler; // Handle signals
       10: 8736:        m_activeTestCase->invoke();
       10: 8737:        fatalConditionHandler.reset();
       10: 8738:    }
        -: 8739:
       10: 8740:    void RunContext::handleUnfinishedSections() {
        -: 8741:        // If sections ended prematurely due to an exception we stored their
        -: 8742:        // infos here so we can tear them down outside the unwind process.
       20: 8743:        for (auto it = m_unfinishedSections.rbegin(),
       10: 8744:             itEnd = m_unfinishedSections.rend();
       10: 8745:             it != itEnd;
    #####: 8746:             ++it)
    #####: 8747:            sectionEnded(*it);
       10: 8748:        m_unfinishedSections.clear();
       10: 8749:    }
        -: 8750:
       41: 8751:    void RunContext::handleExpr(
        -: 8752:        AssertionInfo const& info,
        -: 8753:        ITransientExpression const& expr,
        -: 8754:        AssertionReaction& reaction
        -: 8755:    ) {
       41: 8756:        m_reporter->assertionStarting( info );
        -: 8757:
       41: 8758:        bool negated = isFalseTest( info.resultDisposition );
       41: 8759:        bool result = expr.getResult() != negated;
        -: 8760:
       41: 8761:        if( result ) {
       41: 8762:            if (!m_includeSuccessfulResults) {
       41: 8763:                assertionPassed();
        -: 8764:            }
        -: 8765:            else {
    #####: 8766:                reportExpr(info, ResultWas::Ok, &expr, negated);
        -: 8767:            }
        -: 8768:        }
        -: 8769:        else {
    #####: 8770:            reportExpr(info, ResultWas::ExpressionFailed, &expr, negated );
    #####: 8771:            populateReaction( reaction );
        -: 8772:        }
       41: 8773:    }
    #####: 8774:    void RunContext::reportExpr(
        -: 8775:            AssertionInfo const &info,
        -: 8776:            ResultWas::OfType resultType,
        -: 8777:            ITransientExpression const *expr,
        -: 8778:            bool negated ) {
        -: 8779:
    #####: 8780:        m_lastAssertionInfo = info;
    #####: 8781:        AssertionResultData data( resultType, LazyExpression( negated ) );
        -: 8782:
    #####: 8783:        AssertionResult assertionResult{ info, data };
    #####: 8784:        assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;
        -: 8785:
    #####: 8786:        assertionEnded( assertionResult );
    #####: 8787:    }
        -: 8788:
    #####: 8789:    void RunContext::handleMessage(
        -: 8790:            AssertionInfo const& info,
        -: 8791:            ResultWas::OfType resultType,
        -: 8792:            StringRef const& message,
        -: 8793:            AssertionReaction& reaction
        -: 8794:    ) {
    #####: 8795:        m_reporter->assertionStarting( info );
        -: 8796:
    #####: 8797:        m_lastAssertionInfo = info;
        -: 8798:
    #####: 8799:        AssertionResultData data( resultType, LazyExpression( false ) );
    #####: 8800:        data.message = message;
    #####: 8801:        AssertionResult assertionResult{ m_lastAssertionInfo, data };
    #####: 8802:        assertionEnded( assertionResult );
    #####: 8803:        if( !assertionResult.isOk() )
    #####: 8804:            populateReaction( reaction );
    #####: 8805:    }
    #####: 8806:    void RunContext::handleUnexpectedExceptionNotThrown(
        -: 8807:            AssertionInfo const& info,
        -: 8808:            AssertionReaction& reaction
        -: 8809:    ) {
    #####: 8810:        handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);
    #####: 8811:    }
        -: 8812:
    #####: 8813:    void RunContext::handleUnexpectedInflightException(
        -: 8814:            AssertionInfo const& info,
        -: 8815:            std::string const& message,
        -: 8816:            AssertionReaction& reaction
        -: 8817:    ) {
    #####: 8818:        m_lastAssertionInfo = info;
        -: 8819:
    #####: 8820:        AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
    #####: 8821:        data.message = message;
    #####: 8822:        AssertionResult assertionResult{ info, data };
    #####: 8823:        assertionEnded( assertionResult );
    #####: 8824:        populateReaction( reaction );
    #####: 8825:    }
        -: 8826:
    #####: 8827:    void RunContext::populateReaction( AssertionReaction& reaction ) {
    #####: 8828:        reaction.shouldDebugBreak = m_config->shouldDebugBreak();
    #####: 8829:        reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition & ResultDisposition::Normal);
    #####: 8830:    }
        -: 8831:
    #####: 8832:    void RunContext::handleIncomplete(
        -: 8833:            AssertionInfo const& info
        -: 8834:    ) {
    #####: 8835:        m_lastAssertionInfo = info;
        -: 8836:
    #####: 8837:        AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
    #####: 8838:        data.message = "Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE";
    #####: 8839:        AssertionResult assertionResult{ info, data };
    #####: 8840:        assertionEnded( assertionResult );
    #####: 8841:    }
    #####: 8842:    void RunContext::handleNonExpr(
        -: 8843:            AssertionInfo const &info,
        -: 8844:            ResultWas::OfType resultType,
        -: 8845:            AssertionReaction &reaction
        -: 8846:    ) {
    #####: 8847:        m_lastAssertionInfo = info;
        -: 8848:
    #####: 8849:        AssertionResultData data( resultType, LazyExpression( false ) );
    #####: 8850:        AssertionResult assertionResult{ info, data };
    #####: 8851:        assertionEnded( assertionResult );
        -: 8852:
    #####: 8853:        if( !assertionResult.isOk() )
    #####: 8854:            populateReaction( reaction );
    #####: 8855:    }
        -: 8856:
       83: 8857:    IResultCapture& getResultCapture() {
       83: 8858:        if (auto* capture = getCurrentContext().getResultCapture())
       83: 8859:            return *capture;
        -: 8860:        else
    #####: 8861:            CATCH_INTERNAL_ERROR("No result capture instance");
        -: 8862:    }
        -: 8863:}
        -: 8864:// end catch_run_context.cpp
        -: 8865:// start catch_section.cpp
        -: 8866:
        -: 8867:namespace Catch {
        -: 8868:
       33: 8869:    Section::Section( SectionInfo const& info )
       33: 8870:    :   m_info( info ),
       33: 8871:        m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )
        -: 8872:    {
       33: 8873:        m_timer.start();
       33: 8874:    }
        -: 8875:
      33*: 8876:    Section::~Section() {
       33: 8877:        if( m_sectionIncluded ) {
        9: 8878:            SectionEndInfo endInfo( m_info, m_assertions, m_timer.getElapsedSeconds() );
        9: 8879:            if( uncaught_exceptions() )
    #####: 8880:                getResultCapture().sectionEndedEarly( endInfo );
        -: 8881:            else
        9: 8882:                getResultCapture().sectionEnded( endInfo );
        9: 8883:        }
      33*: 8884:    }
------------------
_ZN5Catch7SectionD0Ev:
    #####: 8876:    Section::~Section() {
        -: 8877:        if( m_sectionIncluded ) {
        -: 8878:            SectionEndInfo endInfo( m_info, m_assertions, m_timer.getElapsedSeconds() );
        -: 8879:            if( uncaught_exceptions() )
        -: 8880:                getResultCapture().sectionEndedEarly( endInfo );
        -: 8881:            else
        -: 8882:                getResultCapture().sectionEnded( endInfo );
        -: 8883:        }
    #####: 8884:    }
------------------
_ZN5Catch7SectionD2Ev:
       33: 8876:    Section::~Section() {
       33: 8877:        if( m_sectionIncluded ) {
        9: 8878:            SectionEndInfo endInfo( m_info, m_assertions, m_timer.getElapsedSeconds() );
        9: 8879:            if( uncaught_exceptions() )
    #####: 8880:                getResultCapture().sectionEndedEarly( endInfo );
        -: 8881:            else
        9: 8882:                getResultCapture().sectionEnded( endInfo );
        9: 8883:        }
       33: 8884:    }
------------------
        -: 8885:
        -: 8886:    // This indicates whether the section should be executed or not
       33: 8887:    Section::operator bool() const {
       33: 8888:        return m_sectionIncluded;
        -: 8889:    }
        -: 8890:
        -: 8891:} // end namespace Catch
        -: 8892:// end catch_section.cpp
        -: 8893:// start catch_section_info.cpp
        -: 8894:
        -: 8895:namespace Catch {
        -: 8896:
       43: 8897:    SectionInfo::SectionInfo
        -: 8898:        (   SourceLineInfo const& _lineInfo,
        -: 8899:            std::string const& _name,
       43: 8900:            std::string const& _description )
       43: 8901:    :   name( _name ),
       43: 8902:        description( _description ),
       43: 8903:        lineInfo( _lineInfo )
       43: 8904:    {}
        -: 8905:
        9: 8906:    SectionEndInfo::SectionEndInfo( SectionInfo const& _sectionInfo, Counts const& _prevAssertions, double _durationInSeconds )
        9: 8907:    : sectionInfo( _sectionInfo ), prevAssertions( _prevAssertions ), durationInSeconds( _durationInSeconds )
        9: 8908:    {}
        -: 8909:
        -: 8910:} // end namespace Catch
        -: 8911:// end catch_section_info.cpp
        -: 8912:// start catch_session.cpp
        -: 8913:
        -: 8914:// start catch_session.h
        -: 8915:
        -: 8916:#include <memory>
        -: 8917:
        -: 8918:namespace Catch {
        -: 8919:
        -: 8920:    class Session : NonCopyable {
        -: 8921:    public:
        -: 8922:
        -: 8923:        Session();
        -: 8924:        ~Session() override;
        -: 8925:
        -: 8926:        void showHelp() const;
        -: 8927:        void libIdentify();
        -: 8928:
        -: 8929:        int applyCommandLine( int argc, char const * const * argv );
        -: 8930:
        -: 8931:        void useConfigData( ConfigData const& configData );
        -: 8932:
        -: 8933:        int run( int argc, char* argv[] );
        -: 8934:    #if defined(CATCH_CONFIG_WCHAR) && defined(WIN32) && defined(UNICODE)
        -: 8935:        int run( int argc, wchar_t* const argv[] );
        -: 8936:    #endif
        -: 8937:        int run();
        -: 8938:
        -: 8939:        clara::Parser const& cli() const;
        -: 8940:        void cli( clara::Parser const& newParser );
        -: 8941:        ConfigData& configData();
        -: 8942:        Config& config();
        -: 8943:    private:
        -: 8944:        int runInternal();
        -: 8945:
        -: 8946:        clara::Parser m_cli;
        -: 8947:        ConfigData m_configData;
        -: 8948:        std::shared_ptr<Config> m_config;
        -: 8949:        bool m_startupExceptions = false;
        -: 8950:    };
        -: 8951:
        -: 8952:} // end namespace Catch
        -: 8953:
        -: 8954:// end catch_session.h
        -: 8955:// start catch_version.h
        -: 8956:
        -: 8957:#include <iosfwd>
        -: 8958:
        -: 8959:namespace Catch {
        -: 8960:
        -: 8961:    // Versioning information
        -: 8962:    struct Version {
        -: 8963:        Version( Version const& ) = delete;
        -: 8964:        Version& operator=( Version const& ) = delete;
        -: 8965:        Version(    unsigned int _majorVersion,
        -: 8966:                    unsigned int _minorVersion,
        -: 8967:                    unsigned int _patchNumber,
        -: 8968:                    char const * const _branchName,
        -: 8969:                    unsigned int _buildNumber );
        -: 8970:
        -: 8971:        unsigned int const majorVersion;
        -: 8972:        unsigned int const minorVersion;
        -: 8973:        unsigned int const patchNumber;
        -: 8974:
        -: 8975:        // buildNumber is only used if branchName is not null
        -: 8976:        char const * const branchName;
        -: 8977:        unsigned int const buildNumber;
        -: 8978:
        -: 8979:        friend std::ostream& operator << ( std::ostream& os, Version const& version );
        -: 8980:    };
        -: 8981:
        -: 8982:    Version const& libraryVersion();
        -: 8983:}
        -: 8984:
        -: 8985:// end catch_version.h
        -: 8986:#include <cstdlib>
        -: 8987:#include <iomanip>
        -: 8988:
        -: 8989:namespace Catch {
        -: 8990:
        -: 8991:    namespace {
        -: 8992:        const int MaxExitCode = 255;
        -: 8993:
        1: 8994:        IStreamingReporterPtr createReporter(std::string const& reporterName, IConfigPtr const& config) {
        1: 8995:            auto reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);
       1*: 8996:            CATCH_ENFORCE(reporter, "No reporter registered with name: '" << reporterName << "'");
        -: 8997:
        1: 8998:            return reporter;
    =====: 8999:        }
        -: 9000:
        -: 9001:#ifndef CATCH_CONFIG_DEFAULT_REPORTER
        -: 9002:#define CATCH_CONFIG_DEFAULT_REPORTER "console"
        -: 9003:#endif
        -: 9004:
        1: 9005:        IStreamingReporterPtr makeReporter(std::shared_ptr<Config> const& config) {
        1: 9006:            auto const& reporterNames = config->getReporterNames();
        1: 9007:            if (reporterNames.empty())
        1: 9008:                return createReporter(CATCH_CONFIG_DEFAULT_REPORTER, config);
        -: 9009:
    #####: 9010:            IStreamingReporterPtr reporter;
    #####: 9011:            for (auto const& name : reporterNames)
    #####: 9012:                addReporter(reporter, createReporter(name, config));
    #####: 9013:            return reporter;
    #####: 9014:        }
        -: 9015:
        -: 9016:#undef CATCH_CONFIG_DEFAULT_REPORTER
        -: 9017:
        1: 9018:        void addListeners(IStreamingReporterPtr& reporters, IConfigPtr const& config) {
        1: 9019:            auto const& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();
       1*: 9020:            for (auto const& listener : listeners)
    #####: 9021:                addReporter(reporters, listener->create(Catch::ReporterConfig(config)));
        1: 9022:        }
        -: 9023:
        1: 9024:        Catch::Totals runTests(std::shared_ptr<Config> const& config) {
        1: 9025:            IStreamingReporterPtr reporter = makeReporter(config);
        1: 9026:            addListeners(reporter, config);
        -: 9027:
        1: 9028:            RunContext context(config, std::move(reporter));
        -: 9029:
        1: 9030:            Totals totals;
        -: 9031:
        1: 9032:            context.testGroupStarting(config->name(), 1, 1);
        -: 9033:
        1: 9034:            TestSpec testSpec = config->testSpec();
        -: 9035:
        1: 9036:            auto const& allTestCases = getAllTestCasesSorted(*config);
        5: 9037:            for (auto const& testCase : allTestCases) {
       4*: 9038:                if (!context.aborting() && matchTest(testCase, testSpec, *config))
        4: 9039:                    totals += context.runTest(testCase);
        -: 9040:                else
    #####: 9041:                    context.reporter().skipTest(testCase);
        -: 9042:            }
        -: 9043:
       1*: 9044:            if (config->warnAboutNoTests() && totals.testCases.total() == 0) {
    #####: 9045:                ReusableStringStream testConfig;
        -: 9046:
    #####: 9047:                bool first = true;
    #####: 9048:                for (const auto& input : config->getTestsOrTags()) {
    #####: 9049:                    if (!first) { testConfig << ' '; }
    #####: 9050:                    first = false;
    #####: 9051:                    testConfig << input;
        -: 9052:                }
        -: 9053:
    #####: 9054:                context.reporter().noMatchingTestCases(testConfig.str());
    #####: 9055:                totals.error = -1;
    #####: 9056:            }
        -: 9057:
        1: 9058:            context.testGroupEnded(config->name(), totals, 1, 1);
        2: 9059:            return totals;
        1: 9060:        }
        -: 9061:
    #####: 9062:        void applyFilenamesAsTags(Catch::IConfig const& config) {
    #####: 9063:            auto& tests = const_cast<std::vector<TestCase>&>(getAllTestCasesSorted(config));
    #####: 9064:            for (auto& testCase : tests) {
    #####: 9065:                auto tags = testCase.tags;
        -: 9066:
    #####: 9067:                std::string filename = testCase.lineInfo.file;
    #####: 9068:                auto lastSlash = filename.find_last_of("\\/");
    #####: 9069:                if (lastSlash != std::string::npos) {
    #####: 9070:                    filename.erase(0, lastSlash);
    #####: 9071:                    filename[0] = '#';
        -: 9072:                }
        -: 9073:
    #####: 9074:                auto lastDot = filename.find_last_of('.');
    #####: 9075:                if (lastDot != std::string::npos) {
    #####: 9076:                    filename.erase(lastDot);
        -: 9077:                }
        -: 9078:
    #####: 9079:                tags.push_back(std::move(filename));
    #####: 9080:                setTags(testCase, tags);
    #####: 9081:            }
    #####: 9082:        }
        -: 9083:
        -: 9084:    } // anon namespace
        -: 9085:
        1: 9086:    Session::Session() {
        -: 9087:        static bool alreadyInstantiated = false;
        1: 9088:        if( alreadyInstantiated ) {
    #####: 9089:            try         { CATCH_INTERNAL_ERROR( "Only one instance of Catch::Session can ever be used" ); }
    =====: 9090:            catch(...)  { getMutableRegistryHub().registerStartupException(); }
        -: 9091:        }
        -: 9092:
        1: 9093:        const auto& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();
        1: 9094:        if ( !exceptions.empty() ) {
    #####: 9095:            m_startupExceptions = true;
    #####: 9096:            Colour colourGuard( Colour::Red );
    #####: 9097:            Catch::cerr() << "Errors occurred during startup!" << '\n';
        -: 9098:            // iterate over all exceptions and notify user
    #####: 9099:            for ( const auto& ex_ptr : exceptions ) {
        -: 9100:                try {
    #####: 9101:                    std::rethrow_exception(ex_ptr);
    =====: 9102:                } catch ( std::exception const& ex ) {
    =====: 9103:                    Catch::cerr() << Column( ex.what() ).indent(2) << '\n';
    =====: 9104:                }
        -: 9105:            }
    #####: 9106:        }
        -: 9107:
        1: 9108:        alreadyInstantiated = true;
        1: 9109:        m_cli = makeCommandLineParser( m_configData );
        1: 9110:    }
       1*: 9111:    Session::~Session() {
        1: 9112:        Catch::cleanUp();
       1*: 9113:    }
------------------
_ZN5Catch7SessionD0Ev:
    #####: 9111:    Session::~Session() {
        -: 9112:        Catch::cleanUp();
    #####: 9113:    }
------------------
_ZN5Catch7SessionD2Ev:
        1: 9111:    Session::~Session() {
        1: 9112:        Catch::cleanUp();
        1: 9113:    }
------------------
        -: 9114:
    #####: 9115:    void Session::showHelp() const {
    #####: 9116:        Catch::cout()
    #####: 9117:                << "\nCatch v" << libraryVersion() << "\n"
    #####: 9118:                << m_cli << std::endl
    #####: 9119:                << "For more detailed usage please see the project docs\n" << std::endl;
    #####: 9120:    }
    #####: 9121:    void Session::libIdentify() {
    #####: 9122:        Catch::cout()
    #####: 9123:                << std::left << std::setw(16) << "description: " << "A Catch test executable\n"
    #####: 9124:                << std::left << std::setw(16) << "category: " << "testframework\n"
    #####: 9125:                << std::left << std::setw(16) << "framework: " << "Catch Test\n"
    #####: 9126:                << std::left << std::setw(16) << "version: " << libraryVersion() << std::endl;
    #####: 9127:    }
        -: 9128:
        1: 9129:    int Session::applyCommandLine( int argc, char const * const * argv ) {
        1: 9130:        if( m_startupExceptions )
    #####: 9131:            return 1;
        -: 9132:
        1: 9133:        auto result = m_cli.parse( clara::Args( argc, argv ) );
        1: 9134:        if( !result ) {
        -: 9135:            Catch::cerr()
    #####: 9136:                << Colour( Colour::Red )
    #####: 9137:                << "\nError(s) in input:\n"
    #####: 9138:                << Column( result.errorMessage() ).indent( 2 )
    #####: 9139:                << "\n\n";
    #####: 9140:            Catch::cerr() << "Run with -? for usage\n" << std::endl;
    #####: 9141:            return MaxExitCode;
        -: 9142:        }
        -: 9143:
        1: 9144:        if( m_configData.showHelp )
    #####: 9145:            showHelp();
        1: 9146:        if( m_configData.libIdentify )
    #####: 9147:            libIdentify();
        1: 9148:        m_config.reset();
        1: 9149:        return 0;
        1: 9150:    }
        -: 9151:
    #####: 9152:    void Session::useConfigData( ConfigData const& configData ) {
    #####: 9153:        m_configData = configData;
    #####: 9154:        m_config.reset();
    #####: 9155:    }
        -: 9156:
        1: 9157:    int Session::run( int argc, char* argv[] ) {
        1: 9158:        if( m_startupExceptions )
    #####: 9159:            return 1;
        1: 9160:        int returnCode = applyCommandLine( argc, argv );
        1: 9161:        if( returnCode == 0 )
        1: 9162:            returnCode = run();
        1: 9163:        return returnCode;
        -: 9164:    }
        -: 9165:
        -: 9166:#if defined(CATCH_CONFIG_WCHAR) && defined(WIN32) && defined(UNICODE)
        -: 9167:    int Session::run( int argc, wchar_t* const argv[] ) {
        -: 9168:
        -: 9169:        char **utf8Argv = new char *[ argc ];
        -: 9170:
        -: 9171:        for ( int i = 0; i < argc; ++i ) {
        -: 9172:            int bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, NULL, 0, NULL, NULL );
        -: 9173:
        -: 9174:            utf8Argv[ i ] = new char[ bufSize ];
        -: 9175:
        -: 9176:            WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, NULL, NULL );
        -: 9177:        }
        -: 9178:
        -: 9179:        int returnCode = run( argc, utf8Argv );
        -: 9180:
        -: 9181:        for ( int i = 0; i < argc; ++i )
        -: 9182:            delete [] utf8Argv[ i ];
        -: 9183:
        -: 9184:        delete [] utf8Argv;
        -: 9185:
        -: 9186:        return returnCode;
        -: 9187:    }
        -: 9188:#endif
        1: 9189:    int Session::run() {
        1: 9190:        if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeStart ) != 0 ) {
    #####: 9191:            Catch::cout() << "...waiting for enter/ return before starting" << std::endl;
    #####: 9192:            static_cast<void>(std::getchar());
        -: 9193:        }
        1: 9194:        int exitCode = runInternal();
        1: 9195:        if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeExit ) != 0 ) {
    #####: 9196:            Catch::cout() << "...waiting for enter/ return before exiting, with code: " << exitCode << std::endl;
    #####: 9197:            static_cast<void>(std::getchar());
        -: 9198:        }
        1: 9199:        return exitCode;
        -: 9200:    }
        -: 9201:
    #####: 9202:    clara::Parser const& Session::cli() const {
    #####: 9203:        return m_cli;
        -: 9204:    }
    #####: 9205:    void Session::cli( clara::Parser const& newParser ) {
    #####: 9206:        m_cli = newParser;
    #####: 9207:    }
    #####: 9208:    ConfigData& Session::configData() {
    #####: 9209:        return m_configData;
        -: 9210:    }
        2: 9211:    Config& Session::config() {
        2: 9212:        if( !m_config )
        1: 9213:            m_config = std::make_shared<Config>( m_configData );
        2: 9214:        return *m_config;
        -: 9215:    }
        -: 9216:
        1: 9217:    int Session::runInternal() {
        1: 9218:        if( m_startupExceptions )
    #####: 9219:            return 1;
        -: 9220:
        1: 9221:        if( m_configData.showHelp || m_configData.libIdentify )
    #####: 9222:            return 0;
        -: 9223:
        -: 9224:        try
        -: 9225:        {
        1: 9226:            config(); // Force config to be constructed
        -: 9227:
        1: 9228:            seedRng( *m_config );
        -: 9229:
        1: 9230:            if( m_configData.filenamesAsTags )
    #####: 9231:                applyFilenamesAsTags( *m_config );
        -: 9232:
        -: 9233:            // Handle list request
        1: 9234:            if( Option<std::size_t> listed = list( config() ) )
       1*: 9235:                return static_cast<int>( *listed );
        -: 9236:
        1: 9237:            auto totals = runTests( m_config );
        -: 9238:            // Note that on unices only the lower 8 bits are usually used, clamping
        -: 9239:            // the return value to 255 prevents false negative when some multiple
        -: 9240:            // of 256 tests has failed
        1: 9241:            return (std::min) (MaxExitCode, (std::max) (totals.error, static_cast<int>(totals.assertions.failed)));
        -: 9242:        }
    =====: 9243:        catch( std::exception& ex ) {
    =====: 9244:            Catch::cerr() << ex.what() << std::endl;
    =====: 9245:            return MaxExitCode;
    =====: 9246:        }
        -: 9247:    }
        -: 9248:
        -: 9249:} // end namespace Catch
        -: 9250:// end catch_session.cpp
        -: 9251:// start catch_startup_exception_registry.cpp
        -: 9252:
        -: 9253:namespace Catch {
    #####: 9254:    void StartupExceptionRegistry::add( std::exception_ptr const& exception ) noexcept {
        -: 9255:        try {
    #####: 9256:            m_exceptions.push_back(exception);
        -: 9257:        }
    =====: 9258:        catch(...) {
        -: 9259:            // If we run out of memory during start-up there's really not a lot more we can do about it
    =====: 9260:            std::terminate();
        -: 9261:        }
    #####: 9262:    }
        -: 9263:
        1: 9264:    std::vector<std::exception_ptr> const& StartupExceptionRegistry::getExceptions() const noexcept {
        1: 9265:        return m_exceptions;
        -: 9266:    }
        -: 9267:
        -: 9268:} // end namespace Catch
        -: 9269:// end catch_startup_exception_registry.cpp
        -: 9270:// start catch_stream.cpp
        -: 9271:
        -: 9272:#include <cstdio>
        -: 9273:#include <iostream>
        -: 9274:#include <fstream>
        -: 9275:#include <sstream>
        -: 9276:#include <vector>
        -: 9277:#include <memory>
        -: 9278:
        -: 9279:#if defined(__clang__)
        -: 9280:#    pragma clang diagnostic push
        -: 9281:#    pragma clang diagnostic ignored "-Wexit-time-destructors"
        -: 9282:#endif
        -: 9283:
        -: 9284:namespace Catch {
        -: 9285:
       1*: 9286:    Catch::IStream::~IStream() = default;
------------------
_ZN5Catch7IStreamD0Ev:
    #####: 9286:    Catch::IStream::~IStream() = default;
------------------
_ZN5Catch7IStreamD2Ev:
        1: 9286:    Catch::IStream::~IStream() = default;
------------------
        -: 9287:
        -: 9288:    namespace detail { namespace {
        -: 9289:        template<typename WriterF, std::size_t bufferSize=256>
        -: 9290:        class StreamBufImpl : public std::streambuf {
        -: 9291:            char data[bufferSize];
        -: 9292:            WriterF m_writer;
        -: 9293:
        -: 9294:        public:
    #####: 9295:            StreamBufImpl() {
    #####: 9296:                setp( data, data + sizeof(data) );
    #####: 9297:            }
        -: 9298:
    #####: 9299:            ~StreamBufImpl() noexcept {
    #####: 9300:                StreamBufImpl::sync();
    #####: 9301:            }
------------------
_ZN5Catch6detail12_GLOBAL__N_113StreamBufImplINS1_17OutputDebugWriterELm256EED0Ev:
    #####: 9299:            ~StreamBufImpl() noexcept {
        -: 9300:                StreamBufImpl::sync();
    #####: 9301:            }
------------------
_ZN5Catch6detail12_GLOBAL__N_113StreamBufImplINS1_17OutputDebugWriterELm256EED2Ev:
    #####: 9299:            ~StreamBufImpl() noexcept {
    #####: 9300:                StreamBufImpl::sync();
    #####: 9301:            }
------------------
        -: 9302:
        -: 9303:        private:
    #####: 9304:            int overflow( int c ) override {
    #####: 9305:                sync();
        -: 9306:
    #####: 9307:                if( c != EOF ) {
    #####: 9308:                    if( pbase() == epptr() )
    #####: 9309:                        m_writer( std::string( 1, static_cast<char>( c ) ) );
        -: 9310:                    else
    #####: 9311:                        sputc( static_cast<char>( c ) );
        -: 9312:                }
    #####: 9313:                return 0;
        -: 9314:            }
        -: 9315:
    #####: 9316:            int sync() override {
    #####: 9317:                if( pbase() != pptr() ) {
    #####: 9318:                    m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );
    #####: 9319:                    setp( pbase(), epptr() );
        -: 9320:                }
    #####: 9321:                return 0;
        -: 9322:            }
        -: 9323:        };
        -: 9324:
        -: 9325:        ///////////////////////////////////////////////////////////////////////////
        -: 9326:
        -: 9327:        struct OutputDebugWriter {
        -: 9328:
    #####: 9329:            void operator()( std::string const&str ) {
    #####: 9330:                writeToDebugConsole( str );
    #####: 9331:            }
        -: 9332:        };
        -: 9333:
        -: 9334:        ///////////////////////////////////////////////////////////////////////////
        -: 9335:
        -: 9336:        class FileStream : public IStream {
        -: 9337:            mutable std::ofstream m_ofs;
        -: 9338:        public:
    #####: 9339:            FileStream( StringRef filename ) {
    #####: 9340:                m_ofs.open( filename.c_str() );
    #####: 9341:                CATCH_ENFORCE( !m_ofs.fail(), "Unable to open file: '" << filename << "'" );
    #####: 9342:            }
    #####: 9343:            ~FileStream() override = default;
------------------
_ZN5Catch6detail12_GLOBAL__N_110FileStreamD0Ev:
    #####: 9343:            ~FileStream() override = default;
------------------
_ZN5Catch6detail12_GLOBAL__N_110FileStreamD2Ev:
    #####: 9343:            ~FileStream() override = default;
------------------
        -: 9344:        public: // IStream
    #####: 9345:            std::ostream& stream() const override {
    #####: 9346:                return m_ofs;
        -: 9347:            }
        -: 9348:        };
        -: 9349:
        -: 9350:        ///////////////////////////////////////////////////////////////////////////
        -: 9351:
        -: 9352:        class CoutStream : public IStream {
        -: 9353:            mutable std::ostream m_os;
        -: 9354:        public:
        -: 9355:            // Store the streambuf from cout up-front because
        -: 9356:            // cout may get redirected when running tests
        1: 9357:            CoutStream() : m_os( Catch::cout().rdbuf() ) {}
        2: 9358:            ~CoutStream() override = default;
------------------
_ZN5Catch6detail12_GLOBAL__N_110CoutStreamD0Ev:
        1: 9358:            ~CoutStream() override = default;
------------------
_ZN5Catch6detail12_GLOBAL__N_110CoutStreamD2Ev:
        1: 9358:            ~CoutStream() override = default;
------------------
        -: 9359:
        -: 9360:        public: // IStream
        1: 9361:            std::ostream& stream() const override { return m_os; }
        -: 9362:        };
        -: 9363:
        -: 9364:        ///////////////////////////////////////////////////////////////////////////
        -: 9365:
        -: 9366:        class DebugOutStream : public IStream {
        -: 9367:            std::unique_ptr<StreamBufImpl<OutputDebugWriter>> m_streamBuf;
        -: 9368:            mutable std::ostream m_os;
        -: 9369:        public:
    #####: 9370:            DebugOutStream()
    #####: 9371:            :   m_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),
    #####: 9372:                m_os( m_streamBuf.get() )
    #####: 9373:            {}
        -: 9374:
    #####: 9375:            ~DebugOutStream() override = default;
------------------
_ZN5Catch6detail12_GLOBAL__N_114DebugOutStreamD0Ev:
    #####: 9375:            ~DebugOutStream() override = default;
------------------
_ZN5Catch6detail12_GLOBAL__N_114DebugOutStreamD2Ev:
    #####: 9375:            ~DebugOutStream() override = default;
------------------
        -: 9376:
        -: 9377:        public: // IStream
    #####: 9378:            std::ostream& stream() const override { return m_os; }
        -: 9379:        };
        -: 9380:
        -: 9381:    }} // namespace anon::detail
        -: 9382:
        -: 9383:    ///////////////////////////////////////////////////////////////////////////
        -: 9384:
        1: 9385:    auto makeStream( StringRef const &filename ) -> IStream const* {
        1: 9386:        if( filename.empty() )
        1: 9387:            return new detail::CoutStream();
    #####: 9388:        else if( filename[0] == '%' ) {
    #####: 9389:            if( filename == "%debug" )
    #####: 9390:                return new detail::DebugOutStream();
        -: 9391:            else
    #####: 9392:                CATCH_ERROR( "Unrecognised stream: '" << filename << "'" );
        -: 9393:        }
        -: 9394:        else
    #####: 9395:            return new detail::FileStream( filename );
        -: 9396:    }
        -: 9397:
        -: 9398:    // This class encapsulates the idea of a pool of ostringstreams that can be reused.
        -: 9399:    struct StringStreams {
        -: 9400:        std::vector<std::unique_ptr<std::ostringstream>> m_streams;
        -: 9401:        std::vector<std::size_t> m_unused;
        -: 9402:        std::ostringstream m_referenceStream; // Used for copy state/ flags from
        -: 9403:        static StringStreams* s_instance;
        -: 9404:
    #####: 9405:        auto add() -> std::size_t {
    #####: 9406:            if( m_unused.empty() ) {
    #####: 9407:                m_streams.push_back( std::unique_ptr<std::ostringstream>( new std::ostringstream ) );
    #####: 9408:                return m_streams.size()-1;
        -: 9409:            }
        -: 9410:            else {
    #####: 9411:                auto index = m_unused.back();
    #####: 9412:                m_unused.pop_back();
    #####: 9413:                return index;
        -: 9414:            }
        -: 9415:        }
        -: 9416:
    #####: 9417:        void release( std::size_t index ) {
    #####: 9418:            m_streams[index]->copyfmt( m_referenceStream ); // Restore initial flags and other state
    #####: 9419:            m_unused.push_back(index);
    #####: 9420:        }
        -: 9421:
        -: 9422:        // !TBD: put in TLS
    #####: 9423:        static auto instance() -> StringStreams& {
    #####: 9424:            if( !s_instance )
    #####: 9425:                s_instance = new StringStreams();
    #####: 9426:            return *s_instance;
        -: 9427:        }
        1: 9428:        static void cleanup() {
       1*: 9429:            delete s_instance;
        1: 9430:            s_instance = nullptr;
        1: 9431:        }
        -: 9432:    };
        -: 9433:
        -: 9434:    StringStreams* StringStreams::s_instance = nullptr;
        -: 9435:
        1: 9436:    void ReusableStringStream::cleanup() {
        1: 9437:        StringStreams::cleanup();
        1: 9438:    }
        -: 9439:
    #####: 9440:    ReusableStringStream::ReusableStringStream()
    #####: 9441:    :   m_index( StringStreams::instance().add() ),
    #####: 9442:        m_oss( StringStreams::instance().m_streams[m_index].get() )
    #####: 9443:    {}
        -: 9444:
    #####: 9445:    ReusableStringStream::~ReusableStringStream() {
    #####: 9446:        static_cast<std::ostringstream*>( m_oss )->str("");
    #####: 9447:        m_oss->clear();
    #####: 9448:        StringStreams::instance().release( m_index );
    #####: 9449:    }
        -: 9450:
    #####: 9451:    auto ReusableStringStream::str() const -> std::string {
    #####: 9452:        return static_cast<std::ostringstream*>( m_oss )->str();
        -: 9453:    }
        -: 9454:
        -: 9455:    ///////////////////////////////////////////////////////////////////////////
        -: 9456:
        -: 9457:#ifndef CATCH_CONFIG_NOSTDOUT // If you #define this you must implement these functions
        9: 9458:    std::ostream& cout() { return std::cout; }
    #####: 9459:    std::ostream& cerr() { return std::cerr; }
    #####: 9460:    std::ostream& clog() { return std::clog; }
        -: 9461:#endif
        -: 9462:}
        -: 9463:
        -: 9464:#if defined(__clang__)
        -: 9465:#    pragma clang diagnostic pop
        -: 9466:#endif
        -: 9467:// end catch_stream.cpp
        -: 9468:// start catch_string_manip.cpp
        -: 9469:
        -: 9470:#include <algorithm>
        -: 9471:#include <ostream>
        -: 9472:#include <cstring>
        -: 9473:#include <cctype>
        -: 9474:
        -: 9475:namespace Catch {
        -: 9476:
        1: 9477:    bool startsWith( std::string const& s, std::string const& prefix ) {
       1*: 9478:        return s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());
        -: 9479:    }
       16: 9480:    bool startsWith( std::string const& s, char prefix ) {
      16*: 9481:        return !s.empty() && s[0] == prefix;
        -: 9482:    }
    #####: 9483:    bool endsWith( std::string const& s, std::string const& suffix ) {
    #####: 9484:        return s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());
        -: 9485:    }
    #####: 9486:    bool endsWith( std::string const& s, char suffix ) {
    #####: 9487:        return !s.empty() && s[s.size()-1] == suffix;
        -: 9488:    }
    #####: 9489:    bool contains( std::string const& s, std::string const& infix ) {
    #####: 9490:        return s.find( infix ) != std::string::npos;
        -: 9491:    }
       29: 9492:    char toLowerCh(char c) {
       29: 9493:        return static_cast<char>( std::tolower( c ) );
        -: 9494:    }
        5: 9495:    void toLowerInPlace( std::string& s ) {
        5: 9496:        std::transform( s.begin(), s.end(), s.begin(), toLowerCh );
        5: 9497:    }
        5: 9498:    std::string toLower( std::string const& s ) {
        5: 9499:        std::string lc = s;
        5: 9500:        toLowerInPlace( lc );
        5: 9501:        return lc;
    =====: 9502:    }
    #####: 9503:    std::string trim( std::string const& str ) {
        -: 9504:        static char const* whitespaceChars = "\n\r\t ";
    #####: 9505:        std::string::size_type start = str.find_first_not_of( whitespaceChars );
    #####: 9506:        std::string::size_type end = str.find_last_not_of( whitespaceChars );
        -: 9507:
    #####: 9508:        return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();
        -: 9509:    }
        -: 9510:
    #####: 9511:    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {
    #####: 9512:        bool replaced = false;
    #####: 9513:        std::size_t i = str.find( replaceThis );
    #####: 9514:        while( i != std::string::npos ) {
    #####: 9515:            replaced = true;
    #####: 9516:            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );
    #####: 9517:            if( i < str.size()-withThis.size() )
    #####: 9518:                i = str.find( replaceThis, i+withThis.size() );
        -: 9519:            else
    #####: 9520:                i = std::string::npos;
        -: 9521:        }
    #####: 9522:        return replaced;
        -: 9523:    }
        -: 9524:
        2: 9525:    pluralise::pluralise( std::size_t count, std::string const& label )
        2: 9526:    :   m_count( count ),
        2: 9527:        m_label( label )
        2: 9528:    {}
        -: 9529:
        2: 9530:    std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser ) {
        2: 9531:        os << pluraliser.m_count << ' ' << pluraliser.m_label;
        2: 9532:        if( pluraliser.m_count != 1 )
        2: 9533:            os << 's';
        2: 9534:        return os;
        -: 9535:    }
        -: 9536:
        -: 9537:}
        -: 9538:// end catch_string_manip.cpp
        -: 9539:// start catch_stringref.cpp
        -: 9540:
        -: 9541:#if defined(__clang__)
        -: 9542:#    pragma clang diagnostic push
        -: 9543:#    pragma clang diagnostic ignored "-Wexit-time-destructors"
        -: 9544:#endif
        -: 9545:
        -: 9546:#include <ostream>
        -: 9547:#include <cstring>
        -: 9548:#include <cstdint>
        -: 9549:
        -: 9550:namespace {
        -: 9551:    const uint32_t byte_2_lead = 0xC0;
        -: 9552:    const uint32_t byte_3_lead = 0xE0;
        -: 9553:    const uint32_t byte_4_lead = 0xF0;
        -: 9554:}
        -: 9555:
        -: 9556:namespace Catch {
      135: 9557:    StringRef::StringRef( char const* rawChars ) noexcept
      135: 9558:    : StringRef( rawChars, static_cast<StringRef::size_type>(std::strlen(rawChars) ) )
      135: 9559:    {}
        -: 9560:
       12: 9561:    StringRef::operator std::string() const {
       12: 9562:        return std::string( m_start, m_size );
        -: 9563:    }
        -: 9564:
    #####: 9565:    void StringRef::swap( StringRef& other ) noexcept {
    #####: 9566:        std::swap( m_start, other.m_start );
    #####: 9567:        std::swap( m_size, other.m_size );
    #####: 9568:        std::swap( m_data, other.m_data );
    #####: 9569:    }
        -: 9570:
    #####: 9571:    auto StringRef::c_str() const -> char const* {
    #####: 9572:        if( isSubstring() )
    #####: 9573:           const_cast<StringRef*>( this )->takeOwnership();
    #####: 9574:        return m_start;
        -: 9575:    }
    #####: 9576:    auto StringRef::currentData() const noexcept -> char const* {
    #####: 9577:        return m_start;
        -: 9578:    }
        -: 9579:
    #####: 9580:    auto StringRef::isOwned() const noexcept -> bool {
    #####: 9581:        return m_data != nullptr;
        -: 9582:    }
    #####: 9583:    auto StringRef::isSubstring() const noexcept -> bool {
    #####: 9584:        return m_start[m_size] != '\0';
        -: 9585:    }
        -: 9586:
    #####: 9587:    void StringRef::takeOwnership() {
    #####: 9588:        if( !isOwned() ) {
    #####: 9589:            m_data = new char[m_size+1];
    #####: 9590:            memcpy( m_data, m_start, m_size );
    #####: 9591:            m_data[m_size] = '\0';
    #####: 9592:            m_start = m_data;
        -: 9593:        }
    #####: 9594:    }
    #####: 9595:    auto StringRef::substr( size_type start, size_type size ) const noexcept -> StringRef {
    #####: 9596:        if( start < m_size )
    #####: 9597:            return StringRef( m_start+start, size );
        -: 9598:        else
    #####: 9599:            return StringRef();
        -: 9600:    }
    #####: 9601:    auto StringRef::operator == ( StringRef const& other ) const noexcept -> bool {
        -: 9602:        return
    #####: 9603:            size() == other.size() &&
    #####: 9604:            (std::strncmp( m_start, other.m_start, size() ) == 0);
        -: 9605:    }
    #####: 9606:    auto StringRef::operator != ( StringRef const& other ) const noexcept -> bool {
    #####: 9607:        return !operator==( other );
        -: 9608:    }
        -: 9609:
    #####: 9610:    auto StringRef::operator[](size_type index) const noexcept -> char {
    #####: 9611:        return m_start[index];
        -: 9612:    }
        -: 9613:
    #####: 9614:    auto StringRef::numberOfCharacters() const noexcept -> size_type {
    #####: 9615:        size_type noChars = m_size;
        -: 9616:        // Make adjustments for uft encodings
    #####: 9617:        for( size_type i=0; i < m_size; ++i ) {
    #####: 9618:            char c = m_start[i];
    #####: 9619:            if( ( c & byte_2_lead ) == byte_2_lead ) {
    #####: 9620:                noChars--;
    #####: 9621:                if (( c & byte_3_lead ) == byte_3_lead )
    #####: 9622:                    noChars--;
    #####: 9623:                if( ( c & byte_4_lead ) == byte_4_lead )
    #####: 9624:                    noChars--;
        -: 9625:            }
        -: 9626:        }
    #####: 9627:        return noChars;
        -: 9628:    }
        -: 9629:
    #####: 9630:    auto operator + ( StringRef const& lhs, StringRef const& rhs ) -> std::string {
    #####: 9631:        std::string str;
    #####: 9632:        str.reserve( lhs.size() + rhs.size() );
    #####: 9633:        str += lhs;
    #####: 9634:        str += rhs;
    #####: 9635:        return str;
    =====: 9636:    }
    #####: 9637:    auto operator + ( StringRef const& lhs, const char* rhs ) -> std::string {
    #####: 9638:        return std::string( lhs ) + std::string( rhs );
        -: 9639:    }
    #####: 9640:    auto operator + ( char const* lhs, StringRef const& rhs ) -> std::string {
    #####: 9641:        return std::string( lhs ) + std::string( rhs );
        -: 9642:    }
        -: 9643:
    #####: 9644:    auto operator << ( std::ostream& os, StringRef const& str ) -> std::ostream& {
    #####: 9645:        return os.write(str.currentData(), str.size());
        -: 9646:    }
        -: 9647:
    #####: 9648:    auto operator+=( std::string& lhs, StringRef const& rhs ) -> std::string& {
    #####: 9649:        lhs.append(rhs.currentData(), rhs.size());
    #####: 9650:        return lhs;
        -: 9651:    }
        -: 9652:
        -: 9653:} // namespace Catch
        -: 9654:
        -: 9655:#if defined(__clang__)
        -: 9656:#    pragma clang diagnostic pop
        -: 9657:#endif
        -: 9658:// end catch_stringref.cpp
        -: 9659:// start catch_tag_alias.cpp
        -: 9660:
        -: 9661:namespace Catch {
    #####: 9662:    TagAlias::TagAlias(std::string const & _tag, SourceLineInfo _lineInfo): tag(_tag), lineInfo(_lineInfo) {}
        -: 9663:}
        -: 9664:// end catch_tag_alias.cpp
        -: 9665:// start catch_tag_alias_autoregistrar.cpp
        -: 9666:
        -: 9667:namespace Catch {
        -: 9668:
    #####: 9669:    RegistrarForTagAliases::RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const& lineInfo) {
        -: 9670:        try {
    #####: 9671:            getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);
    =====: 9672:        } catch (...) {
        -: 9673:            // Do not throw when constructing global objects, instead register the exception to be processed later
    =====: 9674:            getMutableRegistryHub().registerStartupException();
    =====: 9675:        }
    #####: 9676:    }
        -: 9677:
        -: 9678:}
        -: 9679:// end catch_tag_alias_autoregistrar.cpp
        -: 9680:// start catch_tag_alias_registry.cpp
        -: 9681:
        -: 9682:#include <sstream>
        -: 9683:
        -: 9684:namespace Catch {
        -: 9685:
       1*: 9686:    TagAliasRegistry::~TagAliasRegistry() {}
------------------
_ZN5Catch16TagAliasRegistryD0Ev:
    #####: 9686:    TagAliasRegistry::~TagAliasRegistry() {}
------------------
_ZN5Catch16TagAliasRegistryD2Ev:
        1: 9686:    TagAliasRegistry::~TagAliasRegistry() {}
------------------
        -: 9687:
    #####: 9688:    TagAlias const* TagAliasRegistry::find( std::string const& alias ) const {
    #####: 9689:        auto it = m_registry.find( alias );
    #####: 9690:        if( it != m_registry.end() )
    #####: 9691:            return &(it->second);
        -: 9692:        else
    #####: 9693:            return nullptr;
        -: 9694:    }
        -: 9695:
        1: 9696:    std::string TagAliasRegistry::expandAliases( std::string const& unexpandedTestSpec ) const {
        1: 9697:        std::string expandedTestSpec = unexpandedTestSpec;
       1*: 9698:        for( auto const& registryKvp : m_registry ) {
    #####: 9699:            std::size_t pos = expandedTestSpec.find( registryKvp.first );
    #####: 9700:            if( pos != std::string::npos ) {
    #####: 9701:                expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +
    #####: 9702:                                    registryKvp.second.tag +
    #####: 9703:                                    expandedTestSpec.substr( pos + registryKvp.first.size() );
        -: 9704:            }
        -: 9705:        }
        1: 9706:        return expandedTestSpec;
    =====: 9707:    }
        -: 9708:
    #####: 9709:    void TagAliasRegistry::add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) {
    #####: 9710:        CATCH_ENFORCE( startsWith(alias, "[@") && endsWith(alias, ']'),
        -: 9711:                      "error: tag alias, '" << alias << "' is not of the form [@alias name].\n" << lineInfo );
        -: 9712:
    #####: 9713:        CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,
        -: 9714:                      "error: tag alias, '" << alias << "' already registered.\n"
        -: 9715:                      << "\tFirst seen at: " << find(alias)->lineInfo << "\n"
        -: 9716:                      << "\tRedefined at: " << lineInfo );
    #####: 9717:    }
        -: 9718:
       1*: 9719:    ITagAliasRegistry::~ITagAliasRegistry() {}
------------------
_ZN5Catch17ITagAliasRegistryD0Ev:
    #####: 9719:    ITagAliasRegistry::~ITagAliasRegistry() {}
------------------
_ZN5Catch17ITagAliasRegistryD2Ev:
        1: 9719:    ITagAliasRegistry::~ITagAliasRegistry() {}
------------------
        -: 9720:
        1: 9721:    ITagAliasRegistry const& ITagAliasRegistry::get() {
        1: 9722:        return getRegistryHub().getTagAliasRegistry();
        -: 9723:    }
        -: 9724:
        -: 9725:} // end namespace Catch
        -: 9726:// end catch_tag_alias_registry.cpp
        -: 9727:// start catch_test_case_info.cpp
        -: 9728:
        -: 9729:#include <cctype>
        -: 9730:#include <exception>
        -: 9731:#include <algorithm>
        -: 9732:#include <sstream>
        -: 9733:
        -: 9734:namespace Catch {
        -: 9735:
       12: 9736:    TestCaseInfo::SpecialProperties parseSpecialTag( std::string const& tag ) {
      24*: 9737:        if( startsWith( tag, '.' ) ||
       12: 9738:            tag == "!hide" )
    #####: 9739:            return TestCaseInfo::IsHidden;
       12: 9740:        else if( tag == "!throws" )
    #####: 9741:            return TestCaseInfo::Throws;
       12: 9742:        else if( tag == "!shouldfail" )
    #####: 9743:            return TestCaseInfo::ShouldFail;
       12: 9744:        else if( tag == "!mayfail" )
    #####: 9745:            return TestCaseInfo::MayFail;
       12: 9746:        else if( tag == "!nonportable" )
    #####: 9747:            return TestCaseInfo::NonPortable;
       12: 9748:        else if( tag == "!benchmark" )
    #####: 9749:            return static_cast<TestCaseInfo::SpecialProperties>( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );
        -: 9750:        else
       12: 9751:            return TestCaseInfo::None;
        -: 9752:    }
        4: 9753:    bool isReservedTag( std::string const& tag ) {
       4*: 9754:        return parseSpecialTag( tag ) == TestCaseInfo::None && tag.size() > 0 && !std::isalnum( tag[0] );
        -: 9755:    }
        4: 9756:    void enforceNotReservedTag( std::string const& tag, SourceLineInfo const& _lineInfo ) {
       4*: 9757:        CATCH_ENFORCE( !isReservedTag(tag),
        -: 9758:                      "Tag name: [" << tag << "] is not allowed.\n"
        -: 9759:                      << "Tag names starting with non alpha-numeric characters are reserved\n"
        -: 9760:                      << _lineInfo );
        4: 9761:    }
        -: 9762:
        4: 9763:    TestCase makeTestCase(  ITestInvoker* _testCase,
        -: 9764:                            std::string const& _className,
        -: 9765:                            NameAndTags const& nameAndTags,
        -: 9766:                            SourceLineInfo const& _lineInfo )
        -: 9767:    {
        4: 9768:        bool isHidden = false;
        -: 9769:
        -: 9770:        // Parse out tags
        4: 9771:        std::vector<std::string> tags;
        4: 9772:        std::string desc, tag;
        4: 9773:        bool inTag = false;
        4: 9774:        std::string _descOrTags = nameAndTags.tags;
       40: 9775:        for (char c : _descOrTags) {
       36: 9776:            if( !inTag ) {
        4: 9777:                if( c == '[' )
        4: 9778:                    inTag = true;
        -: 9779:                else
    #####: 9780:                    desc += c;
        -: 9781:            }
        -: 9782:            else {
       32: 9783:                if( c == ']' ) {
        4: 9784:                    TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );
        4: 9785:                    if( ( prop & TestCaseInfo::IsHidden ) != 0 )
    #####: 9786:                        isHidden = true;
        4: 9787:                    else if( prop == TestCaseInfo::None )
        4: 9788:                        enforceNotReservedTag( tag, _lineInfo );
        -: 9789:
        4: 9790:                    tags.push_back( tag );
        4: 9791:                    tag.clear();
        4: 9792:                    inTag = false;
        -: 9793:                }
        -: 9794:                else
       28: 9795:                    tag += c;
        -: 9796:            }
        -: 9797:        }
        4: 9798:        if( isHidden ) {
    #####: 9799:            tags.push_back( "." );
        -: 9800:        }
        -: 9801:
        4: 9802:        TestCaseInfo info( nameAndTags.name, _className, desc, tags, _lineInfo );
        8: 9803:        return TestCase( _testCase, std::move(info) );
        4: 9804:    }
        -: 9805:
        4: 9806:    void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags ) {
        4: 9807:        std::sort(begin(tags), end(tags));
        4: 9808:        tags.erase(std::unique(begin(tags), end(tags)), end(tags));
        4: 9809:        testCaseInfo.lcaseTags.clear();
        -: 9810:
        8: 9811:        for( auto const& tag : tags ) {
        4: 9812:            std::string lcaseTag = toLower( tag );
        4: 9813:            testCaseInfo.properties = static_cast<TestCaseInfo::SpecialProperties>( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );
        4: 9814:            testCaseInfo.lcaseTags.push_back( lcaseTag );
        4: 9815:        }
        4: 9816:        testCaseInfo.tags = std::move(tags);
        4: 9817:    }
        -: 9818:
        4: 9819:    TestCaseInfo::TestCaseInfo( std::string const& _name,
        -: 9820:                                std::string const& _className,
        -: 9821:                                std::string const& _description,
        -: 9822:                                std::vector<std::string> const& _tags,
        4: 9823:                                SourceLineInfo const& _lineInfo )
        4: 9824:    :   name( _name ),
        4: 9825:        className( _className ),
        4: 9826:        description( _description ),
        4: 9827:        lineInfo( _lineInfo ),
        4: 9828:        properties( None )
        -: 9829:    {
        4: 9830:        setTags( *this, _tags );
        4: 9831:    }
        -: 9832:
    #####: 9833:    bool TestCaseInfo::isHidden() const {
    #####: 9834:        return ( properties & IsHidden ) != 0;
        -: 9835:    }
    #####: 9836:    bool TestCaseInfo::throws() const {
    #####: 9837:        return ( properties & Throws ) != 0;
        -: 9838:    }
    #####: 9839:    bool TestCaseInfo::okToFail() const {
    #####: 9840:        return ( properties & (ShouldFail | MayFail ) ) != 0;
        -: 9841:    }
        4: 9842:    bool TestCaseInfo::expectedToFail() const {
        4: 9843:        return ( properties & (ShouldFail ) ) != 0;
        -: 9844:    }
        -: 9845:
    #####: 9846:    std::string TestCaseInfo::tagsAsString() const {
    #####: 9847:        std::string ret;
        -: 9848:        // '[' and ']' per tag
    #####: 9849:        std::size_t full_size = 2 * tags.size();
    #####: 9850:        for (const auto& tag : tags) {
    #####: 9851:            full_size += tag.size();
        -: 9852:        }
    #####: 9853:        ret.reserve(full_size);
    #####: 9854:        for (const auto& tag : tags) {
    #####: 9855:            ret.push_back('[');
    #####: 9856:            ret.append(tag);
    #####: 9857:            ret.push_back(']');
        -: 9858:        }
        -: 9859:
    #####: 9860:        return ret;
    =====: 9861:    }
        -: 9862:
        4: 9863:    TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo&& info ) : TestCaseInfo( std::move(info) ), test( testCase ) {}
        -: 9864:
    #####: 9865:    TestCase TestCase::withName( std::string const& _newName ) const {
    #####: 9866:        TestCase other( *this );
    #####: 9867:        other.name = _newName;
    #####: 9868:        return other;
    =====: 9869:    }
        -: 9870:
       10: 9871:    void TestCase::invoke() const {
       10: 9872:        test->invoke();
       10: 9873:    }
        -: 9874:
    #####: 9875:    bool TestCase::operator == ( TestCase const& other ) const {
    #####: 9876:        return  test.get() == other.test.get() &&
    #####: 9877:                name == other.name &&
    #####: 9878:                className == other.className;
        -: 9879:    }
        -: 9880:
        8: 9881:    bool TestCase::operator < ( TestCase const& other ) const {
        8: 9882:        return name < other.name;
        -: 9883:    }
        -: 9884:
       18: 9885:    TestCaseInfo const& TestCase::getTestCaseInfo() const
        -: 9886:    {
       18: 9887:        return *this;
        -: 9888:    }
        -: 9889:
        -: 9890:} // end namespace Catch
        -: 9891:// end catch_test_case_info.cpp
        -: 9892:// start catch_test_case_registry_impl.cpp
        -: 9893:
        -: 9894:#include <sstream>
        -: 9895:
        -: 9896:namespace Catch {
        -: 9897:
        1: 9898:    std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases ) {
        -: 9899:
        1: 9900:        std::vector<TestCase> sorted = unsortedTestCases;
        -: 9901:
        1: 9902:        switch( config.runOrder() ) {
    #####: 9903:            case RunTests::InLexicographicalOrder:
    #####: 9904:                std::sort( sorted.begin(), sorted.end() );
    #####: 9905:                break;
    #####: 9906:            case RunTests::InRandomOrder:
    #####: 9907:                seedRng( config );
    #####: 9908:                RandomNumberGenerator::shuffle( sorted );
    #####: 9909:                break;
        1: 9910:            case RunTests::InDeclarationOrder:
        -: 9911:                // already in declaration order
        1: 9912:                break;
        -: 9913:        }
        1: 9914:        return sorted;
    =====: 9915:    }
        4: 9916:    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config ) {
       4*: 9917:        return testSpec.matches( testCase ) && ( config.allowThrows() || !testCase.throws() );
        -: 9918:    }
        -: 9919:
        1: 9920:    void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions ) {
        1: 9921:        std::set<TestCase> seenFunctions;
        5: 9922:        for( auto const& function : functions ) {
        4: 9923:            auto prev = seenFunctions.insert( function );
       4*: 9924:            CATCH_ENFORCE( prev.second,
        -: 9925:                    "error: TEST_CASE( \"" << function.name << "\" ) already defined.\n"
        -: 9926:                    << "\tFirst seen at " << prev.first->getTestCaseInfo().lineInfo << "\n"
        -: 9927:                    << "\tRedefined at " << function.getTestCaseInfo().lineInfo );
        -: 9928:        }
        1: 9929:    }
        -: 9930:
    #####: 9931:    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config ) {
    #####: 9932:        std::vector<TestCase> filtered;
    #####: 9933:        filtered.reserve( testCases.size() );
    #####: 9934:        for( auto const& testCase : testCases )
    #####: 9935:            if( matchTest( testCase, testSpec, config ) )
    #####: 9936:                filtered.push_back( testCase );
    #####: 9937:        return filtered;
    =====: 9938:    }
        1: 9939:    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config ) {
        1: 9940:        return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );
        -: 9941:    }
        -: 9942:
        4: 9943:    void TestRegistry::registerTest( TestCase const& testCase ) {
        4: 9944:        std::string name = testCase.getTestCaseInfo().name;
        4: 9945:        if( name.empty() ) {
    #####: 9946:            ReusableStringStream rss;
    #####: 9947:            rss << "Anonymous test case " << ++m_unnamedCount;
    #####: 9948:            return registerTest( testCase.withName( rss.str() ) );
    #####: 9949:        }
        4: 9950:        m_functions.push_back( testCase );
        4: 9951:    }
        -: 9952:
    #####: 9953:    std::vector<TestCase> const& TestRegistry::getAllTests() const {
    #####: 9954:        return m_functions;
        -: 9955:    }
        1: 9956:    std::vector<TestCase> const& TestRegistry::getAllTestsSorted( IConfig const& config ) const {
        1: 9957:        if( m_sortedFunctions.empty() )
        1: 9958:            enforceNoDuplicateTestCases( m_functions );
        -: 9959:
       1*: 9960:        if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {
        1: 9961:            m_sortedFunctions = sortTests( config, m_functions );
        1: 9962:            m_currentSortOrder = config.runOrder();
        -: 9963:        }
        1: 9964:        return m_sortedFunctions;
        -: 9965:    }
        -: 9966:
        -: 9967:    ///////////////////////////////////////////////////////////////////////////
        4: 9968:    TestInvokerAsFunction::TestInvokerAsFunction( void(*testAsFunction)() ) noexcept : m_testAsFunction( testAsFunction ) {}
        -: 9969:
       10: 9970:    void TestInvokerAsFunction::invoke() const {
       10: 9971:        m_testAsFunction();
       10: 9972:    }
        -: 9973:
        4: 9974:    std::string extractClassName( StringRef const& classOrQualifiedMethodName ) {
        4: 9975:        std::string className = classOrQualifiedMethodName;
        4: 9976:        if( startsWith( className, '&' ) )
        -: 9977:        {
    #####: 9978:            std::size_t lastColons = className.rfind( "::" );
    #####: 9979:            std::size_t penultimateColons = className.rfind( "::", lastColons-1 );
    #####: 9980:            if( penultimateColons == std::string::npos )
    #####: 9981:                penultimateColons = 1;
    #####: 9982:            className = className.substr( penultimateColons, lastColons-penultimateColons );
        -: 9983:        }
        4: 9984:        return className;
    =====: 9985:    }
        -: 9986:
        -: 9987:} // end namespace Catch
        -: 9988:// end catch_test_case_registry_impl.cpp
        -: 9989:// start catch_test_case_tracker.cpp
        -: 9990:
        -: 9991:#include <algorithm>
        -: 9992:#include <assert.h>
        -: 9993:#include <stdexcept>
        -: 9994:#include <memory>
        -: 9995:#include <sstream>
        -: 9996:
        -: 9997:#if defined(__clang__)
        -: 9998:#    pragma clang diagnostic push
        -: 9999:#    pragma clang diagnostic ignored "-Wexit-time-destructors"
        -:10000:#endif
        -:10001:
        -:10002:namespace Catch {
        -:10003:namespace TestCaseTracking {
        -:10004:
       47:10005:    NameAndLocation::NameAndLocation( std::string const& _name, SourceLineInfo const& _location )
       47:10006:    :   name( _name ),
       47:10007:        location( _location )
       47:10008:    {}
        -:10009:
      17*:10010:    ITracker::~ITracker() = default;
------------------
_ZN5Catch16TestCaseTracking8ITrackerD0Ev:
    #####:10010:    ITracker::~ITracker() = default;
------------------
_ZN5Catch16TestCaseTracking8ITrackerD2Ev:
       17:10010:    ITracker::~ITracker() = default;
------------------
        -:10011:
    #####:10012:    TrackerContext& TrackerContext::instance() {
    #####:10013:        static TrackerContext s_instance;
    #####:10014:        return s_instance;
        -:10015:    }
        -:10016:
        4:10017:    ITracker& TrackerContext::startRun() {
        4:10018:        m_rootTracker = std::make_shared<SectionTracker>( NameAndLocation( "{root}", CATCH_INTERNAL_LINEINFO ), *this, nullptr );
        4:10019:        m_currentTracker = nullptr;
        4:10020:        m_runState = Executing;
        4:10021:        return *m_rootTracker;
        -:10022:    }
        -:10023:
    #####:10024:    void TrackerContext::endRun() {
    #####:10025:        m_rootTracker.reset();
    #####:10026:        m_currentTracker = nullptr;
    #####:10027:        m_runState = NotStarted;
    #####:10028:    }
        -:10029:
       10:10030:    void TrackerContext::startCycle() {
       10:10031:        m_currentTracker = m_rootTracker.get();
       10:10032:        m_runState = Executing;
       10:10033:    }
       19:10034:    void TrackerContext::completeCycle() {
       19:10035:        m_runState = CompletedCycle;
       19:10036:    }
        -:10037:
       43:10038:    bool TrackerContext::completedCycle() const {
       43:10039:        return m_runState == CompletedCycle;
        -:10040:    }
       62:10041:    ITracker& TrackerContext::currentTracker() {
       62:10042:        return *m_currentTracker;
        -:10043:    }
       38:10044:    void TrackerContext::setCurrentTracker( ITracker* tracker ) {
       38:10045:        m_currentTracker = tracker;
       38:10046:    }
        -:10047:
       43:10048:    TrackerBase::TrackerHasName::TrackerHasName( NameAndLocation const& nameAndLocation ) : m_nameAndLocation( nameAndLocation ) {}
       84:10049:    bool TrackerBase::TrackerHasName::operator ()( ITrackerPtr const& tracker ) const {
        -:10050:        return
      114:10051:            tracker->nameAndLocation().name == m_nameAndLocation.name &&
      114:10052:            tracker->nameAndLocation().location == m_nameAndLocation.location;
        -:10053:    }
        -:10054:
       17:10055:    TrackerBase::TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
       17:10056:    :   m_nameAndLocation( nameAndLocation ),
       17:10057:        m_ctx( ctx ),
       17:10058:        m_parent( parent )
       17:10059:    {}
        -:10060:
      114:10061:    NameAndLocation const& TrackerBase::nameAndLocation() const {
      114:10062:        return m_nameAndLocation;
        -:10063:    }
       61:10064:    bool TrackerBase::isComplete() const {
       61:10065:        return m_runState == CompletedSuccessfully || m_runState == Failed;
        -:10066:    }
       10:10067:    bool TrackerBase::isSuccessfullyCompleted() const {
       10:10068:        return m_runState == CompletedSuccessfully;
        -:10069:    }
       33:10070:    bool TrackerBase::isOpen() const {
       33:10071:        return m_runState != NotStarted && !isComplete();
        -:10072:    }
    #####:10073:    bool TrackerBase::hasChildren() const {
    #####:10074:        return !m_children.empty();
        -:10075:    }
        -:10076:
       13:10077:    void TrackerBase::addChild( ITrackerPtr const& child ) {
       13:10078:        m_children.push_back( child );
       13:10079:    }
        -:10080:
       43:10081:    ITrackerPtr TrackerBase::findChild( NameAndLocation const& nameAndLocation ) {
       43:10082:        auto it = std::find_if( m_children.begin(), m_children.end(), TrackerHasName( nameAndLocation ) );
       86:10083:        return( it != m_children.end() )
       30:10084:            ? *it
      116:10085:            : nullptr;
        -:10086:    }
    #####:10087:    ITracker& TrackerBase::parent() {
    #####:10088:        assert( m_parent ); // Should always be non-null except for root
    #####:10089:        return *m_parent;
        -:10090:    }
        -:10091:
       28:10092:    void TrackerBase::openChild() {
       28:10093:        if( m_runState != ExecutingChildren ) {
       13:10094:            m_runState = ExecutingChildren;
       13:10095:            if( m_parent )
        9:10096:                m_parent->openChild();
        -:10097:        }
       28:10098:    }
        -:10099:
    #####:10100:    bool TrackerBase::isSectionTracker() const { return false; }
    #####:10101:    bool TrackerBase::isIndexTracker() const { return false; }
        -:10102:
       19:10103:    void TrackerBase::open() {
       19:10104:        m_runState = Executing;
       19:10105:        moveToThis();
       19:10106:        if( m_parent )
       19:10107:            m_parent->openChild();
       19:10108:    }
        -:10109:
       19:10110:    void TrackerBase::close() {
        -:10111:
        -:10112:        // Close any still open children (e.g. generators)
       19:10113:        while( &m_ctx.currentTracker() != this )
    #####:10114:            m_ctx.currentTracker().close();
        -:10115:
       19:10116:        switch( m_runState ) {
    #####:10117:            case NeedsAnotherRun:
    #####:10118:                break;
        -:10119:
       10:10120:            case Executing:
       10:10121:                m_runState = CompletedSuccessfully;
       10:10122:                break;
        9:10123:            case ExecutingChildren:
        9:10124:                if( m_children.empty() || m_children.back()->isComplete() )
        3:10125:                    m_runState = CompletedSuccessfully;
        9:10126:                break;
        -:10127:
    #####:10128:            case NotStarted:
        -:10129:            case CompletedSuccessfully:
        -:10130:            case Failed:
    #####:10131:                CATCH_INTERNAL_ERROR( "Illogical state: " << m_runState );
        -:10132:
    #####:10133:            default:
    #####:10134:                CATCH_INTERNAL_ERROR( "Unknown state: " << m_runState );
        -:10135:        }
       19:10136:        moveToParent();
       19:10137:        m_ctx.completeCycle();
       19:10138:    }
    #####:10139:    void TrackerBase::fail() {
    #####:10140:        m_runState = Failed;
    #####:10141:        if( m_parent )
    #####:10142:            m_parent->markAsNeedingAnotherRun();
    #####:10143:        moveToParent();
    #####:10144:        m_ctx.completeCycle();
    #####:10145:    }
    #####:10146:    void TrackerBase::markAsNeedingAnotherRun() {
    #####:10147:        m_runState = NeedsAnotherRun;
    #####:10148:    }
        -:10149:
       19:10150:    void TrackerBase::moveToParent() {
      19*:10151:        assert( m_parent );
       19:10152:        m_ctx.setCurrentTracker( m_parent );
       19:10153:    }
       19:10154:    void TrackerBase::moveToThis() {
       19:10155:        m_ctx.setCurrentTracker( this );
       19:10156:    }
        -:10157:
       17:10158:    SectionTracker::SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
       17:10159:    :   TrackerBase( nameAndLocation, ctx, parent )
        -:10160:    {
       17:10161:        if( parent ) {
       13:10162:            while( !parent->isSectionTracker() )
    #####:10163:                parent = &parent->parent();
        -:10164:
       13:10165:            SectionTracker& parentSection = static_cast<SectionTracker&>( *parent );
       13:10166:            addNextFilters( parentSection.m_filters );
        -:10167:        }
       17:10168:    }
        -:10169:
       47:10170:    bool SectionTracker::isSectionTracker() const { return true; }
        -:10171:
       43:10172:    SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {
       43:10173:        std::shared_ptr<SectionTracker> section;
        -:10174:
       43:10175:        ITracker& currentTracker = ctx.currentTracker();
       43:10176:        if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
      30*:10177:            assert( childTracker );
      30*:10178:            assert( childTracker->isSectionTracker() );
       30:10179:            section = std::static_pointer_cast<SectionTracker>( childTracker );
        -:10180:        }
        -:10181:        else {
       13:10182:            section = std::make_shared<SectionTracker>( nameAndLocation, ctx, &currentTracker );
       13:10183:            currentTracker.addChild( section );
       43:10184:        }
       43:10185:        if( !ctx.completedCycle() )
       31:10186:            section->tryOpen();
       86:10187:        return *section;
       43:10188:    }
        -:10189:
       31:10190:    void SectionTracker::tryOpen() {
      31*:10191:        if( !isComplete() && (m_filters.empty() || m_filters[0].empty() ||  m_filters[0] == m_nameAndLocation.name ) )
       19:10192:            open();
       31:10193:    }
        -:10194:
        4:10195:    void SectionTracker::addInitialFilters( std::vector<std::string> const& filters ) {
        4:10196:        if( !filters.empty() ) {
    #####:10197:            m_filters.push_back(""); // Root - should never be consulted
    #####:10198:            m_filters.push_back(""); // Test Case - not a section filter
    #####:10199:            m_filters.insert( m_filters.end(), filters.begin(), filters.end() );
        -:10200:        }
        4:10201:    }
       13:10202:    void SectionTracker::addNextFilters( std::vector<std::string> const& filters ) {
       13:10203:        if( filters.size() > 1 )
    #####:10204:            m_filters.insert( m_filters.end(), ++filters.begin(), filters.end() );
       13:10205:    }
        -:10206:
    #####:10207:    IndexTracker::IndexTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent, int size )
        -:10208:    :   TrackerBase( nameAndLocation, ctx, parent ),
    #####:10209:        m_size( size )
    #####:10210:    {}
        -:10211:
    #####:10212:    bool IndexTracker::isIndexTracker() const { return true; }
        -:10213:
    #####:10214:    IndexTracker& IndexTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation, int size ) {
    #####:10215:        std::shared_ptr<IndexTracker> tracker;
        -:10216:
    #####:10217:        ITracker& currentTracker = ctx.currentTracker();
    #####:10218:        if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
    #####:10219:            assert( childTracker );
    #####:10220:            assert( childTracker->isIndexTracker() );
    #####:10221:            tracker = std::static_pointer_cast<IndexTracker>( childTracker );
        -:10222:        }
        -:10223:        else {
    #####:10224:            tracker = std::make_shared<IndexTracker>( nameAndLocation, ctx, &currentTracker, size );
    #####:10225:            currentTracker.addChild( tracker );
    #####:10226:        }
        -:10227:
    #####:10228:        if( !ctx.completedCycle() && !tracker->isComplete() ) {
    #####:10229:            if( tracker->m_runState != ExecutingChildren && tracker->m_runState != NeedsAnotherRun )
    #####:10230:                tracker->moveNext();
    #####:10231:            tracker->open();
        -:10232:        }
        -:10233:
    #####:10234:        return *tracker;
    #####:10235:    }
        -:10236:
    #####:10237:    int IndexTracker::index() const { return m_index; }
        -:10238:
    #####:10239:    void IndexTracker::moveNext() {
    #####:10240:        m_index++;
    #####:10241:        m_children.clear();
    #####:10242:    }
        -:10243:
    #####:10244:    void IndexTracker::close() {
    #####:10245:        TrackerBase::close();
    #####:10246:        if( m_runState == CompletedSuccessfully && m_index < m_size-1 )
    #####:10247:            m_runState = Executing;
    #####:10248:    }
        -:10249:
        -:10250:} // namespace TestCaseTracking
        -:10251:
        -:10252:using TestCaseTracking::ITracker;
        -:10253:using TestCaseTracking::TrackerContext;
        -:10254:using TestCaseTracking::SectionTracker;
        -:10255:using TestCaseTracking::IndexTracker;
        -:10256:
        -:10257:} // namespace Catch
        -:10258:
        -:10259:#if defined(__clang__)
        -:10260:#    pragma clang diagnostic pop
        -:10261:#endif
        -:10262:// end catch_test_case_tracker.cpp
        -:10263:// start catch_test_registry.cpp
        -:10264:
        -:10265:namespace Catch {
        -:10266:
        4:10267:    auto makeTestInvoker( void(*testAsFunction)() ) noexcept -> ITestInvoker* {
       4*:10268:        return new(std::nothrow) TestInvokerAsFunction( testAsFunction );
        -:10269:    }
        -:10270:
        4:10271:    NameAndTags::NameAndTags( StringRef const& name_ , StringRef const& tags_ ) noexcept : name( name_ ), tags( tags_ ) {}
        -:10272:
        4:10273:    AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept {
        -:10274:        try {
        4:10275:            getMutableRegistryHub()
        4:10276:                    .registerTest(
        8:10277:                        makeTestCase(
        -:10278:                            invoker,
        8:10279:                            extractClassName( classOrMethod ),
        -:10280:                            nameAndTags,
        -:10281:                            lineInfo));
    =====:10282:        } catch (...) {
        -:10283:            // Do not throw when constructing global objects, instead register the exception to be processed later
    =====:10284:            getMutableRegistryHub().registerStartupException();
    =====:10285:        }
        4:10286:    }
        -:10287:
       4*:10288:    AutoReg::~AutoReg() = default;
------------------
_ZN5Catch7AutoRegD0Ev:
    #####:10288:    AutoReg::~AutoReg() = default;
------------------
_ZN5Catch7AutoRegD2Ev:
        4:10288:    AutoReg::~AutoReg() = default;
------------------
        -:10289:}
        -:10290:// end catch_test_registry.cpp
        -:10291:// start catch_test_spec.cpp
        -:10292:
        -:10293:#include <algorithm>
        -:10294:#include <string>
        -:10295:#include <vector>
        -:10296:#include <memory>
        -:10297:
        -:10298:namespace Catch {
        -:10299:
       2*:10300:    TestSpec::Pattern::~Pattern() = default;
------------------
_ZN5Catch8TestSpec7PatternD0Ev:
    #####:10300:    TestSpec::Pattern::~Pattern() = default;
------------------
_ZN5Catch8TestSpec7PatternD2Ev:
        2:10300:    TestSpec::Pattern::~Pattern() = default;
------------------
    #####:10301:    TestSpec::NamePattern::~NamePattern() = default;
------------------
_ZN5Catch8TestSpec11NamePatternD0Ev:
    #####:10301:    TestSpec::NamePattern::~NamePattern() = default;
------------------
_ZN5Catch8TestSpec11NamePatternD2Ev:
    #####:10301:    TestSpec::NamePattern::~NamePattern() = default;
------------------
       1*:10302:    TestSpec::TagPattern::~TagPattern() = default;
------------------
_ZN5Catch8TestSpec10TagPatternD0Ev:
    #####:10302:    TestSpec::TagPattern::~TagPattern() = default;
------------------
_ZN5Catch8TestSpec10TagPatternD2Ev:
        1:10302:    TestSpec::TagPattern::~TagPattern() = default;
------------------
       1*:10303:    TestSpec::ExcludedPattern::~ExcludedPattern() = default;
------------------
_ZN5Catch8TestSpec15ExcludedPatternD0Ev:
    #####:10303:    TestSpec::ExcludedPattern::~ExcludedPattern() = default;
------------------
_ZN5Catch8TestSpec15ExcludedPatternD2Ev:
        1:10303:    TestSpec::ExcludedPattern::~ExcludedPattern() = default;
------------------
        -:10304:
    #####:10305:    TestSpec::NamePattern::NamePattern( std::string const& name )
    #####:10306:    : m_wildcardPattern( toLower( name ), CaseSensitive::No )
    #####:10307:    {}
    #####:10308:    bool TestSpec::NamePattern::matches( TestCaseInfo const& testCase ) const {
    #####:10309:        return m_wildcardPattern.matches( toLower( testCase.name ) );
        -:10310:    }
        -:10311:
        1:10312:    TestSpec::TagPattern::TagPattern( std::string const& tag ) : m_tag( toLower( tag ) ) {}
        4:10313:    bool TestSpec::TagPattern::matches( TestCaseInfo const& testCase ) const {
        4:10314:        return std::find(begin(testCase.lcaseTags),
        4:10315:                         end(testCase.lcaseTags),
        8:10316:                         m_tag) != end(testCase.lcaseTags);
        -:10317:    }
        -:10318:
        1:10319:    TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const& underlyingPattern ) : m_underlyingPattern( underlyingPattern ) {}
        4:10320:    bool TestSpec::ExcludedPattern::matches( TestCaseInfo const& testCase ) const { return !m_underlyingPattern->matches( testCase ); }
        -:10321:
        4:10322:    bool TestSpec::Filter::matches( TestCaseInfo const& testCase ) const {
        -:10323:        // All patterns in a filter must match for the filter to be a match
        8:10324:        for( auto const& pattern : m_patterns ) {
        4:10325:            if( !pattern->matches( testCase ) )
    #####:10326:                return false;
        -:10327:        }
        4:10328:        return true;
        -:10329:    }
        -:10330:
    #####:10331:    bool TestSpec::hasFilters() const {
    #####:10332:        return !m_filters.empty();
        -:10333:    }
        4:10334:    bool TestSpec::matches( TestCaseInfo const& testCase ) const {
        -:10335:        // A TestSpec matches if any filter matches
       4*:10336:        for( auto const& filter : m_filters )
        4:10337:            if( filter.matches( testCase ) )
        4:10338:                return true;
    #####:10339:        return false;
        -:10340:    }
        -:10341:}
        -:10342:// end catch_test_spec.cpp
        -:10343:// start catch_test_spec_parser.cpp
        -:10344:
        -:10345:namespace Catch {
        -:10346:
        1:10347:    TestSpecParser::TestSpecParser( ITagAliasRegistry const& tagAliases ) : m_tagAliases( &tagAliases ) {}
        -:10348:
        1:10349:    TestSpecParser& TestSpecParser::parse( std::string const& arg ) {
        1:10350:        m_mode = None;
        1:10351:        m_exclusion = false;
        1:10352:        m_start = std::string::npos;
        1:10353:        m_arg = m_tagAliases->expandAliases( arg );
        1:10354:        m_escapeChars.clear();
        4:10355:        for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )
        3:10356:            visitChar( m_arg[m_pos] );
        1:10357:        if( m_mode == Name )
    #####:10358:            addPattern<TestSpec::NamePattern>();
        1:10359:        return *this;
        -:10360:    }
        1:10361:    TestSpec TestSpecParser::testSpec() {
        1:10362:        addFilter();
        1:10363:        return m_testSpec;
        -:10364:    }
        -:10365:
        3:10366:    void TestSpecParser::visitChar( char c ) {
        3:10367:        if( m_mode == None ) {
        2:10368:            switch( c ) {
    #####:10369:            case ' ': return;
        1:10370:            case '~': m_exclusion = true; return;
        1:10371:            case '[': return startNewMode( Tag, ++m_pos );
    #####:10372:            case '"': return startNewMode( QuotedName, ++m_pos );
    #####:10373:            case '\\': return escape();
    #####:10374:            default: startNewMode( Name, m_pos ); break;
        -:10375:            }
        -:10376:        }
        1:10377:        if( m_mode == Name ) {
    #####:10378:            if( c == ',' ) {
    #####:10379:                addPattern<TestSpec::NamePattern>();
    #####:10380:                addFilter();
        -:10381:            }
    #####:10382:            else if( c == '[' ) {
    #####:10383:                if( subString() == "exclude:" )
    #####:10384:                    m_exclusion = true;
        -:10385:                else
    #####:10386:                    addPattern<TestSpec::NamePattern>();
    #####:10387:                startNewMode( Tag, ++m_pos );
        -:10388:            }
    #####:10389:            else if( c == '\\' )
    #####:10390:                escape();
        -:10391:        }
        1:10392:        else if( m_mode == EscapedName )
    #####:10393:            m_mode = Name;
       1*:10394:        else if( m_mode == QuotedName && c == '"' )
    #####:10395:            addPattern<TestSpec::NamePattern>();
        1:10396:        else if( m_mode == Tag && c == ']' )
        1:10397:            addPattern<TestSpec::TagPattern>();
        -:10398:    }
        1:10399:    void TestSpecParser::startNewMode( Mode mode, std::size_t start ) {
        1:10400:        m_mode = mode;
        1:10401:        m_start = start;
        1:10402:    }
    #####:10403:    void TestSpecParser::escape() {
    #####:10404:        if( m_mode == None )
    #####:10405:            m_start = m_pos;
    #####:10406:        m_mode = EscapedName;
    #####:10407:        m_escapeChars.push_back( m_pos );
    #####:10408:    }
        1:10409:    std::string TestSpecParser::subString() const { return m_arg.substr( m_start, m_pos - m_start ); }
        -:10410:
        1:10411:    void TestSpecParser::addFilter() {
        1:10412:        if( !m_currentFilter.m_patterns.empty() ) {
        1:10413:            m_testSpec.m_filters.push_back( m_currentFilter );
        1:10414:            m_currentFilter = TestSpec::Filter();
        -:10415:        }
        1:10416:    }
        -:10417:
    #####:10418:    TestSpec parseTestSpec( std::string const& arg ) {
    #####:10419:        return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();
        -:10420:    }
        -:10421:
        -:10422:} // namespace Catch
        -:10423:// end catch_test_spec_parser.cpp
        -:10424:// start catch_timer.cpp
        -:10425:
        -:10426:#include <chrono>
        -:10427:
        -:10428:namespace Catch {
        -:10429:
       62:10430:    auto getCurrentNanosecondsSinceEpoch() -> uint64_t {
       62:10431:        return std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::high_resolution_clock::now().time_since_epoch() ).count();
        -:10432:    }
        -:10433:
    #####:10434:    auto estimateClockResolution() -> uint64_t {
    #####:10435:        uint64_t sum = 0;
        -:10436:        static const uint64_t iterations = 1000000;
        -:10437:
    #####:10438:        for( std::size_t i = 0; i < iterations; ++i ) {
        -:10439:
        -:10440:            uint64_t ticks;
    #####:10441:            uint64_t baseTicks = getCurrentNanosecondsSinceEpoch();
        -:10442:            do {
    #####:10443:                ticks = getCurrentNanosecondsSinceEpoch();
        -:10444:            }
    #####:10445:            while( ticks == baseTicks );
        -:10446:
    #####:10447:            auto delta = ticks - baseTicks;
    #####:10448:            sum += delta;
        -:10449:        }
        -:10450:
        -:10451:        // We're just taking the mean, here. To do better we could take the std. dev and exclude outliers
        -:10452:        // - and potentially do more iterations if there's a high variance.
    #####:10453:        return sum/iterations;
        -:10454:    }
    #####:10455:    auto getEstimatedClockResolution() -> uint64_t {
    #####:10456:        static auto s_resolution = estimateClockResolution();
    #####:10457:        return s_resolution;
        -:10458:    }
        -:10459:
       43:10460:    void Timer::start() {
       43:10461:       m_nanoseconds = getCurrentNanosecondsSinceEpoch();
       43:10462:    }
       19:10463:    auto Timer::getElapsedNanoseconds() const -> uint64_t {
       19:10464:        return getCurrentNanosecondsSinceEpoch() - m_nanoseconds;
        -:10465:    }
       19:10466:    auto Timer::getElapsedMicroseconds() const -> uint64_t {
       19:10467:        return getElapsedNanoseconds()/1000;
        -:10468:    }
    #####:10469:    auto Timer::getElapsedMilliseconds() const -> unsigned int {
    #####:10470:        return static_cast<unsigned int>(getElapsedMicroseconds()/1000);
        -:10471:    }
       19:10472:    auto Timer::getElapsedSeconds() const -> double {
       19:10473:        return getElapsedMicroseconds()/1000000.0;
        -:10474:    }
        -:10475:
        -:10476:} // namespace Catch
        -:10477:// end catch_timer.cpp
        -:10478:// start catch_tostring.cpp
        -:10479:
        -:10480:#if defined(__clang__)
        -:10481:#    pragma clang diagnostic push
        -:10482:#    pragma clang diagnostic ignored "-Wexit-time-destructors"
        -:10483:#    pragma clang diagnostic ignored "-Wglobal-constructors"
        -:10484:#endif
        -:10485:
        -:10486:// Enable specific decls locally
        -:10487:#if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
        -:10488:#define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
        -:10489:#endif
        -:10490:
        -:10491:#include <cmath>
        -:10492:#include <iomanip>
        -:10493:
        -:10494:namespace Catch {
        -:10495:
        -:10496:namespace Detail {
        -:10497:
        -:10498:    const std::string unprintableString = "{?}";
        -:10499:
        -:10500:    namespace {
        -:10501:        const int hexThreshold = 255;
        -:10502:
        -:10503:        struct Endianness {
        -:10504:            enum Arch { Big, Little };
        -:10505:
    #####:10506:            static Arch which() {
        -:10507:                union _{
        -:10508:                    int asInt;
        -:10509:                    char asChar[sizeof (int)];
        -:10510:                } u;
        -:10511:
    #####:10512:                u.asInt = 1;
    #####:10513:                return ( u.asChar[sizeof(int)-1] == 1 ) ? Big : Little;
        -:10514:            }
        -:10515:        };
        -:10516:    }
        -:10517:
    #####:10518:    std::string rawMemoryToString( const void *object, std::size_t size ) {
        -:10519:        // Reverse order for little endian architectures
    #####:10520:        int i = 0, end = static_cast<int>( size ), inc = 1;
    #####:10521:        if( Endianness::which() == Endianness::Little ) {
    #####:10522:            i = end-1;
    #####:10523:            end = inc = -1;
        -:10524:        }
        -:10525:
    #####:10526:        unsigned char const *bytes = static_cast<unsigned char const *>(object);
    #####:10527:        ReusableStringStream rss;
    #####:10528:        rss << "0x" << std::setfill('0') << std::hex;
    #####:10529:        for( ; i != end; i += inc )
    #####:10530:             rss << std::setw(2) << static_cast<unsigned>(bytes[i]);
    #####:10531:       return rss.str();
    #####:10532:    }
        -:10533:}
        -:10534:
        -:10535:template<typename T>
    #####:10536:std::string fpToString( T value, int precision ) {
    #####:10537:    if (std::isnan(value)) {
    #####:10538:        return "nan";
        -:10539:    }
        -:10540:
    #####:10541:    ReusableStringStream rss;
    #####:10542:    rss << std::setprecision( precision )
    #####:10543:        << std::fixed
    #####:10544:        << value;
    #####:10545:    std::string d = rss.str();
    #####:10546:    std::size_t i = d.find_last_not_of( '0' );
    #####:10547:    if( i != std::string::npos && i != d.size()-1 ) {
    #####:10548:        if( d[i] == '.' )
    #####:10549:            i++;
    #####:10550:        d = d.substr( 0, i+1 );
        -:10551:    }
    #####:10552:    return d;
    #####:10553:}
------------------
_ZN5Catch10fpToStringIdEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEET_i:
    #####:10536:std::string fpToString( T value, int precision ) {
    #####:10537:    if (std::isnan(value)) {
    #####:10538:        return "nan";
        -:10539:    }
        -:10540:
    #####:10541:    ReusableStringStream rss;
    #####:10542:    rss << std::setprecision( precision )
    #####:10543:        << std::fixed
    #####:10544:        << value;
    #####:10545:    std::string d = rss.str();
    #####:10546:    std::size_t i = d.find_last_not_of( '0' );
    #####:10547:    if( i != std::string::npos && i != d.size()-1 ) {
    #####:10548:        if( d[i] == '.' )
    #####:10549:            i++;
    #####:10550:        d = d.substr( 0, i+1 );
        -:10551:    }
    #####:10552:    return d;
    #####:10553:}
------------------
_ZN5Catch10fpToStringIfEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEET_i:
    #####:10536:std::string fpToString( T value, int precision ) {
    #####:10537:    if (std::isnan(value)) {
    #####:10538:        return "nan";
        -:10539:    }
        -:10540:
    #####:10541:    ReusableStringStream rss;
    #####:10542:    rss << std::setprecision( precision )
    #####:10543:        << std::fixed
    #####:10544:        << value;
    #####:10545:    std::string d = rss.str();
    #####:10546:    std::size_t i = d.find_last_not_of( '0' );
    #####:10547:    if( i != std::string::npos && i != d.size()-1 ) {
    #####:10548:        if( d[i] == '.' )
    #####:10549:            i++;
    #####:10550:        d = d.substr( 0, i+1 );
        -:10551:    }
    #####:10552:    return d;
    #####:10553:}
------------------
        -:10554:
        -:10555://// ======================================================= ////
        -:10556://
        -:10557://   Out-of-line defs for full specialization of StringMaker
        -:10558://
        -:10559://// ======================================================= ////
        -:10560:
    #####:10561:std::string StringMaker<std::string>::convert(const std::string& str) {
    #####:10562:    if (!getCurrentContext().getConfig()->showInvisibles()) {
    #####:10563:        return '"' + str + '"';
        -:10564:    }
        -:10565:
    #####:10566:    std::string s("\"");
    #####:10567:    for (char c : str) {
    #####:10568:        switch (c) {
    #####:10569:        case '\n':
    #####:10570:            s.append("\\n");
    #####:10571:            break;
    #####:10572:        case '\t':
    #####:10573:            s.append("\\t");
    #####:10574:            break;
    #####:10575:        default:
    #####:10576:            s.push_back(c);
    #####:10577:            break;
        -:10578:        }
        -:10579:    }
    #####:10580:    s.append("\"");
    #####:10581:    return s;
    #####:10582:}
        -:10583:
        -:10584:#ifdef CATCH_CONFIG_WCHAR
    #####:10585:std::string StringMaker<std::wstring>::convert(const std::wstring& wstr) {
    #####:10586:    std::string s;
    #####:10587:    s.reserve(wstr.size());
    #####:10588:    for (auto c : wstr) {
    #####:10589:        s += (c <= 0xff) ? static_cast<char>(c) : '?';
        -:10590:    }
    #####:10591:    return ::Catch::Detail::stringify(s);
    #####:10592:}
        -:10593:#endif
        -:10594:
    #####:10595:std::string StringMaker<char const*>::convert(char const* str) {
    #####:10596:    if (str) {
    #####:10597:        return ::Catch::Detail::stringify(std::string{ str });
        -:10598:    } else {
    #####:10599:        return{ "{null string}" };
        -:10600:    }
        -:10601:}
    #####:10602:std::string StringMaker<char*>::convert(char* str) {
    #####:10603:    if (str) {
    #####:10604:        return ::Catch::Detail::stringify(std::string{ str });
        -:10605:    } else {
    #####:10606:        return{ "{null string}" };
        -:10607:    }
        -:10608:}
        -:10609:#ifdef CATCH_CONFIG_WCHAR
    #####:10610:std::string StringMaker<wchar_t const*>::convert(wchar_t const * str) {
    #####:10611:    if (str) {
    #####:10612:        return ::Catch::Detail::stringify(std::wstring{ str });
        -:10613:    } else {
    #####:10614:        return{ "{null string}" };
        -:10615:    }
        -:10616:}
    #####:10617:std::string StringMaker<wchar_t *>::convert(wchar_t * str) {
    #####:10618:    if (str) {
    #####:10619:        return ::Catch::Detail::stringify(std::wstring{ str });
        -:10620:    } else {
    #####:10621:        return{ "{null string}" };
        -:10622:    }
        -:10623:}
        -:10624:#endif
        -:10625:
    #####:10626:std::string StringMaker<int>::convert(int value) {
    #####:10627:    return ::Catch::Detail::stringify(static_cast<long long>(value));
        -:10628:}
    #####:10629:std::string StringMaker<long>::convert(long value) {
    #####:10630:    return ::Catch::Detail::stringify(static_cast<long long>(value));
        -:10631:}
    #####:10632:std::string StringMaker<long long>::convert(long long value) {
    #####:10633:    ReusableStringStream rss;
    #####:10634:    rss << value;
    #####:10635:    if (value > Detail::hexThreshold) {
    #####:10636:        rss << " (0x" << std::hex << value << ')';
        -:10637:    }
    #####:10638:    return rss.str();
    #####:10639:}
        -:10640:
    #####:10641:std::string StringMaker<unsigned int>::convert(unsigned int value) {
    #####:10642:    return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));
        -:10643:}
    #####:10644:std::string StringMaker<unsigned long>::convert(unsigned long value) {
    #####:10645:    return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));
        -:10646:}
    #####:10647:std::string StringMaker<unsigned long long>::convert(unsigned long long value) {
    #####:10648:    ReusableStringStream rss;
    #####:10649:    rss << value;
    #####:10650:    if (value > Detail::hexThreshold) {
    #####:10651:        rss << " (0x" << std::hex << value << ')';
        -:10652:    }
    #####:10653:    return rss.str();
    #####:10654:}
        -:10655:
    #####:10656:std::string StringMaker<bool>::convert(bool b) {
    #####:10657:    return b ? "true" : "false";
        -:10658:}
        -:10659:
    #####:10660:std::string StringMaker<char>::convert(char value) {
    #####:10661:    if (value == '\r') {
    #####:10662:        return "'\\r'";
    #####:10663:    } else if (value == '\f') {
    #####:10664:        return "'\\f'";
    #####:10665:    } else if (value == '\n') {
    #####:10666:        return "'\\n'";
    #####:10667:    } else if (value == '\t') {
    #####:10668:        return "'\\t'";
    #####:10669:    } else if ('\0' <= value && value < ' ') {
    #####:10670:        return ::Catch::Detail::stringify(static_cast<unsigned int>(value));
        -:10671:    } else {
    #####:10672:        char chstr[] = "' '";
    #####:10673:        chstr[1] = value;
    #####:10674:        return chstr;
        -:10675:    }
        -:10676:}
    #####:10677:std::string StringMaker<signed char>::convert(signed char c) {
    #####:10678:    return ::Catch::Detail::stringify(static_cast<char>(c));
        -:10679:}
    #####:10680:std::string StringMaker<unsigned char>::convert(unsigned char c) {
    #####:10681:    return ::Catch::Detail::stringify(static_cast<char>(c));
        -:10682:}
        -:10683:
    #####:10684:std::string StringMaker<std::nullptr_t>::convert(std::nullptr_t) {
    #####:10685:    return "nullptr";
        -:10686:}
        -:10687:
    #####:10688:std::string StringMaker<float>::convert(float value) {
    #####:10689:    return fpToString(value, 5) + 'f';
        -:10690:}
    #####:10691:std::string StringMaker<double>::convert(double value) {
    #####:10692:    return fpToString(value, 10);
        -:10693:}
        -:10694:
    #####:10695:std::string ratio_string<std::atto>::symbol() { return "a"; }
    #####:10696:std::string ratio_string<std::femto>::symbol() { return "f"; }
    #####:10697:std::string  ratio_string<std::pico>::symbol() { return "p"; }
    #####:10698:std::string  ratio_string<std::nano>::symbol() { return "n"; }
    #####:10699:std::string ratio_string<std::micro>::symbol() { return "u"; }
    #####:10700:std::string ratio_string<std::milli>::symbol() { return "m"; }
        -:10701:
        -:10702:} // end namespace Catch
        -:10703:
        -:10704:#if defined(__clang__)
        -:10705:#    pragma clang diagnostic pop
        -:10706:#endif
        -:10707:
        -:10708:// end catch_tostring.cpp
        -:10709:// start catch_totals.cpp
        -:10710:
        -:10711:namespace Catch {
        -:10712:
       27:10713:    Counts Counts::operator - ( Counts const& other ) const {
       27:10714:        Counts diff;
       27:10715:        diff.passed = passed - other.passed;
       27:10716:        diff.failed = failed - other.failed;
       27:10717:        diff.failedButOk = failedButOk - other.failedButOk;
       27:10718:        return diff;
        -:10719:    }
        -:10720:
       12:10721:    Counts& Counts::operator += ( Counts const& other ) {
       12:10722:        passed += other.passed;
       12:10723:        failed += other.failed;
       12:10724:        failedButOk += other.failedButOk;
       12:10725:        return *this;
        -:10726:    }
        -:10727:
       25:10728:    std::size_t Counts::total() const {
       25:10729:        return passed + failed + failedButOk;
        -:10730:    }
        2:10731:    bool Counts::allPassed() const {
       2*:10732:        return failed == 0 && failedButOk == 0;
        -:10733:    }
    #####:10734:    bool Counts::allOk() const {
    #####:10735:        return failed == 0;
        -:10736:    }
        -:10737:
        4:10738:    Totals Totals::operator - ( Totals const& other ) const {
        4:10739:        Totals diff;
        4:10740:        diff.assertions = assertions - other.assertions;
        4:10741:        diff.testCases = testCases - other.testCases;
        4:10742:        return diff;
        -:10743:    }
        -:10744:
        4:10745:    Totals& Totals::operator += ( Totals const& other ) {
        4:10746:        assertions += other.assertions;
        4:10747:        testCases += other.testCases;
        4:10748:        return *this;
        -:10749:    }
        -:10750:
        4:10751:    Totals Totals::delta( Totals const& prevTotals ) const {
        4:10752:        Totals diff = *this - prevTotals;
        4:10753:        if( diff.assertions.failed > 0 )
    #####:10754:            ++diff.testCases.failed;
        4:10755:        else if( diff.assertions.failedButOk > 0 )
    #####:10756:            ++diff.testCases.failedButOk;
        -:10757:        else
        4:10758:            ++diff.testCases.passed;
        4:10759:        return diff;
        -:10760:    }
        -:10761:
        -:10762:}
        -:10763:// end catch_totals.cpp
        -:10764:// start catch_uncaught_exceptions.cpp
        -:10765:
        -:10766:#include <exception>
        -:10767:
        -:10768:namespace Catch {
        9:10769:    bool uncaught_exceptions() {
        -:10770:#if defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
        -:10771:        return std::uncaught_exceptions() > 0;
        -:10772:#else
        9:10773:        return std::uncaught_exception();
        -:10774:#endif
        -:10775:  }
        -:10776:} // end namespace Catch
        -:10777:// end catch_uncaught_exceptions.cpp
        -:10778:// start catch_version.cpp
        -:10779:
        -:10780:#include <ostream>
        -:10781:
        -:10782:namespace Catch {
        -:10783:
    #####:10784:    Version::Version
        -:10785:        (   unsigned int _majorVersion,
        -:10786:            unsigned int _minorVersion,
        -:10787:            unsigned int _patchNumber,
        -:10788:            char const * const _branchName,
    #####:10789:            unsigned int _buildNumber )
    #####:10790:    :   majorVersion( _majorVersion ),
    #####:10791:        minorVersion( _minorVersion ),
    #####:10792:        patchNumber( _patchNumber ),
    #####:10793:        branchName( _branchName ),
    #####:10794:        buildNumber( _buildNumber )
    #####:10795:    {}
        -:10796:
    #####:10797:    std::ostream& operator << ( std::ostream& os, Version const& version ) {
    #####:10798:        os  << version.majorVersion << '.'
    #####:10799:            << version.minorVersion << '.'
    #####:10800:            << version.patchNumber;
        -:10801:        // branchName is never null -> 0th char is \0 if it is empty
    #####:10802:        if (version.branchName[0]) {
    #####:10803:            os << '-' << version.branchName
    #####:10804:               << '.' << version.buildNumber;
        -:10805:        }
    #####:10806:        return os;
        -:10807:    }
        -:10808:
    #####:10809:    Version const& libraryVersion() {
    #####:10810:        static Version version( 2, 2, 1, "", 0 );
    #####:10811:        return version;
        -:10812:    }
        -:10813:
        -:10814:}
        -:10815:// end catch_version.cpp
        -:10816:// start catch_wildcard_pattern.cpp
        -:10817:
        -:10818:#include <sstream>
        -:10819:
        -:10820:namespace Catch {
        -:10821:
    #####:10822:    WildcardPattern::WildcardPattern( std::string const& pattern,
    #####:10823:                                      CaseSensitive::Choice caseSensitivity )
    #####:10824:    :   m_caseSensitivity( caseSensitivity ),
    #####:10825:        m_pattern( adjustCase( pattern ) )
        -:10826:    {
    #####:10827:        if( startsWith( m_pattern, '*' ) ) {
    #####:10828:            m_pattern = m_pattern.substr( 1 );
    #####:10829:            m_wildcard = WildcardAtStart;
        -:10830:        }
    #####:10831:        if( endsWith( m_pattern, '*' ) ) {
    #####:10832:            m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );
    #####:10833:            m_wildcard = static_cast<WildcardPosition>( m_wildcard | WildcardAtEnd );
        -:10834:        }
    #####:10835:    }
        -:10836:
    #####:10837:    bool WildcardPattern::matches( std::string const& str ) const {
    #####:10838:        switch( m_wildcard ) {
    #####:10839:            case NoWildcard:
    #####:10840:                return m_pattern == adjustCase( str );
    #####:10841:            case WildcardAtStart:
    #####:10842:                return endsWith( adjustCase( str ), m_pattern );
    #####:10843:            case WildcardAtEnd:
    #####:10844:                return startsWith( adjustCase( str ), m_pattern );
    #####:10845:            case WildcardAtBothEnds:
    #####:10846:                return contains( adjustCase( str ), m_pattern );
    #####:10847:            default:
    #####:10848:                CATCH_INTERNAL_ERROR( "Unknown enum" );
        -:10849:        }
        -:10850:    }
        -:10851:
    #####:10852:    std::string WildcardPattern::adjustCase( std::string const& str ) const {
    #####:10853:        return m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str;
        -:10854:    }
        -:10855:}
        -:10856:// end catch_wildcard_pattern.cpp
        -:10857:// start catch_xmlwriter.cpp
        -:10858:
        -:10859:#include <iomanip>
        -:10860:
        -:10861:namespace Catch {
        -:10862:
    #####:10863:    XmlEncode::XmlEncode( std::string const& str, ForWhat forWhat )
    #####:10864:    :   m_str( str ),
    #####:10865:        m_forWhat( forWhat )
    #####:10866:    {}
        -:10867:
    #####:10868:    void XmlEncode::encodeTo( std::ostream& os ) const {
        -:10869:
        -:10870:        // Apostrophe escaping not necessary if we always use " to write attributes
        -:10871:        // (see: http://www.w3.org/TR/xml/#syntax)
        -:10872:
    #####:10873:        for( std::size_t i = 0; i < m_str.size(); ++ i ) {
    #####:10874:            char c = m_str[i];
    #####:10875:            switch( c ) {
    #####:10876:                case '<':   os << "&lt;"; break;
    #####:10877:                case '&':   os << "&amp;"; break;
        -:10878:
    #####:10879:                case '>':
        -:10880:                    // See: http://www.w3.org/TR/xml/#syntax
    #####:10881:                    if( i > 2 && m_str[i-1] == ']' && m_str[i-2] == ']' )
    #####:10882:                        os << "&gt;";
        -:10883:                    else
    #####:10884:                        os << c;
    #####:10885:                    break;
        -:10886:
    #####:10887:                case '\"':
    #####:10888:                    if( m_forWhat == ForAttributes )
    #####:10889:                        os << "&quot;";
        -:10890:                    else
    #####:10891:                        os << c;
    #####:10892:                    break;
        -:10893:
    #####:10894:                default:
        -:10895:                    // Escape control chars - based on contribution by @espenalb in PR #465 and
        -:10896:                    // by @mrpi PR #588
    #####:10897:                    if ( ( c >= 0 && c < '\x09' ) || ( c > '\x0D' && c < '\x20') || c=='\x7F' ) {
        -:10898:                        // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0
    #####:10899:                        os << "\\x" << std::uppercase << std::hex << std::setfill('0') << std::setw(2)
    #####:10900:                           << static_cast<int>( c );
        -:10901:                    }
        -:10902:                    else
    #####:10903:                        os << c;
        -:10904:            }
        -:10905:        }
    #####:10906:    }
        -:10907:
    #####:10908:    std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {
    #####:10909:        xmlEncode.encodeTo( os );
    #####:10910:        return os;
        -:10911:    }
        -:10912:
    #####:10913:    XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer )
    #####:10914:    :   m_writer( writer )
    #####:10915:    {}
        -:10916:
    #####:10917:    XmlWriter::ScopedElement::ScopedElement( ScopedElement&& other ) noexcept
    #####:10918:    :   m_writer( other.m_writer ){
    #####:10919:        other.m_writer = nullptr;
    #####:10920:    }
    #####:10921:    XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=( ScopedElement&& other ) noexcept {
    #####:10922:        if ( m_writer ) {
    #####:10923:            m_writer->endElement();
        -:10924:        }
    #####:10925:        m_writer = other.m_writer;
    #####:10926:        other.m_writer = nullptr;
    #####:10927:        return *this;
        -:10928:    }
        -:10929:
    #####:10930:    XmlWriter::ScopedElement::~ScopedElement() {
    #####:10931:        if( m_writer )
    #####:10932:            m_writer->endElement();
    #####:10933:    }
        -:10934:
    #####:10935:    XmlWriter::ScopedElement& XmlWriter::ScopedElement::writeText( std::string const& text, bool indent ) {
    #####:10936:        m_writer->writeText( text, indent );
    #####:10937:        return *this;
        -:10938:    }
        -:10939:
    #####:10940:    XmlWriter::XmlWriter( std::ostream& os ) : m_os( os )
        -:10941:    {
    #####:10942:        writeDeclaration();
    #####:10943:    }
        -:10944:
    #####:10945:    XmlWriter::~XmlWriter() {
    #####:10946:        while( !m_tags.empty() )
    #####:10947:            endElement();
    #####:10948:    }
        -:10949:
    #####:10950:    XmlWriter& XmlWriter::startElement( std::string const& name ) {
    #####:10951:        ensureTagClosed();
    #####:10952:        newlineIfNecessary();
    #####:10953:        m_os << m_indent << '<' << name;
    #####:10954:        m_tags.push_back( name );
    #####:10955:        m_indent += "  ";
    #####:10956:        m_tagIsOpen = true;
    #####:10957:        return *this;
        -:10958:    }
        -:10959:
    #####:10960:    XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const& name ) {
    #####:10961:        ScopedElement scoped( this );
    #####:10962:        startElement( name );
    #####:10963:        return scoped;
    =====:10964:    }
        -:10965:
    #####:10966:    XmlWriter& XmlWriter::endElement() {
    #####:10967:        newlineIfNecessary();
    #####:10968:        m_indent = m_indent.substr( 0, m_indent.size()-2 );
    #####:10969:        if( m_tagIsOpen ) {
    #####:10970:            m_os << "/>";
    #####:10971:            m_tagIsOpen = false;
        -:10972:        }
        -:10973:        else {
    #####:10974:            m_os << m_indent << "</" << m_tags.back() << ">";
        -:10975:        }
    #####:10976:        m_os << std::endl;
    #####:10977:        m_tags.pop_back();
    #####:10978:        return *this;
        -:10979:    }
        -:10980:
    #####:10981:    XmlWriter& XmlWriter::writeAttribute( std::string const& name, std::string const& attribute ) {
    #####:10982:        if( !name.empty() && !attribute.empty() )
    #####:10983:            m_os << ' ' << name << "=\"" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '"';
    #####:10984:        return *this;
        -:10985:    }
        -:10986:
    #####:10987:    XmlWriter& XmlWriter::writeAttribute( std::string const& name, bool attribute ) {
    #####:10988:        m_os << ' ' << name << "=\"" << ( attribute ? "true" : "false" ) << '"';
    #####:10989:        return *this;
        -:10990:    }
        -:10991:
    #####:10992:    XmlWriter& XmlWriter::writeText( std::string const& text, bool indent ) {
    #####:10993:        if( !text.empty() ){
    #####:10994:            bool tagWasOpen = m_tagIsOpen;
    #####:10995:            ensureTagClosed();
    #####:10996:            if( tagWasOpen && indent )
    #####:10997:                m_os << m_indent;
    #####:10998:            m_os << XmlEncode( text );
    #####:10999:            m_needsNewline = true;
        -:11000:        }
    #####:11001:        return *this;
        -:11002:    }
        -:11003:
    #####:11004:    XmlWriter& XmlWriter::writeComment( std::string const& text ) {
    #####:11005:        ensureTagClosed();
    #####:11006:        m_os << m_indent << "<!--" << text << "-->";
    #####:11007:        m_needsNewline = true;
    #####:11008:        return *this;
        -:11009:    }
        -:11010:
    #####:11011:    void XmlWriter::writeStylesheetRef( std::string const& url ) {
    #####:11012:        m_os << "<?xml-stylesheet type=\"text/xsl\" href=\"" << url << "\"?>\n";
    #####:11013:    }
        -:11014:
    #####:11015:    XmlWriter& XmlWriter::writeBlankLine() {
    #####:11016:        ensureTagClosed();
    #####:11017:        m_os << '\n';
    #####:11018:        return *this;
        -:11019:    }
        -:11020:
    #####:11021:    void XmlWriter::ensureTagClosed() {
    #####:11022:        if( m_tagIsOpen ) {
    #####:11023:            m_os << ">" << std::endl;
    #####:11024:            m_tagIsOpen = false;
        -:11025:        }
    #####:11026:    }
        -:11027:
    #####:11028:    void XmlWriter::writeDeclaration() {
    #####:11029:        m_os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    #####:11030:    }
        -:11031:
    #####:11032:    void XmlWriter::newlineIfNecessary() {
    #####:11033:        if( m_needsNewline ) {
    #####:11034:            m_os << std::endl;
    #####:11035:            m_needsNewline = false;
        -:11036:        }
    #####:11037:    }
        -:11038:}
        -:11039:// end catch_xmlwriter.cpp
        -:11040:// start catch_reporter_bases.cpp
        -:11041:
        -:11042:#include <cstring>
        -:11043:#include <cfloat>
        -:11044:#include <cstdio>
        -:11045:#include <assert.h>
        -:11046:#include <memory>
        -:11047:
        -:11048:namespace Catch {
    #####:11049:    void prepareExpandedExpression(AssertionResult& result) {
    #####:11050:        result.getExpandedExpression();
    #####:11051:    }
        -:11052:
        -:11053:    // Because formatting using c++ streams is stateful, drop down to C is required
        -:11054:    // Alternatively we could use stringstream, but its performance is... not good.
    #####:11055:    std::string getFormattedDuration( double duration ) {
        -:11056:        // Max exponent + 1 is required to represent the whole part
        -:11057:        // + 1 for decimal point
        -:11058:        // + 3 for the 3 decimal places
        -:11059:        // + 1 for null terminator
    #####:11060:        const std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;
        -:11061:        char buffer[maxDoubleSize];
        -:11062:
        -:11063:        // Save previous errno, to prevent sprintf from overwriting it
    #####:11064:        ErrnoGuard guard;
        -:11065:#ifdef _MSC_VER
        -:11066:        sprintf_s(buffer, "%.3f", duration);
        -:11067:#else
    #####:11068:        sprintf(buffer, "%.3f", duration);
        -:11069:#endif
    #####:11070:        return std::string(buffer);
    #####:11071:    }
        -:11072:
    #####:11073:    TestEventListenerBase::TestEventListenerBase(ReporterConfig const & _config)
    #####:11074:        :StreamingReporterBase(_config) {}
        -:11075:
    #####:11076:    void TestEventListenerBase::assertionStarting(AssertionInfo const &) {}
        -:11077:
    #####:11078:    bool TestEventListenerBase::assertionEnded(AssertionStats const &) {
    #####:11079:        return false;
        -:11080:    }
        -:11081:
        -:11082:} // end namespace Catch
        -:11083:// end catch_reporter_bases.cpp
        -:11084:// start catch_reporter_compact.cpp
        -:11085:
        -:11086:namespace {
        -:11087:
        -:11088:#ifdef CATCH_PLATFORM_MAC
        -:11089:    const char* failedString() { return "FAILED"; }
        -:11090:    const char* passedString() { return "PASSED"; }
        -:11091:#else
    #####:11092:    const char* failedString() { return "failed"; }
    #####:11093:    const char* passedString() { return "passed"; }
        -:11094:#endif
        -:11095:
        -:11096:    // Colour::LightGrey
    #####:11097:    Catch::Colour::Code dimColour() { return Catch::Colour::FileName; }
        -:11098:
    #####:11099:    std::string bothOrAll( std::size_t count ) {
        -:11100:        return count == 1 ? std::string() :
    #####:11101:               count == 2 ? "both " : "all " ;
        -:11102:    }
        -:11103:
        -:11104:} // anon namespace
        -:11105:
        -:11106:namespace Catch {
        -:11107:namespace {
        -:11108:// Colour, message variants:
        -:11109:// - white: No tests ran.
        -:11110:// -   red: Failed [both/all] N test cases, failed [both/all] M assertions.
        -:11111:// - white: Passed [both/all] N test cases (no assertions).
        -:11112:// -   red: Failed N tests cases, failed M assertions.
        -:11113:// - green: Passed [both/all] N tests cases with M assertions.
    #####:11114:void printTotals(std::ostream& out, const Totals& totals) {
    #####:11115:    if (totals.testCases.total() == 0) {
    #####:11116:        out << "No tests ran.";
    #####:11117:    } else if (totals.testCases.failed == totals.testCases.total()) {
    #####:11118:        Colour colour(Colour::ResultError);
        -:11119:        const std::string qualify_assertions_failed =
    #####:11120:            totals.assertions.failed == totals.assertions.total() ?
    #####:11121:            bothOrAll(totals.assertions.failed) : std::string();
        -:11122:        out <<
    #####:11123:            "Failed " << bothOrAll(totals.testCases.failed)
    #####:11124:            << pluralise(totals.testCases.failed, "test case") << ", "
    #####:11125:            "failed " << qualify_assertions_failed <<
    #####:11126:            pluralise(totals.assertions.failed, "assertion") << '.';
    #####:11127:    } else if (totals.assertions.total() == 0) {
        -:11128:        out <<
    #####:11129:            "Passed " << bothOrAll(totals.testCases.total())
    #####:11130:            << pluralise(totals.testCases.total(), "test case")
    #####:11131:            << " (no assertions).";
    #####:11132:    } else if (totals.assertions.failed) {
    #####:11133:        Colour colour(Colour::ResultError);
        -:11134:        out <<
    #####:11135:            "Failed " << pluralise(totals.testCases.failed, "test case") << ", "
    #####:11136:            "failed " << pluralise(totals.assertions.failed, "assertion") << '.';
    #####:11137:    } else {
    #####:11138:        Colour colour(Colour::ResultSuccess);
        -:11139:        out <<
    #####:11140:            "Passed " << bothOrAll(totals.testCases.passed)
    #####:11141:            << pluralise(totals.testCases.passed, "test case") <<
    #####:11142:            " with " << pluralise(totals.assertions.passed, "assertion") << '.';
    #####:11143:    }
    #####:11144:}
        -:11145:
        -:11146:// Implementation of CompactReporter formatting
        -:11147:class AssertionPrinter {
        -:11148:public:
        -:11149:    AssertionPrinter& operator= (AssertionPrinter const&) = delete;
        -:11150:    AssertionPrinter(AssertionPrinter const&) = delete;
    #####:11151:    AssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
    #####:11152:        : stream(_stream)
    #####:11153:        , result(_stats.assertionResult)
    #####:11154:        , messages(_stats.infoMessages)
    #####:11155:        , itMessage(_stats.infoMessages.begin())
    #####:11156:        , printInfoMessages(_printInfoMessages) {}
        -:11157:
    #####:11158:    void print() {
    #####:11159:        printSourceInfo();
        -:11160:
    #####:11161:        itMessage = messages.begin();
        -:11162:
    #####:11163:        switch (result.getResultType()) {
    #####:11164:        case ResultWas::Ok:
    #####:11165:            printResultType(Colour::ResultSuccess, passedString());
    #####:11166:            printOriginalExpression();
    #####:11167:            printReconstructedExpression();
    #####:11168:            if (!result.hasExpression())
    #####:11169:                printRemainingMessages(Colour::None);
        -:11170:            else
    #####:11171:                printRemainingMessages();
    #####:11172:            break;
    #####:11173:        case ResultWas::ExpressionFailed:
    #####:11174:            if (result.isOk())
    #####:11175:                printResultType(Colour::ResultSuccess, failedString() + std::string(" - but was ok"));
        -:11176:            else
    #####:11177:                printResultType(Colour::Error, failedString());
    #####:11178:            printOriginalExpression();
    #####:11179:            printReconstructedExpression();
    #####:11180:            printRemainingMessages();
    #####:11181:            break;
    #####:11182:        case ResultWas::ThrewException:
    #####:11183:            printResultType(Colour::Error, failedString());
    #####:11184:            printIssue("unexpected exception with message:");
    #####:11185:            printMessage();
    #####:11186:            printExpressionWas();
    #####:11187:            printRemainingMessages();
    #####:11188:            break;
    #####:11189:        case ResultWas::FatalErrorCondition:
    #####:11190:            printResultType(Colour::Error, failedString());
    #####:11191:            printIssue("fatal error condition with message:");
    #####:11192:            printMessage();
    #####:11193:            printExpressionWas();
    #####:11194:            printRemainingMessages();
    #####:11195:            break;
    #####:11196:        case ResultWas::DidntThrowException:
    #####:11197:            printResultType(Colour::Error, failedString());
    #####:11198:            printIssue("expected exception, got none");
    #####:11199:            printExpressionWas();
    #####:11200:            printRemainingMessages();
    #####:11201:            break;
    #####:11202:        case ResultWas::Info:
    #####:11203:            printResultType(Colour::None, "info");
    #####:11204:            printMessage();
    #####:11205:            printRemainingMessages();
    #####:11206:            break;
    #####:11207:        case ResultWas::Warning:
    #####:11208:            printResultType(Colour::None, "warning");
    #####:11209:            printMessage();
    #####:11210:            printRemainingMessages();
    #####:11211:            break;
    #####:11212:        case ResultWas::ExplicitFailure:
    #####:11213:            printResultType(Colour::Error, failedString());
    #####:11214:            printIssue("explicitly");
    #####:11215:            printRemainingMessages(Colour::None);
    #####:11216:            break;
        -:11217:            // These cases are here to prevent compiler warnings
    #####:11218:        case ResultWas::Unknown:
        -:11219:        case ResultWas::FailureBit:
        -:11220:        case ResultWas::Exception:
    #####:11221:            printResultType(Colour::Error, "** internal error **");
    #####:11222:            break;
        -:11223:        }
    #####:11224:    }
        -:11225:
        -:11226:private:
    #####:11227:    void printSourceInfo() const {
    #####:11228:        Colour colourGuard(Colour::FileName);
    #####:11229:        stream << result.getSourceInfo() << ':';
    #####:11230:    }
        -:11231:
    #####:11232:    void printResultType(Colour::Code colour, std::string const& passOrFail) const {
    #####:11233:        if (!passOrFail.empty()) {
        -:11234:            {
    #####:11235:                Colour colourGuard(colour);
    #####:11236:                stream << ' ' << passOrFail;
    #####:11237:            }
    #####:11238:            stream << ':';
        -:11239:        }
    #####:11240:    }
        -:11241:
    #####:11242:    void printIssue(std::string const& issue) const {
    #####:11243:        stream << ' ' << issue;
    #####:11244:    }
        -:11245:
    #####:11246:    void printExpressionWas() {
    #####:11247:        if (result.hasExpression()) {
    #####:11248:            stream << ';';
        -:11249:            {
    #####:11250:                Colour colour(dimColour());
    #####:11251:                stream << " expression was:";
    #####:11252:            }
    #####:11253:            printOriginalExpression();
        -:11254:        }
    #####:11255:    }
        -:11256:
    #####:11257:    void printOriginalExpression() const {
    #####:11258:        if (result.hasExpression()) {
    #####:11259:            stream << ' ' << result.getExpression();
        -:11260:        }
    #####:11261:    }
        -:11262:
    #####:11263:    void printReconstructedExpression() const {
    #####:11264:        if (result.hasExpandedExpression()) {
        -:11265:            {
    #####:11266:                Colour colour(dimColour());
    #####:11267:                stream << " for: ";
    #####:11268:            }
    #####:11269:            stream << result.getExpandedExpression();
        -:11270:        }
    #####:11271:    }
        -:11272:
    #####:11273:    void printMessage() {
    #####:11274:        if (itMessage != messages.end()) {
    #####:11275:            stream << " '" << itMessage->message << '\'';
    #####:11276:            ++itMessage;
        -:11277:        }
    #####:11278:    }
        -:11279:
    #####:11280:    void printRemainingMessages(Colour::Code colour = dimColour()) {
    #####:11281:        if (itMessage == messages.end())
    #####:11282:            return;
        -:11283:
        -:11284:        // using messages.end() directly yields (or auto) compilation error:
    #####:11285:        std::vector<MessageInfo>::const_iterator itEnd = messages.end();
    #####:11286:        const std::size_t N = static_cast<std::size_t>(std::distance(itMessage, itEnd));
        -:11287:
        -:11288:        {
    #####:11289:            Colour colourGuard(colour);
    #####:11290:            stream << " with " << pluralise(N, "message") << ':';
    #####:11291:        }
        -:11292:
    #####:11293:        for (; itMessage != itEnd; ) {
        -:11294:            // If this assertion is a warning ignore any INFO messages
    #####:11295:            if (printInfoMessages || itMessage->type != ResultWas::Info) {
    #####:11296:                stream << " '" << itMessage->message << '\'';
    #####:11297:                if (++itMessage != itEnd) {
    #####:11298:                    Colour colourGuard(dimColour());
    #####:11299:                    stream << " and";
    #####:11300:                }
        -:11301:            }
        -:11302:        }
        -:11303:    }
        -:11304:
        -:11305:private:
        -:11306:    std::ostream& stream;
        -:11307:    AssertionResult const& result;
        -:11308:    std::vector<MessageInfo> messages;
        -:11309:    std::vector<MessageInfo>::const_iterator itMessage;
        -:11310:    bool printInfoMessages;
        -:11311:};
        -:11312:
        -:11313:} // anon namespace
        -:11314:
    #####:11315:        std::string CompactReporter::getDescription() {
    #####:11316:            return "Reports test results on a single line, suitable for IDEs";
        -:11317:        }
        -:11318:
    #####:11319:        ReporterPreferences CompactReporter::getPreferences() const {
    #####:11320:            ReporterPreferences prefs;
    #####:11321:            prefs.shouldRedirectStdOut = false;
    #####:11322:            return prefs;
        -:11323:        }
        -:11324:
    #####:11325:        void CompactReporter::noMatchingTestCases( std::string const& spec ) {
    #####:11326:            stream << "No test cases matched '" << spec << '\'' << std::endl;
    #####:11327:        }
        -:11328:
    #####:11329:        void CompactReporter::assertionStarting( AssertionInfo const& ) {}
        -:11330:
    #####:11331:        bool CompactReporter::assertionEnded( AssertionStats const& _assertionStats ) {
    #####:11332:            AssertionResult const& result = _assertionStats.assertionResult;
        -:11333:
    #####:11334:            bool printInfoMessages = true;
        -:11335:
        -:11336:            // Drop out if result was successful and we're not printing those
    #####:11337:            if( !m_config->includeSuccessfulResults() && result.isOk() ) {
    #####:11338:                if( result.getResultType() != ResultWas::Warning )
    #####:11339:                    return false;
    #####:11340:                printInfoMessages = false;
        -:11341:            }
        -:11342:
    #####:11343:            AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
    #####:11344:            printer.print();
        -:11345:
    #####:11346:            stream << std::endl;
    #####:11347:            return true;
    #####:11348:        }
        -:11349:
    #####:11350:        void CompactReporter::sectionEnded(SectionStats const& _sectionStats) {
    #####:11351:            if (m_config->showDurations() == ShowDurations::Always) {
    #####:11352:                stream << getFormattedDuration(_sectionStats.durationInSeconds) << " s: " << _sectionStats.sectionInfo.name << std::endl;
        -:11353:            }
    #####:11354:        }
        -:11355:
    #####:11356:        void CompactReporter::testRunEnded( TestRunStats const& _testRunStats ) {
    #####:11357:            printTotals( stream, _testRunStats.totals );
    #####:11358:            stream << '\n' << std::endl;
    #####:11359:            StreamingReporterBase::testRunEnded( _testRunStats );
    #####:11360:        }
        -:11361:
    #####:11362:        CompactReporter::~CompactReporter() {}
------------------
_ZN5Catch15CompactReporterD0Ev:
    #####:11362:        CompactReporter::~CompactReporter() {}
------------------
_ZN5Catch15CompactReporterD2Ev:
    #####:11362:        CompactReporter::~CompactReporter() {}
------------------
        -:11363:
        -:11364:    CATCH_REGISTER_REPORTER( "compact", CompactReporter )
        -:11365:
        -:11366:} // end namespace Catch
        -:11367:// end catch_reporter_compact.cpp
        -:11368:// start catch_reporter_console.cpp
        -:11369:
        -:11370:#include <cfloat>
        -:11371:#include <cstdio>
        -:11372:
        -:11373:#if defined(_MSC_VER)
        -:11374:#pragma warning(push)
        -:11375:#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
        -:11376: // Note that 4062 (not all labels are handled
        -:11377: // and default is missing) is enabled
        -:11378:#endif
        -:11379:
        -:11380:namespace Catch {
        -:11381:
        -:11382:namespace {
        -:11383:
        -:11384:// Formatter impl for ConsoleReporter
        -:11385:class ConsoleAssertionPrinter {
        -:11386:public:
        -:11387:    ConsoleAssertionPrinter& operator= (ConsoleAssertionPrinter const&) = delete;
        -:11388:    ConsoleAssertionPrinter(ConsoleAssertionPrinter const&) = delete;
    #####:11389:    ConsoleAssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
    #####:11390:        : stream(_stream),
    #####:11391:        stats(_stats),
    #####:11392:        result(_stats.assertionResult),
    #####:11393:        colour(Colour::None),
    #####:11394:        message(result.getMessage()),
    #####:11395:        messages(_stats.infoMessages),
    #####:11396:        printInfoMessages(_printInfoMessages) {
    #####:11397:        switch (result.getResultType()) {
    #####:11398:        case ResultWas::Ok:
    #####:11399:            colour = Colour::Success;
    #####:11400:            passOrFail = "PASSED";
        -:11401:            //if( result.hasMessage() )
    #####:11402:            if (_stats.infoMessages.size() == 1)
    #####:11403:                messageLabel = "with message";
    #####:11404:            if (_stats.infoMessages.size() > 1)
    #####:11405:                messageLabel = "with messages";
    #####:11406:            break;
    #####:11407:        case ResultWas::ExpressionFailed:
    #####:11408:            if (result.isOk()) {
    #####:11409:                colour = Colour::Success;
    #####:11410:                passOrFail = "FAILED - but was ok";
        -:11411:            } else {
    #####:11412:                colour = Colour::Error;
    #####:11413:                passOrFail = "FAILED";
        -:11414:            }
    #####:11415:            if (_stats.infoMessages.size() == 1)
    #####:11416:                messageLabel = "with message";
    #####:11417:            if (_stats.infoMessages.size() > 1)
    #####:11418:                messageLabel = "with messages";
    #####:11419:            break;
    #####:11420:        case ResultWas::ThrewException:
    #####:11421:            colour = Colour::Error;
    #####:11422:            passOrFail = "FAILED";
    #####:11423:            messageLabel = "due to unexpected exception with ";
    #####:11424:            if (_stats.infoMessages.size() == 1)
    #####:11425:                messageLabel += "message";
    #####:11426:            if (_stats.infoMessages.size() > 1)
    #####:11427:                messageLabel += "messages";
    #####:11428:            break;
    #####:11429:        case ResultWas::FatalErrorCondition:
    #####:11430:            colour = Colour::Error;
    #####:11431:            passOrFail = "FAILED";
    #####:11432:            messageLabel = "due to a fatal error condition";
    #####:11433:            break;
    #####:11434:        case ResultWas::DidntThrowException:
    #####:11435:            colour = Colour::Error;
    #####:11436:            passOrFail = "FAILED";
    #####:11437:            messageLabel = "because no exception was thrown where one was expected";
    #####:11438:            break;
    #####:11439:        case ResultWas::Info:
    #####:11440:            messageLabel = "info";
    #####:11441:            break;
    #####:11442:        case ResultWas::Warning:
    #####:11443:            messageLabel = "warning";
    #####:11444:            break;
    #####:11445:        case ResultWas::ExplicitFailure:
    #####:11446:            passOrFail = "FAILED";
    #####:11447:            colour = Colour::Error;
    #####:11448:            if (_stats.infoMessages.size() == 1)
    #####:11449:                messageLabel = "explicitly with message";
    #####:11450:            if (_stats.infoMessages.size() > 1)
    #####:11451:                messageLabel = "explicitly with messages";
    #####:11452:            break;
        -:11453:            // These cases are here to prevent compiler warnings
    #####:11454:        case ResultWas::Unknown:
        -:11455:        case ResultWas::FailureBit:
        -:11456:        case ResultWas::Exception:
    #####:11457:            passOrFail = "** internal error **";
    #####:11458:            colour = Colour::Error;
    #####:11459:            break;
        -:11460:        }
    #####:11461:    }
        -:11462:
    #####:11463:    void print() const {
    #####:11464:        printSourceInfo();
    #####:11465:        if (stats.totals.assertions.total() > 0) {
    #####:11466:            if (result.isOk())
    #####:11467:                stream << '\n';
    #####:11468:            printResultType();
    #####:11469:            printOriginalExpression();
    #####:11470:            printReconstructedExpression();
        -:11471:        } else {
    #####:11472:            stream << '\n';
        -:11473:        }
    #####:11474:        printMessage();
    #####:11475:    }
        -:11476:
        -:11477:private:
    #####:11478:    void printResultType() const {
    #####:11479:        if (!passOrFail.empty()) {
    #####:11480:            Colour colourGuard(colour);
    #####:11481:            stream << passOrFail << ":\n";
    #####:11482:        }
    #####:11483:    }
    #####:11484:    void printOriginalExpression() const {
    #####:11485:        if (result.hasExpression()) {
    #####:11486:            Colour colourGuard(Colour::OriginalExpression);
    #####:11487:            stream << "  ";
    #####:11488:            stream << result.getExpressionInMacro();
    #####:11489:            stream << '\n';
    #####:11490:        }
    #####:11491:    }
    #####:11492:    void printReconstructedExpression() const {
    #####:11493:        if (result.hasExpandedExpression()) {
    #####:11494:            stream << "with expansion:\n";
    #####:11495:            Colour colourGuard(Colour::ReconstructedExpression);
    #####:11496:            stream << Column(result.getExpandedExpression()).indent(2) << '\n';
    #####:11497:        }
    #####:11498:    }
    #####:11499:    void printMessage() const {
    #####:11500:        if (!messageLabel.empty())
    #####:11501:            stream << messageLabel << ':' << '\n';
    #####:11502:        for (auto const& msg : messages) {
        -:11503:            // If this assertion is a warning ignore any INFO messages
    #####:11504:            if (printInfoMessages || msg.type != ResultWas::Info)
    #####:11505:                stream << Column(msg.message).indent(2) << '\n';
        -:11506:        }
    #####:11507:    }
    #####:11508:    void printSourceInfo() const {
    #####:11509:        Colour colourGuard(Colour::FileName);
    #####:11510:        stream << result.getSourceInfo() << ": ";
    #####:11511:    }
        -:11512:
        -:11513:    std::ostream& stream;
        -:11514:    AssertionStats const& stats;
        -:11515:    AssertionResult const& result;
        -:11516:    Colour::Code colour;
        -:11517:    std::string passOrFail;
        -:11518:    std::string messageLabel;
        -:11519:    std::string message;
        -:11520:    std::vector<MessageInfo> messages;
        -:11521:    bool printInfoMessages;
        -:11522:};
        -:11523:
        3:11524:std::size_t makeRatio(std::size_t number, std::size_t total) {
       3*:11525:    std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;
       3*:11526:    return (ratio == 0 && number > 0) ? 1 : ratio;
        -:11527:}
        -:11528:
        1:11529:std::size_t& findMax(std::size_t& i, std::size_t& j, std::size_t& k) {
       1*:11530:    if (i > j && i > k)
    #####:11531:        return i;
        1:11532:    else if (j > k)
    #####:11533:        return j;
        -:11534:    else
        1:11535:        return k;
        -:11536:}
        -:11537:
        -:11538:struct ColumnInfo {
        -:11539:    enum Justification { Left, Right };
        -:11540:    std::string name;
        -:11541:    int width;
        -:11542:    Justification justification;
        -:11543:};
        -:11544:struct ColumnBreak {};
        -:11545:struct RowBreak {};
        -:11546:
        -:11547:class Duration {
        -:11548:    enum class Unit {
        -:11549:        Auto,
        -:11550:        Nanoseconds,
        -:11551:        Microseconds,
        -:11552:        Milliseconds,
        -:11553:        Seconds,
        -:11554:        Minutes
        -:11555:    };
        -:11556:    static const uint64_t s_nanosecondsInAMicrosecond = 1000;
        -:11557:    static const uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;
        -:11558:    static const uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;
        -:11559:    static const uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;
        -:11560:
        -:11561:    uint64_t m_inNanoseconds;
        -:11562:    Unit m_units;
        -:11563:
        -:11564:public:
    #####:11565:    explicit Duration(uint64_t inNanoseconds, Unit units = Unit::Auto)
    #####:11566:        : m_inNanoseconds(inNanoseconds),
    #####:11567:        m_units(units) {
    #####:11568:        if (m_units == Unit::Auto) {
    #####:11569:            if (m_inNanoseconds < s_nanosecondsInAMicrosecond)
    #####:11570:                m_units = Unit::Nanoseconds;
    #####:11571:            else if (m_inNanoseconds < s_nanosecondsInAMillisecond)
    #####:11572:                m_units = Unit::Microseconds;
    #####:11573:            else if (m_inNanoseconds < s_nanosecondsInASecond)
    #####:11574:                m_units = Unit::Milliseconds;
    #####:11575:            else if (m_inNanoseconds < s_nanosecondsInAMinute)
    #####:11576:                m_units = Unit::Seconds;
        -:11577:            else
    #####:11578:                m_units = Unit::Minutes;
        -:11579:        }
        -:11580:
    #####:11581:    }
        -:11582:
    #####:11583:    auto value() const -> double {
    #####:11584:        switch (m_units) {
    #####:11585:        case Unit::Microseconds:
    #####:11586:            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMicrosecond);
    #####:11587:        case Unit::Milliseconds:
    #####:11588:            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMillisecond);
    #####:11589:        case Unit::Seconds:
    #####:11590:            return m_inNanoseconds / static_cast<double>(s_nanosecondsInASecond);
    #####:11591:        case Unit::Minutes:
    #####:11592:            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMinute);
    #####:11593:        default:
    #####:11594:            return static_cast<double>(m_inNanoseconds);
        -:11595:        }
        -:11596:    }
    #####:11597:    auto unitsAsString() const -> std::string {
    #####:11598:        switch (m_units) {
    #####:11599:        case Unit::Nanoseconds:
    #####:11600:            return "ns";
    #####:11601:        case Unit::Microseconds:
    #####:11602:            return "µs";
    #####:11603:        case Unit::Milliseconds:
    #####:11604:            return "ms";
    #####:11605:        case Unit::Seconds:
    #####:11606:            return "s";
    #####:11607:        case Unit::Minutes:
    #####:11608:            return "m";
    #####:11609:        default:
    #####:11610:            return "** internal error **";
        -:11611:        }
        -:11612:
        -:11613:    }
    #####:11614:    friend auto operator << (std::ostream& os, Duration const& duration) -> std::ostream& {
    #####:11615:        return os << duration.value() << " " << duration.unitsAsString();
        -:11616:    }
        -:11617:};
        -:11618:} // end anon namespace
        -:11619:
        -:11620:class TablePrinter {
        -:11621:    std::ostream& m_os;
        -:11622:    std::vector<ColumnInfo> m_columnInfos;
        -:11623:    std::ostringstream m_oss;
        -:11624:    int m_currentColumn = -1;
        -:11625:    bool m_isOpen = false;
        -:11626:
        -:11627:public:
        1:11628:    TablePrinter( std::ostream& os, std::vector<ColumnInfo> columnInfos )
        1:11629:    :   m_os( os ),
        1:11630:        m_columnInfos( std::move( columnInfos ) ) {}
        -:11631:
    #####:11632:    auto columnInfos() const -> std::vector<ColumnInfo> const& {
    #####:11633:        return m_columnInfos;
        -:11634:    }
        -:11635:
    #####:11636:    void open() {
    #####:11637:        if (!m_isOpen) {
    #####:11638:            m_isOpen = true;
    #####:11639:            *this << RowBreak();
    #####:11640:            for (auto const& info : m_columnInfos)
    #####:11641:                *this << info.name << ColumnBreak();
    #####:11642:            *this << RowBreak();
    #####:11643:            m_os << Catch::getLineOfChars<'-'>() << "\n";
        -:11644:        }
    #####:11645:    }
       23:11646:    void close() {
       23:11647:        if (m_isOpen) {
    #####:11648:            *this << RowBreak();
    #####:11649:            m_os << std::endl;
    #####:11650:            m_isOpen = false;
        -:11651:        }
       23:11652:    }
        -:11653:
        -:11654:    template<typename T>
    #####:11655:    friend TablePrinter& operator << (TablePrinter& tp, T const& value) {
    #####:11656:        tp.m_oss << value;
    #####:11657:        return tp;
        -:11658:    }
------------------
_ZN5CatchlsINS_12_GLOBAL__N_18DurationEEERNS_12TablePrinterES4_RKT_:
    #####:11655:    friend TablePrinter& operator << (TablePrinter& tp, T const& value) {
    #####:11656:        tp.m_oss << value;
    #####:11657:        return tp;
        -:11658:    }
------------------
_ZN5CatchlsImEERNS_12TablePrinterES2_RKT_:
    #####:11655:    friend TablePrinter& operator << (TablePrinter& tp, T const& value) {
    #####:11656:        tp.m_oss << value;
    #####:11657:        return tp;
        -:11658:    }
------------------
_ZN5CatchlsINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEERNS_12TablePrinterES8_RKT_:
    #####:11655:    friend TablePrinter& operator << (TablePrinter& tp, T const& value) {
    #####:11656:        tp.m_oss << value;
    #####:11657:        return tp;
        -:11658:    }
------------------
        -:11659:
    #####:11660:    friend TablePrinter& operator << (TablePrinter& tp, ColumnBreak) {
    #####:11661:        auto colStr = tp.m_oss.str();
        -:11662:        // This takes account of utf8 encodings
    #####:11663:        auto strSize = Catch::StringRef(colStr).numberOfCharacters();
    #####:11664:        tp.m_oss.str("");
    #####:11665:        tp.open();
    #####:11666:        if (tp.m_currentColumn == static_cast<int>(tp.m_columnInfos.size() - 1)) {
    #####:11667:            tp.m_currentColumn = -1;
    #####:11668:            tp.m_os << "\n";
        -:11669:        }
    #####:11670:        tp.m_currentColumn++;
        -:11671:
    #####:11672:        auto colInfo = tp.m_columnInfos[tp.m_currentColumn];
    #####:11673:        auto padding = (strSize + 2 < static_cast<std::size_t>(colInfo.width))
    #####:11674:            ? std::string(colInfo.width - (strSize + 2), ' ')
    #####:11675:            : std::string();
    #####:11676:        if (colInfo.justification == ColumnInfo::Left)
    #####:11677:            tp.m_os << colStr << padding << " ";
        -:11678:        else
    #####:11679:            tp.m_os << padding << colStr << " ";
    #####:11680:        return tp;
    #####:11681:    }
        -:11682:
    #####:11683:    friend TablePrinter& operator << (TablePrinter& tp, RowBreak) {
    #####:11684:        if (tp.m_currentColumn > 0) {
    #####:11685:            tp.m_os << "\n";
    #####:11686:            tp.m_currentColumn = -1;
        -:11687:        }
    #####:11688:        return tp;
        -:11689:    }
        -:11690:};
        -:11691:
        1:11692:ConsoleReporter::ConsoleReporter(ReporterConfig const& config)
        -:11693:    : StreamingReporterBase(config),
        7:11694:    m_tablePrinter(new TablePrinter(config.stream(),
        -:11695:    {
        -:11696:        { "benchmark name", CATCH_CONFIG_CONSOLE_WIDTH - 32, ColumnInfo::Left },
        -:11697:        { "iters", 8, ColumnInfo::Right },
        -:11698:        { "elapsed ns", 14, ColumnInfo::Right },
        -:11699:        { "average", 14, ColumnInfo::Right }
        8:11700:    })) {}
        2:11701:ConsoleReporter::~ConsoleReporter() = default;
------------------
_ZN5Catch15ConsoleReporterD0Ev:
        1:11701:ConsoleReporter::~ConsoleReporter() = default;
------------------
_ZN5Catch15ConsoleReporterD2Ev:
        1:11701:ConsoleReporter::~ConsoleReporter() = default;
------------------
        -:11702:
    #####:11703:std::string ConsoleReporter::getDescription() {
    #####:11704:    return "Reports test results as plain lines of text";
        -:11705:}
        -:11706:
    #####:11707:void ConsoleReporter::noMatchingTestCases(std::string const& spec) {
    #####:11708:    stream << "No test cases matched '" << spec << '\'' << std::endl;
    #####:11709:}
        -:11710:
       41:11711:void ConsoleReporter::assertionStarting(AssertionInfo const&) {}
        -:11712:
    #####:11713:bool ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {
    #####:11714:    AssertionResult const& result = _assertionStats.assertionResult;
        -:11715:
    #####:11716:    bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();
        -:11717:
        -:11718:    // Drop out if result was successful but we're not printing them.
    #####:11719:    if (!includeResults && result.getResultType() != ResultWas::Warning)
    #####:11720:        return false;
        -:11721:
    #####:11722:    lazyPrint();
        -:11723:
    #####:11724:    ConsoleAssertionPrinter printer(stream, _assertionStats, includeResults);
    #####:11725:    printer.print();
    #####:11726:    stream << std::endl;
    #####:11727:    return true;
    #####:11728:}
        -:11729:
       19:11730:void ConsoleReporter::sectionStarting(SectionInfo const& _sectionInfo) {
       19:11731:    m_headerPrinted = false;
       19:11732:    StreamingReporterBase::sectionStarting(_sectionInfo);
       19:11733:}
       19:11734:void ConsoleReporter::sectionEnded(SectionStats const& _sectionStats) {
       19:11735:    m_tablePrinter->close();
       19:11736:    if (_sectionStats.missingAssertions) {
    #####:11737:        lazyPrint();
    #####:11738:        Colour colour(Colour::ResultError);
    #####:11739:        if (m_sectionStack.size() > 1)
    #####:11740:            stream << "\nNo assertions in section";
        -:11741:        else
    #####:11742:            stream << "\nNo assertions in test case";
    #####:11743:        stream << " '" << _sectionStats.sectionInfo.name << "'\n" << std::endl;
    #####:11744:    }
       19:11745:    if (m_config->showDurations() == ShowDurations::Always) {
    #####:11746:        stream << getFormattedDuration(_sectionStats.durationInSeconds) << " s: " << _sectionStats.sectionInfo.name << std::endl;
        -:11747:    }
       19:11748:    if (m_headerPrinted) {
    #####:11749:        m_headerPrinted = false;
        -:11750:    }
       19:11751:    StreamingReporterBase::sectionEnded(_sectionStats);
       19:11752:}
        -:11753:
    #####:11754:void ConsoleReporter::benchmarkStarting(BenchmarkInfo const& info) {
    #####:11755:    lazyPrintWithoutClosingBenchmarkTable();
        -:11756:
    #####:11757:    auto nameCol = Column( info.name ).width( static_cast<std::size_t>( m_tablePrinter->columnInfos()[0].width - 2 ) );
        -:11758:
    #####:11759:    bool firstLine = true;
    #####:11760:    for (auto line : nameCol) {
    #####:11761:        if (!firstLine)
    #####:11762:            (*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();
        -:11763:        else
    #####:11764:            firstLine = false;
        -:11765:
    #####:11766:        (*m_tablePrinter) << line << ColumnBreak();
    #####:11767:    }
    #####:11768:}
    #####:11769:void ConsoleReporter::benchmarkEnded(BenchmarkStats const& stats) {
    #####:11770:    Duration average(stats.elapsedTimeInNanoseconds / stats.iterations);
    #####:11771:    (*m_tablePrinter)
    #####:11772:        << stats.iterations << ColumnBreak()
    #####:11773:        << stats.elapsedTimeInNanoseconds << ColumnBreak()
    #####:11774:        << average << ColumnBreak();
    #####:11775:}
        -:11776:
        4:11777:void ConsoleReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {
        4:11778:    m_tablePrinter->close();
        4:11779:    StreamingReporterBase::testCaseEnded(_testCaseStats);
        4:11780:    m_headerPrinted = false;
        4:11781:}
        1:11782:void ConsoleReporter::testGroupEnded(TestGroupStats const& _testGroupStats) {
        1:11783:    if (currentGroupInfo.used) {
    #####:11784:        printSummaryDivider();
    #####:11785:        stream << "Summary for group '" << _testGroupStats.groupInfo.name << "':\n";
    #####:11786:        printTotals(_testGroupStats.totals);
    #####:11787:        stream << '\n' << std::endl;
        -:11788:    }
        1:11789:    StreamingReporterBase::testGroupEnded(_testGroupStats);
        1:11790:}
        1:11791:void ConsoleReporter::testRunEnded(TestRunStats const& _testRunStats) {
        1:11792:    printTotalsDivider(_testRunStats.totals);
        1:11793:    printTotals(_testRunStats.totals);
        1:11794:    stream << std::endl;
        1:11795:    StreamingReporterBase::testRunEnded(_testRunStats);
        1:11796:}
        -:11797:
    #####:11798:void ConsoleReporter::lazyPrint() {
        -:11799:
    #####:11800:    m_tablePrinter->close();
    #####:11801:    lazyPrintWithoutClosingBenchmarkTable();
    #####:11802:}
        -:11803:
    #####:11804:void ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() {
        -:11805:
    #####:11806:    if (!currentTestRunInfo.used)
    #####:11807:        lazyPrintRunInfo();
    #####:11808:    if (!currentGroupInfo.used)
    #####:11809:        lazyPrintGroupInfo();
        -:11810:
    #####:11811:    if (!m_headerPrinted) {
    #####:11812:        printTestCaseAndSectionHeader();
    #####:11813:        m_headerPrinted = true;
        -:11814:    }
    #####:11815:}
    #####:11816:void ConsoleReporter::lazyPrintRunInfo() {
    #####:11817:    stream << '\n' << getLineOfChars<'~'>() << '\n';
    #####:11818:    Colour colour(Colour::SecondaryText);
    #####:11819:    stream << currentTestRunInfo->name
    #####:11820:        << " is a Catch v" << libraryVersion() << " host application.\n"
    #####:11821:        << "Run with -? for options\n\n";
        -:11822:
    #####:11823:    if (m_config->rngSeed() != 0)
    #####:11824:        stream << "Randomness seeded to: " << m_config->rngSeed() << "\n\n";
        -:11825:
    #####:11826:    currentTestRunInfo.used = true;
    #####:11827:}
    #####:11828:void ConsoleReporter::lazyPrintGroupInfo() {
    #####:11829:    if (!currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1) {
    #####:11830:        printClosedHeader("Group: " + currentGroupInfo->name);
    #####:11831:        currentGroupInfo.used = true;
        -:11832:    }
    #####:11833:}
    #####:11834:void ConsoleReporter::printTestCaseAndSectionHeader() {
    #####:11835:    assert(!m_sectionStack.empty());
    #####:11836:    printOpenHeader(currentTestCaseInfo->name);
        -:11837:
    #####:11838:    if (m_sectionStack.size() > 1) {
    #####:11839:        Colour colourGuard(Colour::Headers);
        -:11840:
        -:11841:        auto
    #####:11842:            it = m_sectionStack.begin() + 1, // Skip first section (test case)
    #####:11843:            itEnd = m_sectionStack.end();
    #####:11844:        for (; it != itEnd; ++it)
    #####:11845:            printHeaderString(it->name, 2);
    #####:11846:    }
        -:11847:
    #####:11848:    SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;
        -:11849:
    #####:11850:    if (!lineInfo.empty()) {
    #####:11851:        stream << getLineOfChars<'-'>() << '\n';
    #####:11852:        Colour colourGuard(Colour::FileName);
    #####:11853:        stream << lineInfo << '\n';
    #####:11854:    }
    #####:11855:    stream << getLineOfChars<'.'>() << '\n' << std::endl;
    #####:11856:}
        -:11857:
    #####:11858:void ConsoleReporter::printClosedHeader(std::string const& _name) {
    #####:11859:    printOpenHeader(_name);
    #####:11860:    stream << getLineOfChars<'.'>() << '\n';
    #####:11861:}
    #####:11862:void ConsoleReporter::printOpenHeader(std::string const& _name) {
    #####:11863:    stream << getLineOfChars<'-'>() << '\n';
        -:11864:    {
    #####:11865:        Colour colourGuard(Colour::Headers);
    #####:11866:        printHeaderString(_name);
    #####:11867:    }
    #####:11868:}
        -:11869:
        -:11870:// if string has a : in first line will set indent to follow it on
        -:11871:// subsequent lines
    #####:11872:void ConsoleReporter::printHeaderString(std::string const& _string, std::size_t indent) {
    #####:11873:    std::size_t i = _string.find(": ");
    #####:11874:    if (i != std::string::npos)
    #####:11875:        i += 2;
        -:11876:    else
    #####:11877:        i = 0;
    #####:11878:    stream << Column(_string).indent(indent + i).initialIndent(indent) << '\n';
    #####:11879:}
        -:11880:
        -:11881:struct SummaryColumn {
        -:11882:
    #####:11883:    SummaryColumn( std::string _label, Colour::Code _colour )
    #####:11884:    :   label( std::move( _label ) ),
    #####:11885:        colour( _colour ) {}
    #####:11886:    SummaryColumn addRow( std::size_t count ) {
    #####:11887:        ReusableStringStream rss;
    #####:11888:        rss << count;
    #####:11889:        std::string row = rss.str();
    #####:11890:        for (auto& oldRow : rows) {
    #####:11891:            while (oldRow.size() < row.size())
    #####:11892:                oldRow = ' ' + oldRow;
    #####:11893:            while (oldRow.size() > row.size())
    #####:11894:                row = ' ' + row;
        -:11895:        }
    #####:11896:        rows.push_back(row);
    #####:11897:        return *this;
    #####:11898:    }
        -:11899:
        -:11900:    std::string label;
        -:11901:    Colour::Code colour;
        -:11902:    std::vector<std::string> rows;
        -:11903:
        -:11904:};
        -:11905:
        1:11906:void ConsoleReporter::printTotals( Totals const& totals ) {
        1:11907:    if (totals.testCases.total() == 0) {
    #####:11908:        stream << Colour(Colour::Warning) << "No tests ran\n";
       1*:11909:    } else if (totals.assertions.total() > 0 && totals.testCases.allPassed()) {
        1:11910:        stream << Colour(Colour::ResultSuccess) << "All tests passed";
        1:11911:        stream << " ("
        2:11912:            << pluralise(totals.assertions.passed, "assertion") << " in "
        2:11913:            << pluralise(totals.testCases.passed, "test case") << ')'
        1:11914:            << '\n';
        -:11915:    } else {
        -:11916:
    #####:11917:        std::vector<SummaryColumn> columns;
    #####:11918:        columns.push_back(SummaryColumn("", Colour::None)
    #####:11919:                          .addRow(totals.testCases.total())
    #####:11920:                          .addRow(totals.assertions.total()));
    #####:11921:        columns.push_back(SummaryColumn("passed", Colour::Success)
    #####:11922:                          .addRow(totals.testCases.passed)
    #####:11923:                          .addRow(totals.assertions.passed));
    #####:11924:        columns.push_back(SummaryColumn("failed", Colour::ResultError)
    #####:11925:                          .addRow(totals.testCases.failed)
    #####:11926:                          .addRow(totals.assertions.failed));
    #####:11927:        columns.push_back(SummaryColumn("failed as expected", Colour::ResultExpectedFailure)
    #####:11928:                          .addRow(totals.testCases.failedButOk)
    #####:11929:                          .addRow(totals.assertions.failedButOk));
        -:11930:
    #####:11931:        printSummaryRow("test cases", columns, 0);
    #####:11932:        printSummaryRow("assertions", columns, 1);
    #####:11933:    }
        1:11934:}
    #####:11935:void ConsoleReporter::printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row) {
    #####:11936:    for (auto col : cols) {
    #####:11937:        std::string value = col.rows[row];
    #####:11938:        if (col.label.empty()) {
    #####:11939:            stream << label << ": ";
    #####:11940:            if (value != "0")
    #####:11941:                stream << value;
        -:11942:            else
    #####:11943:                stream << Colour(Colour::Warning) << "- none -";
    #####:11944:        } else if (value != "0") {
    #####:11945:            stream << Colour(Colour::LightGrey) << " | ";
    #####:11946:            stream << Colour(col.colour)
    #####:11947:                << value << ' ' << col.label;
        -:11948:        }
    #####:11949:    }
    #####:11950:    stream << '\n';
    #####:11951:}
        -:11952:
        1:11953:void ConsoleReporter::printTotalsDivider(Totals const& totals) {
        1:11954:    if (totals.testCases.total() > 0) {
        1:11955:        std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());
        1:11956:        std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());
        1:11957:        std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());
        1:11958:        while (failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)
    #####:11959:            findMax(failedRatio, failedButOkRatio, passedRatio)++;
        2:11960:        while (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)
        1:11961:            findMax(failedRatio, failedButOkRatio, passedRatio)--;
        -:11962:
        1:11963:        stream << Colour(Colour::Error) << std::string(failedRatio, '=');
        1:11964:        stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, '=');
        1:11965:        if (totals.testCases.allPassed())
        1:11966:            stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, '=');
        -:11967:        else
    #####:11968:            stream << Colour(Colour::Success) << std::string(passedRatio, '=');
        -:11969:    } else {
    #####:11970:        stream << Colour(Colour::Warning) << std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, '=');
        -:11971:    }
        1:11972:    stream << '\n';
        1:11973:}
    #####:11974:void ConsoleReporter::printSummaryDivider() {
    #####:11975:    stream << getLineOfChars<'-'>() << '\n';
    #####:11976:}
        -:11977:
        -:11978:CATCH_REGISTER_REPORTER("console", ConsoleReporter)
        -:11979:
        -:11980:} // end namespace Catch
        -:11981:
        -:11982:#if defined(_MSC_VER)
        -:11983:#pragma warning(pop)
        -:11984:#endif
        -:11985:// end catch_reporter_console.cpp
        -:11986:// start catch_reporter_junit.cpp
        -:11987:
        -:11988:#include <assert.h>
        -:11989:#include <sstream>
        -:11990:#include <ctime>
        -:11991:#include <algorithm>
        -:11992:
        -:11993:namespace Catch {
        -:11994:
        -:11995:    namespace {
    #####:11996:        std::string getCurrentTimestamp() {
        -:11997:            // Beware, this is not reentrant because of backward compatibility issues
        -:11998:            // Also, UTC only, again because of backward compatibility (%z is C++11)
        -:11999:            time_t rawtime;
    #####:12000:            std::time(&rawtime);
    #####:12001:            auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");
        -:12002:
        -:12003:#ifdef _MSC_VER
        -:12004:            std::tm timeInfo = {};
        -:12005:            gmtime_s(&timeInfo, &rawtime);
        -:12006:#else
        -:12007:            std::tm* timeInfo;
    #####:12008:            timeInfo = std::gmtime(&rawtime);
        -:12009:#endif
        -:12010:
        -:12011:            char timeStamp[timeStampSize];
    #####:12012:            const char * const fmt = "%Y-%m-%dT%H:%M:%SZ";
        -:12013:
        -:12014:#ifdef _MSC_VER
        -:12015:            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
        -:12016:#else
    #####:12017:            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
        -:12018:#endif
    #####:12019:            return std::string(timeStamp);
        -:12020:        }
        -:12021:
    #####:12022:        std::string fileNameTag(const std::vector<std::string> &tags) {
    #####:12023:            auto it = std::find_if(begin(tags),
        -:12024:                                   end(tags),
    #####:12025:                                   [] (std::string const& tag) {return tag.front() == '#'; });
    #####:12026:            if (it != tags.end())
    #####:12027:                return it->substr(1);
    #####:12028:            return std::string();
        -:12029:        }
        -:12030:    } // anonymous namespace
        -:12031:
    #####:12032:    JunitReporter::JunitReporter( ReporterConfig const& _config )
        -:12033:        :   CumulativeReporterBase( _config ),
    #####:12034:            xml( _config.stream() )
        -:12035:        {
    #####:12036:            m_reporterPrefs.shouldRedirectStdOut = true;
    #####:12037:        }
        -:12038:
    #####:12039:    JunitReporter::~JunitReporter() {}
------------------
_ZN5Catch13JunitReporterD0Ev:
    #####:12039:    JunitReporter::~JunitReporter() {}
------------------
_ZN5Catch13JunitReporterD2Ev:
    #####:12039:    JunitReporter::~JunitReporter() {}
------------------
        -:12040:
    #####:12041:    std::string JunitReporter::getDescription() {
    #####:12042:        return "Reports test results in an XML format that looks like Ant's junitreport target";
        -:12043:    }
        -:12044:
    #####:12045:    void JunitReporter::noMatchingTestCases( std::string const& /*spec*/ ) {}
        -:12046:
    #####:12047:    void JunitReporter::testRunStarting( TestRunInfo const& runInfo )  {
    #####:12048:        CumulativeReporterBase::testRunStarting( runInfo );
    #####:12049:        xml.startElement( "testsuites" );
    #####:12050:    }
        -:12051:
    #####:12052:    void JunitReporter::testGroupStarting( GroupInfo const& groupInfo ) {
    #####:12053:        suiteTimer.start();
    #####:12054:        stdOutForSuite.clear();
    #####:12055:        stdErrForSuite.clear();
    #####:12056:        unexpectedExceptions = 0;
    #####:12057:        CumulativeReporterBase::testGroupStarting( groupInfo );
    #####:12058:    }
        -:12059:
    #####:12060:    void JunitReporter::testCaseStarting( TestCaseInfo const& testCaseInfo ) {
    #####:12061:        m_okToFail = testCaseInfo.okToFail();
    #####:12062:    }
        -:12063:
    #####:12064:    bool JunitReporter::assertionEnded( AssertionStats const& assertionStats ) {
    #####:12065:        if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException && !m_okToFail )
    #####:12066:            unexpectedExceptions++;
    #####:12067:        return CumulativeReporterBase::assertionEnded( assertionStats );
        -:12068:    }
        -:12069:
    #####:12070:    void JunitReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
    #####:12071:        stdOutForSuite += testCaseStats.stdOut;
    #####:12072:        stdErrForSuite += testCaseStats.stdErr;
    #####:12073:        CumulativeReporterBase::testCaseEnded( testCaseStats );
    #####:12074:    }
        -:12075:
    #####:12076:    void JunitReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
    #####:12077:        double suiteTime = suiteTimer.getElapsedSeconds();
    #####:12078:        CumulativeReporterBase::testGroupEnded( testGroupStats );
    #####:12079:        writeGroup( *m_testGroups.back(), suiteTime );
    #####:12080:    }
        -:12081:
    #####:12082:    void JunitReporter::testRunEndedCumulative() {
    #####:12083:        xml.endElement();
    #####:12084:    }
        -:12085:
    #####:12086:    void JunitReporter::writeGroup( TestGroupNode const& groupNode, double suiteTime ) {
    #####:12087:        XmlWriter::ScopedElement e = xml.scopedElement( "testsuite" );
    #####:12088:        TestGroupStats const& stats = groupNode.value;
    #####:12089:        xml.writeAttribute( "name", stats.groupInfo.name );
    #####:12090:        xml.writeAttribute( "errors", unexpectedExceptions );
    #####:12091:        xml.writeAttribute( "failures", stats.totals.assertions.failed-unexpectedExceptions );
    #####:12092:        xml.writeAttribute( "tests", stats.totals.assertions.total() );
    #####:12093:        xml.writeAttribute( "hostname", "tbd" ); // !TBD
    #####:12094:        if( m_config->showDurations() == ShowDurations::Never )
    #####:12095:            xml.writeAttribute( "time", "" );
        -:12096:        else
    #####:12097:            xml.writeAttribute( "time", suiteTime );
    #####:12098:        xml.writeAttribute( "timestamp", getCurrentTimestamp() );
        -:12099:
        -:12100:        // Write test cases
    #####:12101:        for( auto const& child : groupNode.children )
    #####:12102:            writeTestCase( *child );
        -:12103:
    #####:12104:        xml.scopedElement( "system-out" ).writeText( trim( stdOutForSuite ), false );
    #####:12105:        xml.scopedElement( "system-err" ).writeText( trim( stdErrForSuite ), false );
    #####:12106:    }
        -:12107:
    #####:12108:    void JunitReporter::writeTestCase( TestCaseNode const& testCaseNode ) {
    #####:12109:        TestCaseStats const& stats = testCaseNode.value;
        -:12110:
        -:12111:        // All test cases have exactly one section - which represents the
        -:12112:        // test case itself. That section may have 0-n nested sections
    #####:12113:        assert( testCaseNode.children.size() == 1 );
    #####:12114:        SectionNode const& rootSection = *testCaseNode.children.front();
        -:12115:
    #####:12116:        std::string className = stats.testInfo.className;
        -:12117:
    #####:12118:        if( className.empty() ) {
    #####:12119:            className = fileNameTag(stats.testInfo.tags);
    #####:12120:            if ( className.empty() )
    #####:12121:                className = "global";
        -:12122:        }
        -:12123:
    #####:12124:        if ( !m_config->name().empty() )
    #####:12125:            className = m_config->name() + "." + className;
        -:12126:
    #####:12127:        writeSection( className, "", rootSection );
    #####:12128:    }
        -:12129:
    #####:12130:    void JunitReporter::writeSection(  std::string const& className,
        -:12131:                        std::string const& rootName,
        -:12132:                        SectionNode const& sectionNode ) {
    #####:12133:        std::string name = trim( sectionNode.stats.sectionInfo.name );
    #####:12134:        if( !rootName.empty() )
    #####:12135:            name = rootName + '/' + name;
        -:12136:
    #####:12137:        if( !sectionNode.assertions.empty() ||
    #####:12138:            !sectionNode.stdOut.empty() ||
    #####:12139:            !sectionNode.stdErr.empty() ) {
    #####:12140:            XmlWriter::ScopedElement e = xml.scopedElement( "testcase" );
    #####:12141:            if( className.empty() ) {
    #####:12142:                xml.writeAttribute( "classname", name );
    #####:12143:                xml.writeAttribute( "name", "root" );
        -:12144:            }
        -:12145:            else {
    #####:12146:                xml.writeAttribute( "classname", className );
    #####:12147:                xml.writeAttribute( "name", name );
        -:12148:            }
    #####:12149:            xml.writeAttribute( "time", ::Catch::Detail::stringify( sectionNode.stats.durationInSeconds ) );
        -:12150:
    #####:12151:            writeAssertions( sectionNode );
        -:12152:
    #####:12153:            if( !sectionNode.stdOut.empty() )
    #####:12154:                xml.scopedElement( "system-out" ).writeText( trim( sectionNode.stdOut ), false );
    #####:12155:            if( !sectionNode.stdErr.empty() )
    #####:12156:                xml.scopedElement( "system-err" ).writeText( trim( sectionNode.stdErr ), false );
    #####:12157:        }
    #####:12158:        for( auto const& childNode : sectionNode.childSections )
    #####:12159:            if( className.empty() )
    #####:12160:                writeSection( name, "", *childNode );
        -:12161:            else
    #####:12162:                writeSection( className, name, *childNode );
    #####:12163:    }
        -:12164:
    #####:12165:    void JunitReporter::writeAssertions( SectionNode const& sectionNode ) {
    #####:12166:        for( auto const& assertion : sectionNode.assertions )
    #####:12167:            writeAssertion( assertion );
    #####:12168:    }
        -:12169:
    #####:12170:    void JunitReporter::writeAssertion( AssertionStats const& stats ) {
    #####:12171:        AssertionResult const& result = stats.assertionResult;
    #####:12172:        if( !result.isOk() ) {
    #####:12173:            std::string elementName;
    #####:12174:            switch( result.getResultType() ) {
    #####:12175:                case ResultWas::ThrewException:
        -:12176:                case ResultWas::FatalErrorCondition:
    #####:12177:                    elementName = "error";
    #####:12178:                    break;
    #####:12179:                case ResultWas::ExplicitFailure:
    #####:12180:                    elementName = "failure";
    #####:12181:                    break;
    #####:12182:                case ResultWas::ExpressionFailed:
    #####:12183:                    elementName = "failure";
    #####:12184:                    break;
    #####:12185:                case ResultWas::DidntThrowException:
    #####:12186:                    elementName = "failure";
    #####:12187:                    break;
        -:12188:
        -:12189:                // We should never see these here:
    #####:12190:                case ResultWas::Info:
        -:12191:                case ResultWas::Warning:
        -:12192:                case ResultWas::Ok:
        -:12193:                case ResultWas::Unknown:
        -:12194:                case ResultWas::FailureBit:
        -:12195:                case ResultWas::Exception:
    #####:12196:                    elementName = "internalError";
    #####:12197:                    break;
        -:12198:            }
        -:12199:
    #####:12200:            XmlWriter::ScopedElement e = xml.scopedElement( elementName );
        -:12201:
    #####:12202:            xml.writeAttribute( "message", result.getExpandedExpression() );
    #####:12203:            xml.writeAttribute( "type", result.getTestMacroName() );
        -:12204:
    #####:12205:            ReusableStringStream rss;
    #####:12206:            if( !result.getMessage().empty() )
    #####:12207:                rss << result.getMessage() << '\n';
    #####:12208:            for( auto const& msg : stats.infoMessages )
    #####:12209:                if( msg.type == ResultWas::Info )
    #####:12210:                    rss << msg.message << '\n';
        -:12211:
    #####:12212:            rss << "at " << result.getSourceInfo();
    #####:12213:            xml.writeText( rss.str(), false );
    #####:12214:        }
    #####:12215:    }
        -:12216:
        -:12217:    CATCH_REGISTER_REPORTER( "junit", JunitReporter )
        -:12218:
        -:12219:} // end namespace Catch
        -:12220:// end catch_reporter_junit.cpp
        -:12221:// start catch_reporter_multi.cpp
        -:12222:
        -:12223:namespace Catch {
        -:12224:
    #####:12225:    void MultipleReporters::add( IStreamingReporterPtr&& reporter ) {
    #####:12226:        m_reporters.push_back( std::move( reporter ) );
    #####:12227:    }
        -:12228:
    #####:12229:    ReporterPreferences MultipleReporters::getPreferences() const {
    #####:12230:        return m_reporters[0]->getPreferences();
        -:12231:    }
        -:12232:
    #####:12233:    std::set<Verbosity> MultipleReporters::getSupportedVerbosities() {
    #####:12234:        return std::set<Verbosity>{ };
        -:12235:    }
        -:12236:
    #####:12237:    void MultipleReporters::noMatchingTestCases( std::string const& spec ) {
    #####:12238:        for( auto const& reporter : m_reporters )
    #####:12239:            reporter->noMatchingTestCases( spec );
    #####:12240:    }
        -:12241:
    #####:12242:    void MultipleReporters::benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) {
    #####:12243:        for( auto const& reporter : m_reporters )
    #####:12244:            reporter->benchmarkStarting( benchmarkInfo );
    #####:12245:    }
    #####:12246:    void MultipleReporters::benchmarkEnded( BenchmarkStats const& benchmarkStats ) {
    #####:12247:        for( auto const& reporter : m_reporters )
    #####:12248:            reporter->benchmarkEnded( benchmarkStats );
    #####:12249:    }
        -:12250:
    #####:12251:    void MultipleReporters::testRunStarting( TestRunInfo const& testRunInfo ) {
    #####:12252:        for( auto const& reporter : m_reporters )
    #####:12253:            reporter->testRunStarting( testRunInfo );
    #####:12254:    }
        -:12255:
    #####:12256:    void MultipleReporters::testGroupStarting( GroupInfo const& groupInfo ) {
    #####:12257:        for( auto const& reporter : m_reporters )
    #####:12258:            reporter->testGroupStarting( groupInfo );
    #####:12259:    }
        -:12260:
    #####:12261:    void MultipleReporters::testCaseStarting( TestCaseInfo const& testInfo ) {
    #####:12262:        for( auto const& reporter : m_reporters )
    #####:12263:            reporter->testCaseStarting( testInfo );
    #####:12264:    }
        -:12265:
    #####:12266:    void MultipleReporters::sectionStarting( SectionInfo const& sectionInfo ) {
    #####:12267:        for( auto const& reporter : m_reporters )
    #####:12268:            reporter->sectionStarting( sectionInfo );
    #####:12269:    }
        -:12270:
    #####:12271:    void MultipleReporters::assertionStarting( AssertionInfo const& assertionInfo ) {
    #####:12272:        for( auto const& reporter : m_reporters )
    #####:12273:            reporter->assertionStarting( assertionInfo );
    #####:12274:    }
        -:12275:
        -:12276:    // The return value indicates if the messages buffer should be cleared:
    #####:12277:    bool MultipleReporters::assertionEnded( AssertionStats const& assertionStats ) {
    #####:12278:        bool clearBuffer = false;
    #####:12279:        for( auto const& reporter : m_reporters )
    #####:12280:            clearBuffer |= reporter->assertionEnded( assertionStats );
    #####:12281:        return clearBuffer;
        -:12282:    }
        -:12283:
    #####:12284:    void MultipleReporters::sectionEnded( SectionStats const& sectionStats ) {
    #####:12285:        for( auto const& reporter : m_reporters )
    #####:12286:            reporter->sectionEnded( sectionStats );
    #####:12287:    }
        -:12288:
    #####:12289:    void MultipleReporters::testCaseEnded( TestCaseStats const& testCaseStats ) {
    #####:12290:        for( auto const& reporter : m_reporters )
    #####:12291:            reporter->testCaseEnded( testCaseStats );
    #####:12292:    }
        -:12293:
    #####:12294:    void MultipleReporters::testGroupEnded( TestGroupStats const& testGroupStats ) {
    #####:12295:        for( auto const& reporter : m_reporters )
    #####:12296:            reporter->testGroupEnded( testGroupStats );
    #####:12297:    }
        -:12298:
    #####:12299:    void MultipleReporters::testRunEnded( TestRunStats const& testRunStats ) {
    #####:12300:        for( auto const& reporter : m_reporters )
    #####:12301:            reporter->testRunEnded( testRunStats );
    #####:12302:    }
        -:12303:
    #####:12304:    void MultipleReporters::skipTest( TestCaseInfo const& testInfo ) {
    #####:12305:        for( auto const& reporter : m_reporters )
    #####:12306:            reporter->skipTest( testInfo );
    #####:12307:    }
        -:12308:
    #####:12309:    bool MultipleReporters::isMulti() const {
    #####:12310:        return true;
        -:12311:    }
        -:12312:
        -:12313:} // end namespace Catch
        -:12314:// end catch_reporter_multi.cpp
        -:12315:// start catch_reporter_xml.cpp
        -:12316:
        -:12317:#if defined(_MSC_VER)
        -:12318:#pragma warning(push)
        -:12319:#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
        -:12320:                              // Note that 4062 (not all labels are handled
        -:12321:                              // and default is missing) is enabled
        -:12322:#endif
        -:12323:
        -:12324:namespace Catch {
    #####:12325:    XmlReporter::XmlReporter( ReporterConfig const& _config )
        -:12326:    :   StreamingReporterBase( _config ),
    #####:12327:        m_xml(_config.stream())
        -:12328:    {
    #####:12329:        m_reporterPrefs.shouldRedirectStdOut = true;
    #####:12330:    }
        -:12331:
    #####:12332:    XmlReporter::~XmlReporter() = default;
------------------
_ZN5Catch11XmlReporterD0Ev:
    #####:12332:    XmlReporter::~XmlReporter() = default;
------------------
_ZN5Catch11XmlReporterD2Ev:
    #####:12332:    XmlReporter::~XmlReporter() = default;
------------------
        -:12333:
    #####:12334:    std::string XmlReporter::getDescription() {
    #####:12335:        return "Reports test results as an XML document";
        -:12336:    }
        -:12337:
    #####:12338:    std::string XmlReporter::getStylesheetRef() const {
    #####:12339:        return std::string();
        -:12340:    }
        -:12341:
    #####:12342:    void XmlReporter::writeSourceInfo( SourceLineInfo const& sourceInfo ) {
        -:12343:        m_xml
    #####:12344:            .writeAttribute( "filename", sourceInfo.file )
    #####:12345:            .writeAttribute( "line", sourceInfo.line );
    #####:12346:    }
        -:12347:
    #####:12348:    void XmlReporter::noMatchingTestCases( std::string const& s ) {
    #####:12349:        StreamingReporterBase::noMatchingTestCases( s );
    #####:12350:    }
        -:12351:
    #####:12352:    void XmlReporter::testRunStarting( TestRunInfo const& testInfo ) {
    #####:12353:        StreamingReporterBase::testRunStarting( testInfo );
    #####:12354:        std::string stylesheetRef = getStylesheetRef();
    #####:12355:        if( !stylesheetRef.empty() )
    #####:12356:            m_xml.writeStylesheetRef( stylesheetRef );
    #####:12357:        m_xml.startElement( "Catch" );
    #####:12358:        if( !m_config->name().empty() )
    #####:12359:            m_xml.writeAttribute( "name", m_config->name() );
    #####:12360:    }
        -:12361:
    #####:12362:    void XmlReporter::testGroupStarting( GroupInfo const& groupInfo ) {
    #####:12363:        StreamingReporterBase::testGroupStarting( groupInfo );
    #####:12364:        m_xml.startElement( "Group" )
    #####:12365:            .writeAttribute( "name", groupInfo.name );
    #####:12366:    }
        -:12367:
    #####:12368:    void XmlReporter::testCaseStarting( TestCaseInfo const& testInfo ) {
    #####:12369:        StreamingReporterBase::testCaseStarting(testInfo);
    #####:12370:        m_xml.startElement( "TestCase" )
    #####:12371:            .writeAttribute( "name", trim( testInfo.name ) )
    #####:12372:            .writeAttribute( "description", testInfo.description )
    #####:12373:            .writeAttribute( "tags", testInfo.tagsAsString() );
        -:12374:
    #####:12375:        writeSourceInfo( testInfo.lineInfo );
        -:12376:
    #####:12377:        if ( m_config->showDurations() == ShowDurations::Always )
    #####:12378:            m_testCaseTimer.start();
    #####:12379:        m_xml.ensureTagClosed();
    #####:12380:    }
        -:12381:
    #####:12382:    void XmlReporter::sectionStarting( SectionInfo const& sectionInfo ) {
    #####:12383:        StreamingReporterBase::sectionStarting( sectionInfo );
    #####:12384:        if( m_sectionDepth++ > 0 ) {
    #####:12385:            m_xml.startElement( "Section" )
    #####:12386:                .writeAttribute( "name", trim( sectionInfo.name ) )
    #####:12387:                .writeAttribute( "description", sectionInfo.description );
    #####:12388:            writeSourceInfo( sectionInfo.lineInfo );
    #####:12389:            m_xml.ensureTagClosed();
        -:12390:        }
    #####:12391:    }
        -:12392:
    #####:12393:    void XmlReporter::assertionStarting( AssertionInfo const& ) { }
        -:12394:
    #####:12395:    bool XmlReporter::assertionEnded( AssertionStats const& assertionStats ) {
        -:12396:
    #####:12397:        AssertionResult const& result = assertionStats.assertionResult;
        -:12398:
    #####:12399:        bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();
        -:12400:
    #####:12401:        if( includeResults || result.getResultType() == ResultWas::Warning ) {
        -:12402:            // Print any info messages in <Info> tags.
    #####:12403:            for( auto const& msg : assertionStats.infoMessages ) {
    #####:12404:                if( msg.type == ResultWas::Info && includeResults ) {
    #####:12405:                    m_xml.scopedElement( "Info" )
    #####:12406:                            .writeText( msg.message );
    #####:12407:                } else if ( msg.type == ResultWas::Warning ) {
    #####:12408:                    m_xml.scopedElement( "Warning" )
    #####:12409:                            .writeText( msg.message );
        -:12410:                }
        -:12411:            }
        -:12412:        }
        -:12413:
        -:12414:        // Drop out if result was successful but we're not printing them.
    #####:12415:        if( !includeResults && result.getResultType() != ResultWas::Warning )
    #####:12416:            return true;
        -:12417:
        -:12418:        // Print the expression if there is one.
    #####:12419:        if( result.hasExpression() ) {
    #####:12420:            m_xml.startElement( "Expression" )
    #####:12421:                .writeAttribute( "success", result.succeeded() )
    #####:12422:                .writeAttribute( "type", result.getTestMacroName() );
        -:12423:
    #####:12424:            writeSourceInfo( result.getSourceInfo() );
        -:12425:
    #####:12426:            m_xml.scopedElement( "Original" )
    #####:12427:                .writeText( result.getExpression() );
    #####:12428:            m_xml.scopedElement( "Expanded" )
    #####:12429:                .writeText( result.getExpandedExpression() );
        -:12430:        }
        -:12431:
        -:12432:        // And... Print a result applicable to each result type.
    #####:12433:        switch( result.getResultType() ) {
    #####:12434:            case ResultWas::ThrewException:
    #####:12435:                m_xml.startElement( "Exception" );
    #####:12436:                writeSourceInfo( result.getSourceInfo() );
    #####:12437:                m_xml.writeText( result.getMessage() );
    #####:12438:                m_xml.endElement();
    #####:12439:                break;
    #####:12440:            case ResultWas::FatalErrorCondition:
    #####:12441:                m_xml.startElement( "FatalErrorCondition" );
    #####:12442:                writeSourceInfo( result.getSourceInfo() );
    #####:12443:                m_xml.writeText( result.getMessage() );
    #####:12444:                m_xml.endElement();
    #####:12445:                break;
    #####:12446:            case ResultWas::Info:
    #####:12447:                m_xml.scopedElement( "Info" )
    #####:12448:                    .writeText( result.getMessage() );
    #####:12449:                break;
    #####:12450:            case ResultWas::Warning:
        -:12451:                // Warning will already have been written
    #####:12452:                break;
    #####:12453:            case ResultWas::ExplicitFailure:
    #####:12454:                m_xml.startElement( "Failure" );
    #####:12455:                writeSourceInfo( result.getSourceInfo() );
    #####:12456:                m_xml.writeText( result.getMessage() );
    #####:12457:                m_xml.endElement();
    #####:12458:                break;
    #####:12459:            default:
    #####:12460:                break;
        -:12461:        }
        -:12462:
    #####:12463:        if( result.hasExpression() )
    #####:12464:            m_xml.endElement();
        -:12465:
    #####:12466:        return true;
        -:12467:    }
        -:12468:
    #####:12469:    void XmlReporter::sectionEnded( SectionStats const& sectionStats ) {
    #####:12470:        StreamingReporterBase::sectionEnded( sectionStats );
    #####:12471:        if( --m_sectionDepth > 0 ) {
    #####:12472:            XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResults" );
    #####:12473:            e.writeAttribute( "successes", sectionStats.assertions.passed );
    #####:12474:            e.writeAttribute( "failures", sectionStats.assertions.failed );
    #####:12475:            e.writeAttribute( "expectedFailures", sectionStats.assertions.failedButOk );
        -:12476:
    #####:12477:            if ( m_config->showDurations() == ShowDurations::Always )
    #####:12478:                e.writeAttribute( "durationInSeconds", sectionStats.durationInSeconds );
        -:12479:
    #####:12480:            m_xml.endElement();
    #####:12481:        }
    #####:12482:    }
        -:12483:
    #####:12484:    void XmlReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
    #####:12485:        StreamingReporterBase::testCaseEnded( testCaseStats );
    #####:12486:        XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResult" );
    #####:12487:        e.writeAttribute( "success", testCaseStats.totals.assertions.allOk() );
        -:12488:
    #####:12489:        if ( m_config->showDurations() == ShowDurations::Always )
    #####:12490:            e.writeAttribute( "durationInSeconds", m_testCaseTimer.getElapsedSeconds() );
        -:12491:
    #####:12492:        if( !testCaseStats.stdOut.empty() )
    #####:12493:            m_xml.scopedElement( "StdOut" ).writeText( trim( testCaseStats.stdOut ), false );
    #####:12494:        if( !testCaseStats.stdErr.empty() )
    #####:12495:            m_xml.scopedElement( "StdErr" ).writeText( trim( testCaseStats.stdErr ), false );
        -:12496:
    #####:12497:        m_xml.endElement();
    #####:12498:    }
        -:12499:
    #####:12500:    void XmlReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
    #####:12501:        StreamingReporterBase::testGroupEnded( testGroupStats );
        -:12502:        // TODO: Check testGroupStats.aborting and act accordingly.
    #####:12503:        m_xml.scopedElement( "OverallResults" )
    #####:12504:            .writeAttribute( "successes", testGroupStats.totals.assertions.passed )
    #####:12505:            .writeAttribute( "failures", testGroupStats.totals.assertions.failed )
    #####:12506:            .writeAttribute( "expectedFailures", testGroupStats.totals.assertions.failedButOk );
    #####:12507:        m_xml.endElement();
    #####:12508:    }
        -:12509:
    #####:12510:    void XmlReporter::testRunEnded( TestRunStats const& testRunStats ) {
    #####:12511:        StreamingReporterBase::testRunEnded( testRunStats );
    #####:12512:        m_xml.scopedElement( "OverallResults" )
    #####:12513:            .writeAttribute( "successes", testRunStats.totals.assertions.passed )
    #####:12514:            .writeAttribute( "failures", testRunStats.totals.assertions.failed )
    #####:12515:            .writeAttribute( "expectedFailures", testRunStats.totals.assertions.failedButOk );
    #####:12516:        m_xml.endElement();
    #####:12517:    }
        -:12518:
        -:12519:    CATCH_REGISTER_REPORTER( "xml", XmlReporter )
        -:12520:
        -:12521:} // end namespace Catch
        -:12522:
        -:12523:#if defined(_MSC_VER)
        -:12524:#pragma warning(pop)
        -:12525:#endif
        -:12526:// end catch_reporter_xml.cpp
        -:12527:
        -:12528:namespace Catch {
        -:12529:    LeakDetector leakDetector;
        -:12530:}
        -:12531:
        -:12532:#ifdef __clang__
        -:12533:#pragma clang diagnostic pop
        -:12534:#endif
        -:12535:
        -:12536:// end catch_impl.hpp
        -:12537:#endif
        -:12538:
        -:12539:#ifdef CATCH_CONFIG_MAIN
        -:12540:// start catch_default_main.hpp
        -:12541:
        -:12542:#ifndef __OBJC__
        -:12543:
        -:12544:#if defined(CATCH_CONFIG_WCHAR) && defined(WIN32) && defined(_UNICODE) && !defined(DO_NOT_USE_WMAIN)
        -:12545:// Standard C/C++ Win32 Unicode wmain entry point
        -:12546:extern "C" int wmain (int argc, wchar_t * argv[], wchar_t * []) {
        -:12547:#else
        -:12548:// Standard C/C++ main entry point
        1:12549:int main (int argc, char * argv[]) {
        -:12550:#endif
        -:12551:
        1:12552:    return Catch::Session().run( argc, argv );
        -:12553:}
        -:12554:
        -:12555:#else // __OBJC__
        -:12556:
        -:12557:// Objective-C entry point
        -:12558:int main (int argc, char * const argv[]) {
        -:12559:#if !CATCH_ARC_ENABLED
        -:12560:    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
        -:12561:#endif
        -:12562:
        -:12563:    Catch::registerTestMethods();
        -:12564:    int result = Catch::Session().run( argc, (char**)argv );
        -:12565:
        -:12566:#if !CATCH_ARC_ENABLED
        -:12567:    [pool drain];
        -:12568:#endif
        -:12569:
        -:12570:    return result;
        -:12571:}
        -:12572:
        -:12573:#endif // __OBJC__
        -:12574:
        -:12575:// end catch_default_main.hpp
        -:12576:#endif
        -:12577:
        -:12578:#if !defined(CATCH_CONFIG_IMPL_ONLY)
        -:12579:
        -:12580:#ifdef CLARA_CONFIG_MAIN_NOT_DEFINED
        -:12581:#  undef CLARA_CONFIG_MAIN
        -:12582:#endif
        -:12583:
        -:12584:#if !defined(CATCH_CONFIG_DISABLE)
        -:12585://////
        -:12586:// If this config identifier is defined then all CATCH macros are prefixed with CATCH_
        -:12587:#ifdef CATCH_CONFIG_PREFIX_ALL
        -:12588:
        -:12589:#define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -:12590:#define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
        -:12591:
        -:12592:#define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "CATCH_REQUIRE_THROWS", Catch::ResultDisposition::Normal, "", __VA_ARGS__ )
        -:12593:#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
        -:12594:#define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
        -:12595:#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -:12596:#define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
        -:12597:#endif// CATCH_CONFIG_DISABLE_MATCHERS
        -:12598:#define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -:12599:
        -:12600:#define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:12601:#define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
        -:12602:#define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CATCH_CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:12603:#define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CATCH_CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:12604:#define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
        -:12605:
        -:12606:#define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CATCH_CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, "", __VA_ARGS__ )
        -:12607:#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
        -:12608:#define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -:12609:#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -:12610:#define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -:12611:#endif // CATCH_CONFIG_DISABLE_MATCHERS
        -:12612:#define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:12613:
        -:12614:#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -:12615:#define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
        -:12616:
        -:12617:#define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
        -:12618:#endif // CATCH_CONFIG_DISABLE_MATCHERS
        -:12619:
        -:12620:#define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( "CATCH_INFO", msg )
        -:12621:#define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( "CATCH_WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
        -:12622:#define CATCH_CAPTURE( msg ) INTERNAL_CATCH_INFO( "CATCH_CAPTURE", #msg " := " << ::Catch::Detail::stringify(msg) )
        -:12623:
        -:12624:#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
        -:12625:#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -:12626:#define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
        -:12627:#define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
        -:12628:#define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
        -:12629:#define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -:12630:#define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:12631:#define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( "CATCH_SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:12632:
        -:12633:#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
        -:12634:
        -:12635:// "BDD-style" convenience wrappers
        -:12636:#define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: " __VA_ARGS__ )
        -:12637:#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
        -:12638:#define CATCH_GIVEN( desc )    CATCH_SECTION( std::string( "Given: ") + desc )
        -:12639:#define CATCH_WHEN( desc )     CATCH_SECTION( std::string( " When: ") + desc )
        -:12640:#define CATCH_AND_WHEN( desc ) CATCH_SECTION( std::string( "  And: ") + desc )
        -:12641:#define CATCH_THEN( desc )     CATCH_SECTION( std::string( " Then: ") + desc )
        -:12642:#define CATCH_AND_THEN( desc ) CATCH_SECTION( std::string( "  And: ") + desc )
        -:12643:
        -:12644:// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
        -:12645:#else
        -:12646:
        -:12647:#define REQUIRE( ... ) INTERNAL_CATCH_TEST( "REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__  )
        -:12648:#define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
        -:12649:
        -:12650:#define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -:12651:#define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
        -:12652:#define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
        -:12653:#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -:12654:#define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
        -:12655:#endif // CATCH_CONFIG_DISABLE_MATCHERS
        -:12656:#define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -:12657:
        -:12658:#define CHECK( ... ) INTERNAL_CATCH_TEST( "CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:12659:#define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
        -:12660:#define CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:12661:#define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:12662:#define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
        -:12663:
        -:12664:#define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:12665:#define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
        -:12666:#define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -:12667:#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -:12668:#define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -:12669:#endif // CATCH_CONFIG_DISABLE_MATCHERS
        -:12670:#define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:12671:
        -:12672:#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -:12673:#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
        -:12674:
        -:12675:#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
        -:12676:#endif // CATCH_CONFIG_DISABLE_MATCHERS
        -:12677:
        -:12678:#define INFO( msg ) INTERNAL_CATCH_INFO( "INFO", msg )
        -:12679:#define WARN( msg ) INTERNAL_CATCH_MSG( "WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
        -:12680:#define CAPTURE( msg ) INTERNAL_CATCH_INFO( "CAPTURE", #msg " := " << ::Catch::Detail::stringify(msg) )
        -:12681:
        -:12682:#define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
        -:12683:#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -:12684:#define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
        -:12685:#define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
        -:12686:#define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
        -:12687:#define FAIL( ... ) INTERNAL_CATCH_MSG( "FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -:12688:#define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:12689:#define SUCCEED( ... ) INTERNAL_CATCH_MSG( "SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:12690:#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
        -:12691:
        -:12692:#endif
        -:12693:
        -:12694:#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )
        -:12695:
        -:12696:// "BDD-style" convenience wrappers
        -:12697:#define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )
        -:12698:#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
        -:12699:
        -:12700:#define GIVEN( desc )    SECTION( std::string("   Given: ") + desc )
        -:12701:#define WHEN( desc )     SECTION( std::string("    When: ") + desc )
        -:12702:#define AND_WHEN( desc ) SECTION( std::string("And when: ") + desc )
        -:12703:#define THEN( desc )     SECTION( std::string("    Then: ") + desc )
        -:12704:#define AND_THEN( desc ) SECTION( std::string("     And: ") + desc )
        -:12705:
        -:12706:using Catch::Detail::Approx;
        -:12707:
        -:12708:#else
        -:12709://////
        -:12710:// If this config identifier is defined then all CATCH macros are prefixed with CATCH_
        -:12711:#ifdef CATCH_CONFIG_PREFIX_ALL
        -:12712:
        -:12713:#define CATCH_REQUIRE( ... )        (void)(0)
        -:12714:#define CATCH_REQUIRE_FALSE( ... )  (void)(0)
        -:12715:
        -:12716:#define CATCH_REQUIRE_THROWS( ... ) (void)(0)
        -:12717:#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
        -:12718:#define CATCH_REQUIRE_THROWS_WITH( expr, matcher )     (void)(0)
        -:12719:#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -:12720:#define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
        -:12721:#endif// CATCH_CONFIG_DISABLE_MATCHERS
        -:12722:#define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)
        -:12723:
        -:12724:#define CATCH_CHECK( ... )         (void)(0)
        -:12725:#define CATCH_CHECK_FALSE( ... )   (void)(0)
        -:12726:#define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)
        -:12727:#define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))
        -:12728:#define CATCH_CHECK_NOFAIL( ... )  (void)(0)
        -:12729:
        -:12730:#define CATCH_CHECK_THROWS( ... )  (void)(0)
        -:12731:#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
        -:12732:#define CATCH_CHECK_THROWS_WITH( expr, matcher )     (void)(0)
        -:12733:#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -:12734:#define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
        -:12735:#endif // CATCH_CONFIG_DISABLE_MATCHERS
        -:12736:#define CATCH_CHECK_NOTHROW( ... ) (void)(0)
        -:12737:
        -:12738:#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -:12739:#define CATCH_CHECK_THAT( arg, matcher )   (void)(0)
        -:12740:
        -:12741:#define CATCH_REQUIRE_THAT( arg, matcher ) (void)(0)
        -:12742:#endif // CATCH_CONFIG_DISABLE_MATCHERS
        -:12743:
        -:12744:#define CATCH_INFO( msg )    (void)(0)
        -:12745:#define CATCH_WARN( msg )    (void)(0)
        -:12746:#define CATCH_CAPTURE( msg ) (void)(0)
        -:12747:
        -:12748:#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
        -:12749:#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
        -:12750:#define CATCH_METHOD_AS_TEST_CASE( method, ... )
        -:12751:#define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)
        -:12752:#define CATCH_SECTION( ... )
        -:12753:#define CATCH_FAIL( ... ) (void)(0)
        -:12754:#define CATCH_FAIL_CHECK( ... ) (void)(0)
        -:12755:#define CATCH_SUCCEED( ... ) (void)(0)
        -:12756:
        -:12757:#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
        -:12758:
        -:12759:// "BDD-style" convenience wrappers
        -:12760:#define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
        -:12761:#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
        -:12762:#define CATCH_GIVEN( desc )
        -:12763:#define CATCH_WHEN( desc )
        -:12764:#define CATCH_AND_WHEN( desc )
        -:12765:#define CATCH_THEN( desc )
        -:12766:#define CATCH_AND_THEN( desc )
        -:12767:
        -:12768:// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
        -:12769:#else
        -:12770:
        -:12771:#define REQUIRE( ... )       (void)(0)
        -:12772:#define REQUIRE_FALSE( ... ) (void)(0)
        -:12773:
        -:12774:#define REQUIRE_THROWS( ... ) (void)(0)
        -:12775:#define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
        -:12776:#define REQUIRE_THROWS_WITH( expr, matcher ) (void)(0)
        -:12777:#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -:12778:#define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
        -:12779:#endif // CATCH_CONFIG_DISABLE_MATCHERS
        -:12780:#define REQUIRE_NOTHROW( ... ) (void)(0)
        -:12781:
        -:12782:#define CHECK( ... ) (void)(0)
        -:12783:#define CHECK_FALSE( ... ) (void)(0)
        -:12784:#define CHECKED_IF( ... ) if (__VA_ARGS__)
        -:12785:#define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))
        -:12786:#define CHECK_NOFAIL( ... ) (void)(0)
        -:12787:
        -:12788:#define CHECK_THROWS( ... )  (void)(0)
        -:12789:#define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
        -:12790:#define CHECK_THROWS_WITH( expr, matcher ) (void)(0)
        -:12791:#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -:12792:#define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
        -:12793:#endif // CATCH_CONFIG_DISABLE_MATCHERS
        -:12794:#define CHECK_NOTHROW( ... ) (void)(0)
        -:12795:
        -:12796:#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
        -:12797:#define CHECK_THAT( arg, matcher ) (void)(0)
        -:12798:
        -:12799:#define REQUIRE_THAT( arg, matcher ) (void)(0)
        -:12800:#endif // CATCH_CONFIG_DISABLE_MATCHERS
        -:12801:
        -:12802:#define INFO( msg ) (void)(0)
        -:12803:#define WARN( msg ) (void)(0)
        -:12804:#define CAPTURE( msg ) (void)(0)
        -:12805:
        -:12806:#define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
        -:12807:#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
        -:12808:#define METHOD_AS_TEST_CASE( method, ... )
        -:12809:#define REGISTER_TEST_CASE( Function, ... ) (void)(0)
        -:12810:#define SECTION( ... )
        -:12811:#define FAIL( ... ) (void)(0)
        -:12812:#define FAIL_CHECK( ... ) (void)(0)
        -:12813:#define SUCCEED( ... ) (void)(0)
        -:12814:#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
        -:12815:
        -:12816:#endif
        -:12817:
        -:12818:#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
        -:12819:
        -:12820:// "BDD-style" convenience wrappers
        -:12821:#define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) )
        -:12822:#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
        -:12823:
        -:12824:#define GIVEN( desc )
        -:12825:#define WHEN( desc )
        -:12826:#define AND_WHEN( desc )
        -:12827:#define THEN( desc )
        -:12828:#define AND_THEN( desc )
        -:12829:
        -:12830:using Catch::Detail::Approx;
        -:12831:
        -:12832:#endif
        -:12833:
        -:12834:#endif // ! CATCH_CONFIG_IMPL_ONLY
        -:12835:
        -:12836:// start catch_reenable_warnings.h
        -:12837:
        -:12838:
        -:12839:#ifdef __clang__
        -:12840:#    ifdef __ICC // icpc defines the __clang__ macro
        -:12841:#        pragma warning(pop)
        -:12842:#    else
        -:12843:#        pragma clang diagnostic pop
        -:12844:#    endif
        -:12845:#elif defined __GNUC__
        -:12846:#    pragma GCC diagnostic pop
        -:12847:#endif
        -:12848:
        -:12849:// end catch_reenable_warnings.h
        -:12850:// end catch.hpp
        -:12851:#endif // TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
        -:12852:
